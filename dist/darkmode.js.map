{"version":3,"file":"darkmode.js","mappings":";;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C,CAAC,EAAE,SAAI;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,8CAA8C;AACnD;AACA;AACA;AACA,KAAK,8CAA8C;AACnD;AACA;AACA;AACA;AACA,KAAK,wDAAwD;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,8CAA8C;AACnD;AACA;AACA;AACA,KAAK,wDAAwD;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,8CAA8C;AACnD;AACA;AACA;AACA,KAAK,wDAAwD;AAC7D;AACA;AACA;AACA,KAAK,8CAA8C;AACnD;AACA;AACA;AACA,KAAK,8CAA8C;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,2BAA2B,EAAE,cAAc;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,wCAAwC,OAAO;AAC/C;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,IAAI;AACnE;AACA;AACA;AACA,kCAAkC,KAAK,EAAE,iBAAiB,EAAE,oBAAoB;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,IAAI;AACvB;AACA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,kCAAkC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,wCAAwC;AAC7C;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,gCAAgC;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA,uCAAuC,YAAY;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,KAAK,EAAE,UAAU,EAAE,MAAM,OAAO;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,kBAAkB,EAAE,UAAU;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,6BAA6B,GAAG;AAC5D;AACA,yCAAyC,mBAAmB,WAAW;AACvE;AACA;AACA;AACA,0CAA0C,kBAAkB,cAAc;AAC1E;AACA,yCAAyC,kBAAkB,cAAc;AACzE;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,SAAS;AACzD;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,SAAS;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,SAAS;AAClD;AACA,iDAAiD,UAAU;AAC3D;AACA,qDAAqD,UAAU;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,gCAAgC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,kBAAkB;AACzD;AACA;AACA,qCAAqC,gBAAgB;AACrD;AACA;AACA,sCAAsC,iBAAiB;AACvD;AACA;AACA,kCAAkC,aAAa;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,SAAS;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,SAAS;AACxD;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,eAAe;AACtC;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,uBAAuB,iCAAiC;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B;AACA,2BAA2B,WAAW,IAAI,WAAW,IAAI,WAAW,IAAI,cAAc;AACtF;AACA,sBAAsB,WAAW,IAAI,WAAW,IAAI,WAAW;AAC/D;AACA,6BAA6B,WAAW;AACxC,mBAAmB;AACnB;AACA;AACA;AACA;AACA,0BAA0B,kBAAkB,EAAE,eAAe;AAC7D,aAAa;AACb,sBAAsB;AACtB;AACA;AACA,eAAe,YAAY;AAC3B;AACA,2BAA2B,WAAW,IAAI,iBAAiB,KAAK,iBAAiB,KAAK,cAAc;AACpG;AACA,sBAAsB,WAAW,IAAI,iBAAiB,KAAK,iBAAiB;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,yBAAyB,WAAW;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,KAAK,EAAE,KAAK;AAC5C;AACA;AACA,qDAAqD,KAAK,EAAE,KAAK;AACjE,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,yBAAyB;AAC5E;AACA;AACA;AACA;AACA,8BAA8B,KAAK,IAAI,KAAK,IAAI,KAAK,IAAI,wBAAwB;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,OAAO;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,WAAW;AACtD,+CAA+C,YAAY;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,sCAAsC,gBAAgB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,oDAAoD,gBAAgB;AACpE;AACA;AACA,sBAAsB;AACtB;AACA,wDAAwD,gBAAgB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,gDAAgD,iBAAiB;AACjE;AACA;AACA;AACA,aAAa;AACb,oCAAoC,+BAA+B;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,KAAK,eAAe;AAC/D;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,gBAAgB,KAAK,GAAG,IAAI,UAAU,UAAU;AACvE;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,cAAc,EAAE,qEAAqE;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,WAAW;AAC1C,cAAc;AACd;AACA;AACA,SAAS;AACT;AACA,yCAAyC,GAAG,GAAG;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,aAAa;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,aAAa;AACvE;AACA;AACA,8CAA8C,aAAa;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,YAAY;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iCAAiC,EAAE,IAAI;AAClE;AACA;AACA;AACA,kBAAkB;AAClB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iCAAiC,EAAE,IAAI;AAC9D;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,UAAU;AACV;AACA;AACA,uBAAuB,6BAA6B,EAAE,IAAI;AAC1D;AACA;AACA,UAAU;AACV;AACA;AACA,uBAAuB,6BAA6B,EAAE,IAAI;AAC1D;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA,2CAA2C,sBAAsB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB,cAAc;AACd;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,8BAA8B;AAC5D;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,0DAA0D,UAAU,IAAI,YAAY;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,IAAI;AACrE;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,yBAAyB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,YAAY;AAChC,wBAAwB,WAAW;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,uBAAuB;AACzD;AACA;AACA;AACA;AACA;AACA,yGAAyG,MAAM,YAAY,OAAO;AAClI;AACA;AACA,oDAAoD,OAAO;AAC3D;AACA;AACA,6BAA6B,MAAM,YAAY,OAAO,uDAAuD,QAAQ;AACrH;AACA;AACA;AACA,uCAAuC,SAAS,UAAU;AAC1D;AACA;AACA,wBAAwB,gBAAgB;AACxC;AACA;AACA,wCAAwC,sBAAsB;AAC9D;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,kBAAkB;AAClB,mBAAmB;AACnB,oBAAoB;AACpB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA,kCAAkC,gBAAgB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,0BAA0B,IAAI,uBAAuB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,0BAA0B;AAC1B;AACA;AACA,yCAAyC,KAAK,GAAG,qBAAqB;AACtE,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,UAAU;AACrC,SAAS;AACT;AACA,2BAA2B,YAAY;AACvC,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA,kCAAkC,oBAAoB;AACtD,+BAA+B,uBAAuB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,WAAW;AAC5C;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,0BAA0B,WAAW;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,kBAAkB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,WAAW;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,kBAAkB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,WAAW;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,kBAAkB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,cAAc;AACd;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA,yCAAyC,uBAAuB,uBAAuB,UAAU,WAAW;AAC5G;AACA,yBAAyB;AACzB;AACA;AACA,8BAA8B;AAC9B,0DAA0D;AAC1D,yBAAyB;AACzB,gCAAgC;AAChC,0DAA0D;AAC1D,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,cAAc;AACxC;AACA,yCAAyC,uBAAuB,uBAAuB,UAAU;AACjG;AACA,yBAAyB;AACzB;AACA;AACA,eAAe,4FAA4F;AAC3G;AACA;AACA,iCAAiC,mBAAmB,oBAAoB,UAAU;AAClF;AACA;AACA,0BAA0B,uBAAuB,iBAAiB,UAAU;AAC5E;AACA,qBAAqB;AACrB,uBAAuB;AACvB;AACA,0BAA0B,uBAAuB,oBAAoB,UAAU;AAC/E;AACA,qBAAqB;AACrB,2BAA2B;AAC3B;AACA,iCAAiC,mBAAmB,uBAAuB,UAAU;AACrF;AACA,qBAAqB;AACrB,0BAA0B;AAC1B;AACA,0BAA0B,uBAAuB,iBAAiB,UAAU;AAC5E;AACA,qBAAqB;AACrB,mCAAmC;AACnC;AACA,0BAA0B,uBAAuB,uBAAuB,UAAU;AAClF;AACA,qBAAqB;AACrB;AACA;AACA,6CAA6C;AAC7C;AACA,qCAAqC,uBAAuB,uBAAuB,UAAU,WAAW;AACxG;AACA;AACA,0BAA0B,uBAAuB,iBAAiB,UAAU,WAAW;AACvF;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,oBAAoB;AACrC,iBAAiB;AACjB;AACA;AACA,iBAAiB,uBAAuB;AACxC,iBAAiB;AACjB;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,YAAY;AACtC;AACA,yCAAyC,0BAA0B,WAAW;AAC9E;AACA,qCAAqC,0BAA0B,WAAW;AAC1E,yBAAyB;AACzB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,uBAAuB;AACvE,gDAAgD,uBAAuB;AACvE,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,gBAAgB;AAChB,oCAAoC,YAAY,EAAE,YAAY;AAC9D,cAAc;AACd;AACA;AACA,8CAA8C,OAAO;AACrD;AACA,+BAA+B,OAAO;AACtC;AACA,4CAA4C,OAAO;AACnD;AACA;AACA,2BAA2B,uDAAuD;AAClF;AACA;AACA,qCAAqC,uBAAuB,uBAAuB,UAAU,WAAW;AACxG;AACA;AACA,iCAAiC,mBAAmB,oBAAoB,UAAU,WAAW;AAC7F;AACA;AACA,0BAA0B,uBAAuB,iBAAiB,UAAU,WAAW;AACvF;AACA,qBAAqB;AACrB,wEAAwE;AACxE,6DAA6D;AAC7D,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B,iBAAiB;AACjB;AACA;AACA,8BAA8B,uBAAuB;AACrD;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,uBAAuB,+BAA+B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,iCAAiC,EAAE,0BAA0B;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,kBAAkB,GAAG,uBAAuB,kBAAkB,SAAS,EAAE,gCAAgC;AAC5I;AACA;AACA;AACA,iBAAiB;AACjB;AACA,8BAA8B,aAAa,GAAG,gDAAgD,GAAG,qBAAqB;AACtH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,QAAQ;AACnD;AACA;AACA,mCAAmC,IAAI;AACvC;AACA;AACA;AACA,uBAAuB,gDAAgD;AACvE;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,OAAO;AAC/D;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,oDAAoD,OAAO;AAC3D;AACA;AACA;AACA,qBAAqB;AACrB,qCAAqC,SAAS;AAC9C,kBAAkB;AAClB,mDAAmD,OAAO;AAC1D;AACA,qCAAqC,OAAO;AAC5C,kBAAkB;AAClB,wDAAwD,OAAO;AAC/D;AACA;AACA;AACA;AACA,qBAAqB;AACrB,qCAAqC,SAAS;AAC9C,kBAAkB;AAClB,uDAAuD,OAAO;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,mDAAmD;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,yCAAyC,EAAE,8BAA8B,EAAE,+DAA+D;AACjK,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qCAAqC,EAAE,oCAAoC;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB,kBAAkB;AAClB;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA,qCAAqC,SAAS,IAAI,OAAO;AACzD;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,YAAY;AAC/B,yBAAyB,+CAA+C;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,gBAAgB;AACnC;AACA;AACA;AACA,kCAAkC,QAAQ,IAAI,cAAc;AAC5D;AACA,8BAA8B,QAAQ;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA,0BAA0B,QAAQ,IAAI,YAAY;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,iCAAiC,KAAK;AACtC;AACA;AACA,mCAAmC,KAAK;AACxC;AACA;AACA,qCAAqC,KAAK;AAC1C;AACA;AACA,oCAAoC,KAAK;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,IAAI,mCAAmC,EAAE;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,IAAI,QAAQ,IAAI,QAAQ,IAAI;AAC/D,mCAAmC,IAAI,SAAS,IAAI,SAAS,IAAI;AACjE;AACA;AACA;AACA;AACA,iCAAiC,SAAS,IAAI,SAAS,IAAI,SAAS;AACpE,oBAAoB;AACpB;AACA,gBAAgB;AAChB;AACA;AACA,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,cAAc,IAAI,cAAc,IAAI,cAAc;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,gBAAgB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,IAAI,GAAG,YAAY;AAC/C,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,mCAAmC,EAAE,UAAU;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,wBAAwB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,eAAe;AACjD;AACA,2BAA2B,4BAA4B;AACvD;AACA,wCAAwC,SAAS,IAAI,MAAM,EAAE,gCAAgC;AAC7F;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,mCAAmC;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,qCAAqC;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,0BAA0B,wCAAwC;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,2BAA2B,MAAM;AACjC;AACA,+BAA+B,OAAO;AACtC;AACA;AACA,sCAAsC,mBAAmB;AACzD;AACA;AACA;AACA;AACA;AACA,+BAA+B,MAAM;AACrC;AACA,oDAAoD,QAAQ;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,gDAAgD,iBAAiB;AACjE;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,yDAAyD,oBAAoB;AAC7E;AACA,qBAAqB;AACrB;AACA,iBAAiB;AACjB;AACA;AACA,uBAAuB,qBAAqB;AAC5C;AACA;AACA;AACA;AACA;AACA,uBAAuB,qBAAqB;AAC5C;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,QAAQ;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,QAAQ;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,QAAQ;AACvE;AACA;AACA,0EAA0E;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,+BAA+B;AAC/D;AACA;AACA;AACA;AACA,gCAAgC,sBAAsB;AACtD;AACA;AACA;AACA;AACA,gCAAgC,yBAAyB;AACzD;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,oBAAoB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,KAAK;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,8BAA8B;AACjD;AACA,wBAAwB,SAAS,GAAG;AACpC,yBAAyB,QAAQ,QAAQ,WAAW,aAAa;AACjE,sBAAsB;AACtB;AACA,aAAa;AACb;AACA,kDAAkD;AAClD,6DAA6D;AAC7D,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,uCAAuC,UAAU;AACjD;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,+CAA+C,YAAY;AAC3D,2CAA2C,WAAW;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,oCAAoC,SAAS;AAC7C;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,KAAK,IAAI,sBAAsB;AACxD;AACA,gDAAgD,KAAK,IAAI,YAAY;AACrE;AACA;AACA;AACA,gDAAgD,SAAS;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,qBAAqB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,SAAS;AACxD;AACA,qBAAqB;AACrB,2CAA2C,gBAAgB;AAC3D;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,SAAS,gBAAgB;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,EAAE;AACzC,uCAAuC,EAAE;AACzC;AACA,4BAA4B,MAAM;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,IAAI;AACtC;AACA;AACA;AACA;AACA;AACA,uCAAuC,EAAE;AACzC,uCAAuC,EAAE;AACzC;AACA,4BAA4B,MAAM;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,eAAe;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,iDAAiD,mBAAmB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,sCAAsC,sBAAsB;AAC5D,2BAA2B,YAAY;AACvC,oCAAoC,uBAAuB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,6CAA6C,gBAAgB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,0CAA0C,cAAc;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,iCAAiC;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,eAAe;AAC1D;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,QAAQ;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,WAAW,sBAAsB,UAAU;AAC9E;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,mDAAmD,cAAc;AACjE,qDAAqD,cAAc;AACnE;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,eAAe;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,WAAW;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,gEAAgE,SAAS,KAAK;AAC9E;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gBAAgB;AAC5C;AACA;AACA,4CAA4C,sBAAsB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,iCAAiC;AACjC,qBAAqB;AACrB;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,2CAA2C;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iDAAiD,4BAA4B;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,mBAAmB,YAAY;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wDAAwD;AAC5E;AACA,uBAAuB,YAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,UAAU;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,UAAU;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,0BAA0B;AAC7C,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA,iBAAiB,GAAG,WAAW;AAC/B,kBAAkB;AAClB;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,mDAAmD,wBAAwB;AAC3E,6CAA6C,kBAAkB;AAC/D,qDAAqD,wDAAwD;AAC7G,+CAA+C,wDAAwD;AACvG,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,YAAY,IAAI,uBAAuB,IAAI,iCAAiC;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,0BAA0B;AAC7C,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA,iBAAiB,GAAG,WAAW;AAC/B,kBAAkB;AAClB;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oBAAoB;AAC5C;AACA,gCAAgC,qBAAqB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,gCAAgC,gBAAgB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,MAAM;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,mBAAmB;AAClE;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA,iCAAiC,MAAM;AACvC,2BAA2B,UAAU;AACrC;AACA,iBAAiB;AACjB;AACA;AACA,iCAAiC,eAAe;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,mCAAmC,kBAAkB;AACrD,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,mBAAmB;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,eAAe,kBAAkB,mBAAmB;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,kBAAkB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,iCAAiC;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,mBAAmB;AAC1E;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,6CAA6C,+BAA+B;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,iBAAiB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,iBAAiB;AACjB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,4CAA4C,+BAA+B;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,+BAA+B,mBAAmB;AAClD,0BAA0B,OAAO,EAAE,MAAM,EAAE,QAAQ;AACnD,0DAA0D,OAAO,EAAE,IAAI;AACvE,0BAA0B,QAAQ;AAClC;AACA,kCAAkC,wBAAwB;AAC1D;AACA;AACA;AACA,uBAAuB,OAAO,EAAE,SAAS,EAAE,iCAAiC,EAAE;AAC9E;AACA,aAAa;AACb;AACA,6BAA6B,2BAA2B;AACxD;AACA,uBAAuB,OAAO,EAAE,IAAI,EAAE,SAAS,IAAI,MAAM,EAAE,gCAAgC;AAC3F;AACA,aAAa;AACb,0BAA0B,QAAQ;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,uCAAuC,QAAQ;AAC/C;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,qDAAqD,aAAa;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,SAAS;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,KAAK;AACL,qCAAqC;AACrC,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,mCAAmC;AACnC;AACA,qBAAqB;AACrB;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,UAAU;AACV;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,YAAY;AAC9D,CAAC;;;;;;;;;;;;ACtjQD;;;;;;;UCAA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;;;;ACN6D;AAE/B;;AAE9B;AACAE,QAAQ,CAACC,gBAAgB,CAAC,kBAAkB,EAAE,MAAM;EACnD,MAAMC,QAAQ,GAAG,IAAIC,QAAQ,CAAC,CAAC;AAChC,CAAC,CAAC;AAEF,MAAMA,QAAQ,CAAC;EACdC,WAAWA,CAAA,EAAG;IACb,IAAI,CAACC,SAAS,GAAG,KAAK;IACtB,IAAI,CAACC,YAAY,GAAG,CAAC;IACrB,IAAI,CAACC,IAAI,CAAC,CAAC;EACZ;EAEAA,IAAIA,CAAA,EAAG;IACN;IACA,IAAI,CAACC,oBAAoB,CAAC,CAAC;;IAE3B;IACA,MAAMC,eAAe,GAAGC,YAAY,CAACC,OAAO,CAAC,mBAAmB,CAAC;IACjE,IAAIF,eAAe,KAAK,SAAS,EAAE;MAClC,IAAI,CAACG,MAAM,CAAC,CAAC;MACb;MACAZ,QAAQ,CAACa,gBAAgB,CAAC,iBAAiB,CAAC,CAACC,OAAO,CAAEC,QAAQ,IAAK;QAClEA,QAAQ,CAACC,SAAS,CAACC,GAAG,CAAC,QAAQ,CAAC;MACjC,CAAC,CAAC;IACH;;IAEA;IACA,IAAI,CAACC,YAAY,CAAC,CAAC;;IAEnB;IACA,IAAI,CAACC,cAAc,CAAC,CAAC;EACtB;EAEAC,mBAAmBA,CAACC,SAAS,GAAG,EAAE,EAAE;IACnC,MAAMC,aAAa,GAAGtB,QAAQ,CAACuB,aAAa,CAAC,KAAK,CAAC;IACnDD,aAAa,CAACD,SAAS,GAAG,kBAAkBA,SAAS,EAAE,CAACG,IAAI,CAAC,CAAC;IAE9D,MAAMC,KAAK,GAAGzB,QAAQ,CAACuB,aAAa,CAAC,KAAK,CAAC;IAC3CE,KAAK,CAACJ,SAAS,GAAG,uBAAuB;IAEzC,MAAMK,MAAM,GAAG1B,QAAQ,CAACuB,aAAa,CAAC,KAAK,CAAC;IAC5CG,MAAM,CAACL,SAAS,GAAG,wBAAwB;IAE3CC,aAAa,CAACK,WAAW,CAACF,KAAK,CAAC;IAChCH,aAAa,CAACK,WAAW,CAACD,MAAM,CAAC;IAEjC,OAAOJ,aAAa;EACrB;EAEAd,oBAAoBA,CAAA,EAAG;IACtB,MAAMoB,cAAc,GAAG,IAAI,CAACR,mBAAmB,CAAC,UAAU,CAAC;IAC3DpB,QAAQ,CAAC6B,IAAI,CAACF,WAAW,CAACC,cAAc,CAAC;EAC1C;;EAEA;EACAE,iBAAiBA,CAAA,EAAG;IACnB,MAAMC,QAAQ,GAAG/B,QAAQ,CAACa,gBAAgB,CAAC,iBAAiB,CAAC;IAC7DkB,QAAQ,CAACjB,OAAO,CAAEC,QAAQ,IAAK;MAC9BA,QAAQ,CAACC,SAAS,CAACC,GAAG,CAAC,SAAS,IAAI,CAACX,YAAY,EAAE,CAAC;IACrD,CAAC,CAAC;EACH;EAEAY,YAAYA,CAAA,EAAG;IACd,MAAMa,QAAQ,GAAG/B,QAAQ,CAACa,gBAAgB,CAAC,iBAAiB,CAAC;IAC7DkB,QAAQ,CAACjB,OAAO,CAAEC,QAAQ,IAAK;MAC9BA,QAAQ,CAACd,gBAAgB,CAAC,OAAO,EAAE,MAAM;QACxC,IAAI,CAAC+B,MAAM,CAAC,CAAC;QACb;QACAhC,QAAQ,CAACa,gBAAgB,CAAC,iBAAiB,CAAC,CAACC,OAAO,CAAEmB,CAAC,IAAK;UAC3DA,CAAC,CAACjB,SAAS,CAACgB,MAAM,CAAC,QAAQ,EAAE,IAAI,CAAC3B,SAAS,CAAC;QAC7C,CAAC,CAAC;MACH,CAAC,CAAC;IACH,CAAC,CAAC;EACH;EAEAO,MAAMA,CAAA,EAAG;IACRd,0DAAc,CAAC;MACdoC,UAAU,EAAE,GAAG;MACfC,QAAQ,EAAE,GAAG;MACbC,KAAK,EAAE,CAAC;MACRC,yBAAyB,EAAE,SAAS;MACpCC,mBAAmB,EAAE;IACtB,CAAC,CAAC;IACF,IAAI,CAACjC,SAAS,GAAG,IAAI;IACrBK,YAAY,CAAC6B,OAAO,CAAC,mBAAmB,EAAE,SAAS,CAAC;IACpDvC,QAAQ,CAAC6B,IAAI,CAACb,SAAS,CAACC,GAAG,CAAC,mBAAmB,CAAC;EACjD;EAEAuB,OAAOA,CAAA,EAAG;IACTzC,2DAAe,CAAC,CAAC;IACjB,IAAI,CAACM,SAAS,GAAG,KAAK;IACtBK,YAAY,CAAC6B,OAAO,CAAC,mBAAmB,EAAE,UAAU,CAAC;IACrDvC,QAAQ,CAAC6B,IAAI,CAACb,SAAS,CAACyB,MAAM,CAAC,mBAAmB,CAAC;EACpD;EAEAT,MAAMA,CAAA,EAAG;IACR,IAAI,IAAI,CAAC3B,SAAS,EAAE;MACnB,IAAI,CAACmC,OAAO,CAAC,CAAC;IACf,CAAC,MAAM;MACN,IAAI,CAAC5B,MAAM,CAAC,CAAC;IACd;EACD;AACD;AAEA,iEAAe,IAAIT,QAAQ,CAAC,CAAC,E","sources":["webpack://@plugpress/nightly/./node_modules/darkreader/darkreader.js","webpack://@plugpress/nightly/./src/scss/darkmode.scss","webpack://@plugpress/nightly/webpack/bootstrap","webpack://@plugpress/nightly/webpack/runtime/define property getters","webpack://@plugpress/nightly/webpack/runtime/hasOwnProperty shorthand","webpack://@plugpress/nightly/webpack/runtime/make namespace object","webpack://@plugpress/nightly/./src/darkmode.js"],"sourcesContent":["/**\r\n * Dark Reader v4.9.101\r\n * https://darkreader.org/\r\n */\r\n\r\n(function (global, factory) {\r\n    typeof exports === \"object\" && typeof module !== \"undefined\"\r\n        ? factory(exports)\r\n        : typeof define === \"function\" && define.amd\r\n          ? define([\"exports\"], factory)\r\n          : ((global =\r\n                typeof globalThis !== \"undefined\"\r\n                    ? globalThis\r\n                    : global || self),\r\n            factory((global.DarkReader = {})));\r\n})(this, function (exports) {\r\n    \"use strict\";\r\n\r\n    var MessageTypeUItoBG;\r\n    (function (MessageTypeUItoBG) {\r\n        MessageTypeUItoBG[\"GET_DATA\"] = \"ui-bg-get-data\";\r\n        MessageTypeUItoBG[\"GET_DEVTOOLS_DATA\"] = \"ui-bg-get-devtools-data\";\r\n        MessageTypeUItoBG[\"SUBSCRIBE_TO_CHANGES\"] =\r\n            \"ui-bg-subscribe-to-changes\";\r\n        MessageTypeUItoBG[\"UNSUBSCRIBE_FROM_CHANGES\"] =\r\n            \"ui-bg-unsubscribe-from-changes\";\r\n        MessageTypeUItoBG[\"CHANGE_SETTINGS\"] = \"ui-bg-change-settings\";\r\n        MessageTypeUItoBG[\"SET_THEME\"] = \"ui-bg-set-theme\";\r\n        MessageTypeUItoBG[\"TOGGLE_ACTIVE_TAB\"] = \"ui-bg-toggle-active-tab\";\r\n        MessageTypeUItoBG[\"MARK_NEWS_AS_READ\"] = \"ui-bg-mark-news-as-read\";\r\n        MessageTypeUItoBG[\"MARK_NEWS_AS_DISPLAYED\"] =\r\n            \"ui-bg-mark-news-as-displayed\";\r\n        MessageTypeUItoBG[\"LOAD_CONFIG\"] = \"ui-bg-load-config\";\r\n        MessageTypeUItoBG[\"APPLY_DEV_DYNAMIC_THEME_FIXES\"] =\r\n            \"ui-bg-apply-dev-dynamic-theme-fixes\";\r\n        MessageTypeUItoBG[\"RESET_DEV_DYNAMIC_THEME_FIXES\"] =\r\n            \"ui-bg-reset-dev-dynamic-theme-fixes\";\r\n        MessageTypeUItoBG[\"APPLY_DEV_INVERSION_FIXES\"] =\r\n            \"ui-bg-apply-dev-inversion-fixes\";\r\n        MessageTypeUItoBG[\"RESET_DEV_INVERSION_FIXES\"] =\r\n            \"ui-bg-reset-dev-inversion-fixes\";\r\n        MessageTypeUItoBG[\"APPLY_DEV_STATIC_THEMES\"] =\r\n            \"ui-bg-apply-dev-static-themes\";\r\n        MessageTypeUItoBG[\"RESET_DEV_STATIC_THEMES\"] =\r\n            \"ui-bg-reset-dev-static-themes\";\r\n        MessageTypeUItoBG[\"COLOR_SCHEME_CHANGE\"] = \"ui-bg-color-scheme-change\";\r\n        MessageTypeUItoBG[\"HIDE_HIGHLIGHTS\"] = \"ui-bg-hide-highlights\";\r\n    })(MessageTypeUItoBG || (MessageTypeUItoBG = {}));\r\n    var MessageTypeBGtoUI;\r\n    (function (MessageTypeBGtoUI) {\r\n        MessageTypeBGtoUI[\"CHANGES\"] = \"bg-ui-changes\";\r\n    })(MessageTypeBGtoUI || (MessageTypeBGtoUI = {}));\r\n    var DebugMessageTypeBGtoUI;\r\n    (function (DebugMessageTypeBGtoUI) {\r\n        DebugMessageTypeBGtoUI[\"CSS_UPDATE\"] = \"debug-bg-ui-css-update\";\r\n        DebugMessageTypeBGtoUI[\"UPDATE\"] = \"debug-bg-ui-update\";\r\n    })(DebugMessageTypeBGtoUI || (DebugMessageTypeBGtoUI = {}));\r\n    var MessageTypeBGtoCS;\r\n    (function (MessageTypeBGtoCS) {\r\n        MessageTypeBGtoCS[\"ADD_CSS_FILTER\"] = \"bg-cs-add-css-filter\";\r\n        MessageTypeBGtoCS[\"ADD_DYNAMIC_THEME\"] = \"bg-cs-add-dynamic-theme\";\r\n        MessageTypeBGtoCS[\"ADD_STATIC_THEME\"] = \"bg-cs-add-static-theme\";\r\n        MessageTypeBGtoCS[\"ADD_SVG_FILTER\"] = \"bg-cs-add-svg-filter\";\r\n        MessageTypeBGtoCS[\"CLEAN_UP\"] = \"bg-cs-clean-up\";\r\n        MessageTypeBGtoCS[\"FETCH_RESPONSE\"] = \"bg-cs-fetch-response\";\r\n        MessageTypeBGtoCS[\"UNSUPPORTED_SENDER\"] = \"bg-cs-unsupported-sender\";\r\n    })(MessageTypeBGtoCS || (MessageTypeBGtoCS = {}));\r\n    var DebugMessageTypeBGtoCS;\r\n    (function (DebugMessageTypeBGtoCS) {\r\n        DebugMessageTypeBGtoCS[\"RELOAD\"] = \"debug-bg-cs-reload\";\r\n    })(DebugMessageTypeBGtoCS || (DebugMessageTypeBGtoCS = {}));\r\n    var MessageTypeCStoBG;\r\n    (function (MessageTypeCStoBG) {\r\n        MessageTypeCStoBG[\"COLOR_SCHEME_CHANGE\"] = \"cs-bg-color-scheme-change\";\r\n        MessageTypeCStoBG[\"DARK_THEME_DETECTED\"] = \"cs-bg-dark-theme-detected\";\r\n        MessageTypeCStoBG[\"DARK_THEME_NOT_DETECTED\"] =\r\n            \"cs-bg-dark-theme-not-detected\";\r\n        MessageTypeCStoBG[\"FETCH\"] = \"cs-bg-fetch\";\r\n        MessageTypeCStoBG[\"DOCUMENT_CONNECT\"] = \"cs-bg-document-connect\";\r\n        MessageTypeCStoBG[\"DOCUMENT_FORGET\"] = \"cs-bg-document-forget\";\r\n        MessageTypeCStoBG[\"DOCUMENT_FREEZE\"] = \"cs-bg-document-freeze\";\r\n        MessageTypeCStoBG[\"DOCUMENT_RESUME\"] = \"cs-bg-document-resume\";\r\n    })(MessageTypeCStoBG || (MessageTypeCStoBG = {}));\r\n    var DebugMessageTypeCStoBG;\r\n    (function (DebugMessageTypeCStoBG) {\r\n        DebugMessageTypeCStoBG[\"LOG\"] = \"debug-cs-bg-log\";\r\n    })(DebugMessageTypeCStoBG || (DebugMessageTypeCStoBG = {}));\r\n    var MessageTypeCStoUI;\r\n    (function (MessageTypeCStoUI) {\r\n        MessageTypeCStoUI[\"EXPORT_CSS_RESPONSE\"] = \"cs-ui-export-css-response\";\r\n    })(MessageTypeCStoUI || (MessageTypeCStoUI = {}));\r\n    var MessageTypeUItoCS;\r\n    (function (MessageTypeUItoCS) {\r\n        MessageTypeUItoCS[\"EXPORT_CSS\"] = \"ui-cs-export-css\";\r\n    })(MessageTypeUItoCS || (MessageTypeUItoCS = {}));\r\n\r\n    const isNavigatorDefined = typeof navigator !== \"undefined\";\r\n    const userAgent = isNavigatorDefined\r\n        ? navigator.userAgentData &&\r\n          Array.isArray(navigator.userAgentData.brands)\r\n            ? navigator.userAgentData.brands\r\n                  .map(\r\n                      (brand) => `${brand.brand.toLowerCase()} ${brand.version}`\r\n                  )\r\n                  .join(\" \")\r\n            : navigator.userAgent.toLowerCase()\r\n        : \"some useragent\";\r\n    const platform = isNavigatorDefined\r\n        ? navigator.userAgentData &&\r\n          typeof navigator.userAgentData.platform === \"string\"\r\n            ? navigator.userAgentData.platform.toLowerCase()\r\n            : navigator.platform.toLowerCase()\r\n        : \"some platform\";\r\n    const isChromium =\r\n        userAgent.includes(\"chrome\") || userAgent.includes(\"chromium\");\r\n    const isFirefox =\r\n        userAgent.includes(\"firefox\") ||\r\n        userAgent.includes(\"thunderbird\") ||\r\n        userAgent.includes(\"librewolf\");\r\n    const isSafari = userAgent.includes(\"safari\") && !isChromium;\r\n    const isWindows = platform.startsWith(\"win\");\r\n    const isMacOS = platform.startsWith(\"mac\");\r\n    isNavigatorDefined && navigator.userAgentData\r\n        ? navigator.userAgentData.mobile\r\n        : userAgent.includes(\"mobile\");\r\n    const isShadowDomSupported = typeof ShadowRoot === \"function\";\r\n    const isMatchMediaChangeEventListenerSupported =\r\n        typeof MediaQueryList === \"function\" &&\r\n        typeof MediaQueryList.prototype.addEventListener === \"function\";\r\n    const isLayerRuleSupported = typeof CSSLayerBlockRule === \"function\";\r\n    (() => {\r\n        const m = userAgent.match(/chrom(?:e|ium)(?:\\/| )([^ ]+)/);\r\n        if (m && m[1]) {\r\n            return m[1];\r\n        }\r\n        return \"\";\r\n    })();\r\n    (() => {\r\n        const m = userAgent.match(/(?:firefox|librewolf)(?:\\/| )([^ ]+)/);\r\n        if (m && m[1]) {\r\n            return m[1];\r\n        }\r\n        return \"\";\r\n    })();\r\n    const isDefinedSelectorSupported = (() => {\r\n        try {\r\n            document.querySelector(\":defined\");\r\n            return true;\r\n        } catch (err) {\r\n            return false;\r\n        }\r\n    })();\r\n    const isCSSColorSchemePropSupported = (() => {\r\n        try {\r\n            if (typeof document === \"undefined\") {\r\n                return false;\r\n            }\r\n            const el = document.createElement(\"div\");\r\n            if (!el || typeof el.style !== \"object\") {\r\n                return false;\r\n            }\r\n            if (typeof el.style.colorScheme === \"string\") {\r\n                return true;\r\n            }\r\n            el.setAttribute(\"style\", \"color-scheme: dark\");\r\n            return el.style.colorScheme === \"dark\";\r\n        } catch (e) {\r\n            return false;\r\n        }\r\n    })();\r\n\r\n    async function getOKResponse(url, mimeType, origin) {\r\n        const credentials =\r\n            origin && url.startsWith(`${origin}/`) ? undefined : \"omit\";\r\n        const response = await fetch(url, {\r\n            cache: \"force-cache\",\r\n            credentials,\r\n            referrer: origin\r\n        });\r\n        if (\r\n            isFirefox &&\r\n            mimeType === \"text/css\" &&\r\n            url.startsWith(\"moz-extension://\") &&\r\n            url.endsWith(\".css\")\r\n        ) {\r\n            return response;\r\n        }\r\n        if (\r\n            mimeType &&\r\n            !response.headers.get(\"Content-Type\").startsWith(mimeType)\r\n        ) {\r\n            throw new Error(`Mime type mismatch when loading ${url}`);\r\n        }\r\n        if (!response.ok) {\r\n            throw new Error(\r\n                `Unable to load ${url} ${response.status} ${response.statusText}`\r\n            );\r\n        }\r\n        return response;\r\n    }\r\n    async function loadAsDataURL(url, mimeType) {\r\n        const response = await getOKResponse(url, mimeType);\r\n        return await readResponseAsDataURL(response);\r\n    }\r\n    async function loadAsBlob(url, mimeType) {\r\n        const response = await getOKResponse(url, mimeType);\r\n        return await response.blob();\r\n    }\r\n    async function readResponseAsDataURL(response) {\r\n        const blob = await response.blob();\r\n        const dataURL = await new Promise((resolve) => {\r\n            const reader = new FileReader();\r\n            reader.onloadend = () => resolve(reader.result);\r\n            reader.readAsDataURL(blob);\r\n        });\r\n        return dataURL;\r\n    }\r\n    async function loadAsText(url, mimeType, origin) {\r\n        const response = await getOKResponse(url, mimeType, origin);\r\n        return await response.text();\r\n    }\r\n\r\n    const throwCORSError = async (url) => {\r\n        return Promise.reject(\r\n            new Error(\r\n                [\r\n                    \"Embedded Dark Reader cannot access a cross-origin resource\",\r\n                    url,\r\n                    \"Overview your URLs and CORS policies or use\",\r\n                    \"`DarkReader.setFetchMethod(fetch: (url) => Promise<Response>))`.\",\r\n                    \"See if using `DarkReader.setFetchMethod(window.fetch)`\",\r\n                    \"before `DarkReader.enable()` works.\"\r\n                ].join(\" \")\r\n            )\r\n        );\r\n    };\r\n    let fetcher = throwCORSError;\r\n    function setFetchMethod$1(fetch) {\r\n        if (fetch) {\r\n            fetcher = fetch;\r\n        } else {\r\n            fetcher = throwCORSError;\r\n        }\r\n    }\r\n    async function callFetchMethod(url) {\r\n        return await fetcher(url);\r\n    }\r\n\r\n    if (!window.chrome) {\r\n        window.chrome = {};\r\n    }\r\n    if (!chrome.runtime) {\r\n        chrome.runtime = {};\r\n    }\r\n    const messageListeners = new Set();\r\n    async function sendMessage(...args) {\r\n        if (args[0] && args[0].type === MessageTypeCStoBG.FETCH) {\r\n            const {id} = args[0];\r\n            try {\r\n                const {url, responseType} = args[0].data;\r\n                const response = await callFetchMethod(url);\r\n                let text;\r\n                if (responseType === \"data-url\") {\r\n                    text = await readResponseAsDataURL(response);\r\n                } else {\r\n                    text = await response.text();\r\n                }\r\n                messageListeners.forEach((cb) =>\r\n                    cb({\r\n                        type: MessageTypeBGtoCS.FETCH_RESPONSE,\r\n                        data: text,\r\n                        error: null,\r\n                        id\r\n                    })\r\n                );\r\n            } catch (error) {\r\n                console.error(error);\r\n                messageListeners.forEach((cb) =>\r\n                    cb({\r\n                        type: MessageTypeBGtoCS.FETCH_RESPONSE,\r\n                        data: null,\r\n                        error,\r\n                        id\r\n                    })\r\n                );\r\n            }\r\n        }\r\n    }\r\n    function addMessageListener(callback) {\r\n        messageListeners.add(callback);\r\n    }\r\n    if (typeof chrome.runtime.sendMessage === \"function\") {\r\n        const nativeSendMessage = chrome.runtime.sendMessage;\r\n        chrome.runtime.sendMessage = (...args) => {\r\n            sendMessage(...args);\r\n            nativeSendMessage.apply(chrome.runtime, args);\r\n        };\r\n    } else {\r\n        chrome.runtime.sendMessage = sendMessage;\r\n    }\r\n    if (!chrome.runtime.onMessage) {\r\n        chrome.runtime.onMessage = {};\r\n    }\r\n    if (typeof chrome.runtime.onMessage.addListener === \"function\") {\r\n        const nativeAddListener = chrome.runtime.onMessage.addListener;\r\n        chrome.runtime.onMessage.addListener = (...args) => {\r\n            addMessageListener(args[0]);\r\n            nativeAddListener.apply(chrome.runtime.onMessage, args);\r\n        };\r\n    } else {\r\n        chrome.runtime.onMessage.addListener = (...args) =>\r\n            addMessageListener(args[0]);\r\n    }\r\n\r\n    var ThemeEngine;\r\n    (function (ThemeEngine) {\r\n        ThemeEngine[\"cssFilter\"] = \"cssFilter\";\r\n        ThemeEngine[\"svgFilter\"] = \"svgFilter\";\r\n        ThemeEngine[\"staticTheme\"] = \"staticTheme\";\r\n        ThemeEngine[\"dynamicTheme\"] = \"dynamicTheme\";\r\n    })(ThemeEngine || (ThemeEngine = {}));\r\n\r\n    var AutomationMode;\r\n    (function (AutomationMode) {\r\n        AutomationMode[\"NONE\"] = \"\";\r\n        AutomationMode[\"TIME\"] = \"time\";\r\n        AutomationMode[\"SYSTEM\"] = \"system\";\r\n        AutomationMode[\"LOCATION\"] = \"location\";\r\n    })(AutomationMode || (AutomationMode = {}));\r\n\r\n    const DEFAULT_COLORS = {\r\n        darkScheme: {\r\n            background: \"#181a1b\",\r\n            text: \"#e8e6e3\"\r\n        },\r\n        lightScheme: {\r\n            background: \"#dcdad7\",\r\n            text: \"#181a1b\"\r\n        }\r\n    };\r\n    const DEFAULT_THEME = {\r\n        mode: 1,\r\n        brightness: 100,\r\n        contrast: 100,\r\n        grayscale: 0,\r\n        sepia: 0,\r\n        useFont: false,\r\n        fontFamily: isMacOS\r\n            ? \"Helvetica Neue\"\r\n            : isWindows\r\n              ? \"Segoe UI\"\r\n              : \"Open Sans\",\r\n        textStroke: 0,\r\n        engine: ThemeEngine.dynamicTheme,\r\n        stylesheet: \"\",\r\n        darkSchemeBackgroundColor: DEFAULT_COLORS.darkScheme.background,\r\n        darkSchemeTextColor: DEFAULT_COLORS.darkScheme.text,\r\n        lightSchemeBackgroundColor: DEFAULT_COLORS.lightScheme.background,\r\n        lightSchemeTextColor: DEFAULT_COLORS.lightScheme.text,\r\n        scrollbarColor: \"\",\r\n        selectionColor: \"auto\",\r\n        styleSystemControls: !isCSSColorSchemePropSupported,\r\n        lightColorScheme: \"Default\",\r\n        darkColorScheme: \"Default\",\r\n        immediateModify: false\r\n    };\r\n    const filterModeSites = [\r\n        \"*.officeapps.live.com\",\r\n        \"*.sharepoint.com\",\r\n        \"docs.google.com\",\r\n        \"onedrive.live.com\"\r\n    ];\r\n    ({\r\n        schemeVersion: 0,\r\n        enabled: true,\r\n        fetchNews: true,\r\n        theme: DEFAULT_THEME,\r\n        presets: [],\r\n        customThemes: filterModeSites.map((url) => {\r\n            const engine = isChromium\r\n                ? ThemeEngine.svgFilter\r\n                : ThemeEngine.cssFilter;\r\n            return {\r\n                url: [url],\r\n                theme: {...DEFAULT_THEME, engine},\r\n                builtIn: true\r\n            };\r\n        }),\r\n        enabledByDefault: true,\r\n        enabledFor: [],\r\n        disabledFor: [],\r\n        changeBrowserTheme: false,\r\n        syncSettings: true,\r\n        syncSitesFixes: false,\r\n        automation: {\r\n            enabled: false,\r\n            mode: AutomationMode.NONE,\r\n            behavior: \"OnOff\"\r\n        },\r\n        time: {\r\n            activation: \"18:00\",\r\n            deactivation: \"9:00\"\r\n        },\r\n        location: {\r\n            latitude: null,\r\n            longitude: null\r\n        },\r\n        previewNewDesign: false,\r\n        previewNewestDesign: false,\r\n        enableForPDF: true,\r\n        enableForProtectedPages: false,\r\n        enableContextMenus: false,\r\n        detectDarkTheme: true\r\n    });\r\n\r\n    function getMatches(regex, input, group = 0) {\r\n        const matches = [];\r\n        let m;\r\n        while ((m = regex.exec(input))) {\r\n            matches.push(m[group]);\r\n        }\r\n        return matches;\r\n    }\r\n    function getMatchesWithOffsets(regex, input, group = 0) {\r\n        const matches = [];\r\n        let m;\r\n        while ((m = regex.exec(input))) {\r\n            matches.push({text: m[group], offset: m.index});\r\n        }\r\n        return matches;\r\n    }\r\n    function getHashCode(text) {\r\n        const len = text.length;\r\n        let hash = 0;\r\n        for (let i = 0; i < len; i++) {\r\n            const c = text.charCodeAt(i);\r\n            hash = ((hash << 5) - hash + c) & 4294967295;\r\n        }\r\n        return hash;\r\n    }\r\n    function escapeRegExpSpecialChars(input) {\r\n        return input.replaceAll(/[\\^$.*+?\\(\\)\\[\\]{}|\\-\\\\]/g, \"\\\\$&\");\r\n    }\r\n    function getParenthesesRange(input, searchStartIndex = 0) {\r\n        return getOpenCloseRange(input, searchStartIndex, \"(\", \")\", []);\r\n    }\r\n    function getOpenCloseRange(\r\n        input,\r\n        searchStartIndex,\r\n        openToken,\r\n        closeToken,\r\n        excludeRanges\r\n    ) {\r\n        let indexOf;\r\n        if (excludeRanges.length === 0) {\r\n            indexOf = (token, pos) => input.indexOf(token, pos);\r\n        } else {\r\n            indexOf = (token, pos) =>\r\n                indexOfExcluding(input, token, pos, excludeRanges);\r\n        }\r\n        const {length} = input;\r\n        let depth = 0;\r\n        let firstOpenIndex = -1;\r\n        for (let i = searchStartIndex; i < length; i++) {\r\n            if (depth === 0) {\r\n                const openIndex = indexOf(openToken, i);\r\n                if (openIndex < 0) {\r\n                    break;\r\n                }\r\n                firstOpenIndex = openIndex;\r\n                depth++;\r\n                i = openIndex;\r\n            } else {\r\n                const closeIndex = indexOf(closeToken, i);\r\n                if (closeIndex < 0) {\r\n                    break;\r\n                }\r\n                const openIndex = indexOf(openToken, i);\r\n                if (openIndex < 0 || closeIndex <= openIndex) {\r\n                    depth--;\r\n                    if (depth === 0) {\r\n                        return {start: firstOpenIndex, end: closeIndex + 1};\r\n                    }\r\n                    i = closeIndex;\r\n                } else {\r\n                    depth++;\r\n                    i = openIndex;\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    function indexOfExcluding(input, search, position, excludeRanges) {\r\n        const i = input.indexOf(search, position);\r\n        const exclusion = excludeRanges.find((r) => i >= r.start && i < r.end);\r\n        if (exclusion) {\r\n            return indexOfExcluding(\r\n                input,\r\n                search,\r\n                exclusion.end,\r\n                excludeRanges\r\n            );\r\n        }\r\n        return i;\r\n    }\r\n    function splitExcluding(input, separator, excludeRanges) {\r\n        const parts = [];\r\n        let commaIndex = -1;\r\n        let currIndex = 0;\r\n        while (\r\n            (commaIndex = indexOfExcluding(\r\n                input,\r\n                separator,\r\n                currIndex,\r\n                excludeRanges\r\n            )) >= 0\r\n        ) {\r\n            parts.push(input.substring(currIndex, commaIndex).trim());\r\n            currIndex = commaIndex + 1;\r\n        }\r\n        parts.push(input.substring(currIndex).trim());\r\n        return parts;\r\n    }\r\n\r\n    let anchor;\r\n    const parsedURLCache = new Map();\r\n    function fixBaseURL($url) {\r\n        if (!anchor) {\r\n            anchor = document.createElement(\"a\");\r\n        }\r\n        anchor.href = $url;\r\n        return anchor.href;\r\n    }\r\n    function parseURL($url, $base = null) {\r\n        const key = `${$url}${$base ? `;${$base}` : \"\"}`;\r\n        if (parsedURLCache.has(key)) {\r\n            return parsedURLCache.get(key);\r\n        }\r\n        if ($base) {\r\n            const parsedURL = new URL($url, fixBaseURL($base));\r\n            parsedURLCache.set(key, parsedURL);\r\n            return parsedURL;\r\n        }\r\n        const parsedURL = new URL(fixBaseURL($url));\r\n        parsedURLCache.set($url, parsedURL);\r\n        return parsedURL;\r\n    }\r\n    function getAbsoluteURL($base, $relative) {\r\n        if ($relative.match(/^data\\\\?\\:/)) {\r\n            return $relative;\r\n        }\r\n        if (/^\\/\\//.test($relative)) {\r\n            return `${location.protocol}${$relative}`;\r\n        }\r\n        const b = parseURL($base);\r\n        const a = parseURL($relative, b.href);\r\n        return a.href;\r\n    }\r\n    function isRelativeHrefOnAbsolutePath(href) {\r\n        if (href.startsWith(\"data:\")) {\r\n            return true;\r\n        }\r\n        const url = parseURL(href);\r\n        if (url.protocol !== location.protocol) {\r\n            return false;\r\n        }\r\n        if (url.hostname !== location.hostname) {\r\n            return false;\r\n        }\r\n        if (url.port !== location.port) {\r\n            return false;\r\n        }\r\n        return url.pathname === location.pathname;\r\n    }\r\n\r\n    const excludedSelectors = [\r\n        \"pre\",\r\n        \"pre *\",\r\n        \"code\",\r\n        '[aria-hidden=\"true\"]',\r\n        '[class*=\"fa-\"]',\r\n        \".fa\",\r\n        \".fab\",\r\n        \".fad\",\r\n        \".fal\",\r\n        \".far\",\r\n        \".fas\",\r\n        \".fass\",\r\n        \".fasr\",\r\n        \".fat\",\r\n        \".icofont\",\r\n        '[style*=\"font-\"]',\r\n        '[class*=\"icon\"]',\r\n        '[class*=\"Icon\"]',\r\n        '[class*=\"symbol\"]',\r\n        '[class*=\"Symbol\"]',\r\n        \".glyphicon\",\r\n        '[class*=\"material-symbol\"]',\r\n        '[class*=\"material-icon\"]',\r\n        \"mu\",\r\n        '[class*=\"mu-\"]',\r\n        \".typcn\",\r\n        '[class*=\"vjs-\"]'\r\n    ];\r\n    function createTextStyle(config) {\r\n        const lines = [];\r\n        lines.push(`*:not(${excludedSelectors.join(\", \")}) {`);\r\n        if (config.useFont && config.fontFamily) {\r\n            lines.push(`  font-family: ${config.fontFamily} !important;`);\r\n        }\r\n        if (config.textStroke > 0) {\r\n            lines.push(\r\n                `  -webkit-text-stroke: ${config.textStroke}px !important;`\r\n            );\r\n            lines.push(`  text-stroke: ${config.textStroke}px !important;`);\r\n        }\r\n        lines.push(\"}\");\r\n        return lines.join(\"\\n\");\r\n    }\r\n\r\n    function isArrayLike(items) {\r\n        return items.length != null;\r\n    }\r\n    function forEach(items, iterator) {\r\n        if (isArrayLike(items)) {\r\n            for (let i = 0, len = items.length; i < len; i++) {\r\n                iterator(items[i]);\r\n            }\r\n        } else {\r\n            for (const item of items) {\r\n                iterator(item);\r\n            }\r\n        }\r\n    }\r\n    function push(array, addition) {\r\n        forEach(addition, (a) => array.push(a));\r\n    }\r\n    function toArray(items) {\r\n        const results = [];\r\n        for (let i = 0, len = items.length; i < len; i++) {\r\n            results.push(items[i]);\r\n        }\r\n        return results;\r\n    }\r\n\r\n    function scale(x, inLow, inHigh, outLow, outHigh) {\r\n        return ((x - inLow) * (outHigh - outLow)) / (inHigh - inLow) + outLow;\r\n    }\r\n    function clamp(x, min, max) {\r\n        return Math.min(max, Math.max(min, x));\r\n    }\r\n    function multiplyMatrices(m1, m2) {\r\n        const result = [];\r\n        for (let i = 0, len = m1.length; i < len; i++) {\r\n            result[i] = [];\r\n            for (let j = 0, len2 = m2[0].length; j < len2; j++) {\r\n                let sum = 0;\r\n                for (let k = 0, len3 = m1[0].length; k < len3; k++) {\r\n                    sum += m1[i][k] * m2[k][j];\r\n                }\r\n                result[i][j] = sum;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function createFilterMatrix(config) {\r\n        let m = Matrix.identity();\r\n        if (config.sepia !== 0) {\r\n            m = multiplyMatrices(m, Matrix.sepia(config.sepia / 100));\r\n        }\r\n        if (config.grayscale !== 0) {\r\n            m = multiplyMatrices(m, Matrix.grayscale(config.grayscale / 100));\r\n        }\r\n        if (config.contrast !== 100) {\r\n            m = multiplyMatrices(m, Matrix.contrast(config.contrast / 100));\r\n        }\r\n        if (config.brightness !== 100) {\r\n            m = multiplyMatrices(m, Matrix.brightness(config.brightness / 100));\r\n        }\r\n        if (config.mode === 1) {\r\n            m = multiplyMatrices(m, Matrix.invertNHue());\r\n        }\r\n        return m;\r\n    }\r\n    function applyColorMatrix([r, g, b], matrix) {\r\n        const rgb = [[r / 255], [g / 255], [b / 255], [1], [1]];\r\n        const result = multiplyMatrices(matrix, rgb);\r\n        return [0, 1, 2].map((i) =>\r\n            clamp(Math.round(result[i][0] * 255), 0, 255)\r\n        );\r\n    }\r\n    const Matrix = {\r\n        identity() {\r\n            return [\r\n                [1, 0, 0, 0, 0],\r\n                [0, 1, 0, 0, 0],\r\n                [0, 0, 1, 0, 0],\r\n                [0, 0, 0, 1, 0],\r\n                [0, 0, 0, 0, 1]\r\n            ];\r\n        },\r\n        invertNHue() {\r\n            return [\r\n                [0.333, -0.667, -0.667, 0, 1],\r\n                [-0.667, 0.333, -0.667, 0, 1],\r\n                [-0.667, -0.667, 0.333, 0, 1],\r\n                [0, 0, 0, 1, 0],\r\n                [0, 0, 0, 0, 1]\r\n            ];\r\n        },\r\n        brightness(v) {\r\n            return [\r\n                [v, 0, 0, 0, 0],\r\n                [0, v, 0, 0, 0],\r\n                [0, 0, v, 0, 0],\r\n                [0, 0, 0, 1, 0],\r\n                [0, 0, 0, 0, 1]\r\n            ];\r\n        },\r\n        contrast(v) {\r\n            const t = (1 - v) / 2;\r\n            return [\r\n                [v, 0, 0, 0, t],\r\n                [0, v, 0, 0, t],\r\n                [0, 0, v, 0, t],\r\n                [0, 0, 0, 1, 0],\r\n                [0, 0, 0, 0, 1]\r\n            ];\r\n        },\r\n        sepia(v) {\r\n            return [\r\n                [\r\n                    0.393 + 0.607 * (1 - v),\r\n                    0.769 - 0.769 * (1 - v),\r\n                    0.189 - 0.189 * (1 - v),\r\n                    0,\r\n                    0\r\n                ],\r\n                [\r\n                    0.349 - 0.349 * (1 - v),\r\n                    0.686 + 0.314 * (1 - v),\r\n                    0.168 - 0.168 * (1 - v),\r\n                    0,\r\n                    0\r\n                ],\r\n                [\r\n                    0.272 - 0.272 * (1 - v),\r\n                    0.534 - 0.534 * (1 - v),\r\n                    0.131 + 0.869 * (1 - v),\r\n                    0,\r\n                    0\r\n                ],\r\n                [0, 0, 0, 1, 0],\r\n                [0, 0, 0, 0, 1]\r\n            ];\r\n        },\r\n        grayscale(v) {\r\n            return [\r\n                [\r\n                    0.2126 + 0.7874 * (1 - v),\r\n                    0.7152 - 0.7152 * (1 - v),\r\n                    0.0722 - 0.0722 * (1 - v),\r\n                    0,\r\n                    0\r\n                ],\r\n                [\r\n                    0.2126 - 0.2126 * (1 - v),\r\n                    0.7152 + 0.2848 * (1 - v),\r\n                    0.0722 - 0.0722 * (1 - v),\r\n                    0,\r\n                    0\r\n                ],\r\n                [\r\n                    0.2126 - 0.2126 * (1 - v),\r\n                    0.7152 - 0.7152 * (1 - v),\r\n                    0.0722 + 0.9278 * (1 - v),\r\n                    0,\r\n                    0\r\n                ],\r\n                [0, 0, 0, 1, 0],\r\n                [0, 0, 0, 0, 1]\r\n            ];\r\n        }\r\n    };\r\n\r\n    var FilterMode;\r\n    (function (FilterMode) {\r\n        FilterMode[(FilterMode[\"light\"] = 0)] = \"light\";\r\n        FilterMode[(FilterMode[\"dark\"] = 1)] = \"dark\";\r\n    })(FilterMode || (FilterMode = {}));\r\n    function getCSSFilterValue(config) {\r\n        const filters = [];\r\n        if (config.mode === FilterMode.dark) {\r\n            filters.push(\"invert(100%) hue-rotate(180deg)\");\r\n        }\r\n        if (config.brightness !== 100) {\r\n            filters.push(`brightness(${config.brightness}%)`);\r\n        }\r\n        if (config.contrast !== 100) {\r\n            filters.push(`contrast(${config.contrast}%)`);\r\n        }\r\n        if (config.grayscale !== 0) {\r\n            filters.push(`grayscale(${config.grayscale}%)`);\r\n        }\r\n        if (config.sepia !== 0) {\r\n            filters.push(`sepia(${config.sepia}%)`);\r\n        }\r\n        if (filters.length === 0) {\r\n            return null;\r\n        }\r\n        return filters.join(\" \");\r\n    }\r\n\r\n    function evalMath(expression) {\r\n        const rpnStack = [];\r\n        const workingStack = [];\r\n        let lastToken;\r\n        for (let i = 0, len = expression.length; i < len; i++) {\r\n            const token = expression[i];\r\n            if (!token || token === \" \") {\r\n                continue;\r\n            }\r\n            if (operators.has(token)) {\r\n                const op = operators.get(token);\r\n                while (workingStack.length) {\r\n                    const currentOp = operators.get(workingStack[0]);\r\n                    if (!currentOp) {\r\n                        break;\r\n                    }\r\n                    if (op.lessOrEqualThan(currentOp)) {\r\n                        rpnStack.push(workingStack.shift());\r\n                    } else {\r\n                        break;\r\n                    }\r\n                }\r\n                workingStack.unshift(token);\r\n            } else if (!lastToken || operators.has(lastToken)) {\r\n                rpnStack.push(token);\r\n            } else {\r\n                rpnStack[rpnStack.length - 1] += token;\r\n            }\r\n            lastToken = token;\r\n        }\r\n        rpnStack.push(...workingStack);\r\n        const stack = [];\r\n        for (let i = 0, len = rpnStack.length; i < len; i++) {\r\n            const op = operators.get(rpnStack[i]);\r\n            if (op) {\r\n                const args = stack.splice(0, 2);\r\n                stack.push(op.exec(args[1], args[0]));\r\n            } else {\r\n                stack.unshift(parseFloat(rpnStack[i]));\r\n            }\r\n        }\r\n        return stack[0];\r\n    }\r\n    class Operator {\r\n        constructor(precedence, method) {\r\n            this.precendce = precedence;\r\n            this.execMethod = method;\r\n        }\r\n        exec(left, right) {\r\n            return this.execMethod(left, right);\r\n        }\r\n        lessOrEqualThan(op) {\r\n            return this.precendce <= op.precendce;\r\n        }\r\n    }\r\n    const operators = new Map([\r\n        [\"+\", new Operator(1, (left, right) => left + right)],\r\n        [\"-\", new Operator(1, (left, right) => left - right)],\r\n        [\"*\", new Operator(2, (left, right) => left * right)],\r\n        [\"/\", new Operator(2, (left, right) => left / right)]\r\n    ]);\r\n\r\n    const isSystemDarkModeEnabled = () =>\r\n        matchMedia(\"(prefers-color-scheme: dark)\").matches;\r\n\r\n    const hslaParseCache = new Map();\r\n    const rgbaParseCache = new Map();\r\n    function parseColorWithCache($color) {\r\n        $color = $color.trim();\r\n        if (rgbaParseCache.has($color)) {\r\n            return rgbaParseCache.get($color);\r\n        }\r\n        if ($color.includes(\"calc(\")) {\r\n            $color = lowerCalcExpression($color);\r\n        }\r\n        const color = parse($color);\r\n        if (color) {\r\n            rgbaParseCache.set($color, color);\r\n            return color;\r\n        }\r\n        return null;\r\n    }\r\n    function parseToHSLWithCache(color) {\r\n        if (hslaParseCache.has(color)) {\r\n            return hslaParseCache.get(color);\r\n        }\r\n        const rgb = parseColorWithCache(color);\r\n        if (!rgb) {\r\n            return null;\r\n        }\r\n        const hsl = rgbToHSL(rgb);\r\n        hslaParseCache.set(color, hsl);\r\n        return hsl;\r\n    }\r\n    function clearColorCache() {\r\n        hslaParseCache.clear();\r\n        rgbaParseCache.clear();\r\n    }\r\n    function hslToRGB({h, s, l, a = 1}) {\r\n        if (s === 0) {\r\n            const [r, b, g] = [l, l, l].map((x) => Math.round(x * 255));\r\n            return {r, g, b, a};\r\n        }\r\n        const c = (1 - Math.abs(2 * l - 1)) * s;\r\n        const x = c * (1 - Math.abs(((h / 60) % 2) - 1));\r\n        const m = l - c / 2;\r\n        const [r, g, b] = (\r\n            h < 60\r\n                ? [c, x, 0]\r\n                : h < 120\r\n                  ? [x, c, 0]\r\n                  : h < 180\r\n                    ? [0, c, x]\r\n                    : h < 240\r\n                      ? [0, x, c]\r\n                      : h < 300\r\n                        ? [x, 0, c]\r\n                        : [c, 0, x]\r\n        ).map((n) => Math.round((n + m) * 255));\r\n        return {r, g, b, a};\r\n    }\r\n    function rgbToHSL({r: r255, g: g255, b: b255, a = 1}) {\r\n        const r = r255 / 255;\r\n        const g = g255 / 255;\r\n        const b = b255 / 255;\r\n        const max = Math.max(r, g, b);\r\n        const min = Math.min(r, g, b);\r\n        const c = max - min;\r\n        const l = (max + min) / 2;\r\n        if (c === 0) {\r\n            return {h: 0, s: 0, l, a};\r\n        }\r\n        let h =\r\n            (max === r\r\n                ? ((g - b) / c) % 6\r\n                : max === g\r\n                  ? (b - r) / c + 2\r\n                  : (r - g) / c + 4) * 60;\r\n        if (h < 0) {\r\n            h += 360;\r\n        }\r\n        const s = c / (1 - Math.abs(2 * l - 1));\r\n        return {h, s, l, a};\r\n    }\r\n    function toFixed(n, digits = 0) {\r\n        const fixed = n.toFixed(digits);\r\n        if (digits === 0) {\r\n            return fixed;\r\n        }\r\n        const dot = fixed.indexOf(\".\");\r\n        if (dot >= 0) {\r\n            const zerosMatch = fixed.match(/0+$/);\r\n            if (zerosMatch) {\r\n                if (zerosMatch.index === dot + 1) {\r\n                    return fixed.substring(0, dot);\r\n                }\r\n                return fixed.substring(0, zerosMatch.index);\r\n            }\r\n        }\r\n        return fixed;\r\n    }\r\n    function rgbToString(rgb) {\r\n        const {r, g, b, a} = rgb;\r\n        if (a != null && a < 1) {\r\n            return `rgba(${toFixed(r)}, ${toFixed(g)}, ${toFixed(b)}, ${toFixed(a, 2)})`;\r\n        }\r\n        return `rgb(${toFixed(r)}, ${toFixed(g)}, ${toFixed(b)})`;\r\n    }\r\n    function rgbToHexString({r, g, b, a}) {\r\n        return `#${(a != null && a < 1\r\n            ? [r, g, b, Math.round(a * 255)]\r\n            : [r, g, b]\r\n        )\r\n            .map((x) => {\r\n                return `${x < 16 ? \"0\" : \"\"}${x.toString(16)}`;\r\n            })\r\n            .join(\"\")}`;\r\n    }\r\n    function hslToString(hsl) {\r\n        const {h, s, l, a} = hsl;\r\n        if (a != null && a < 1) {\r\n            return `hsla(${toFixed(h)}, ${toFixed(s * 100)}%, ${toFixed(l * 100)}%, ${toFixed(a, 2)})`;\r\n        }\r\n        return `hsl(${toFixed(h)}, ${toFixed(s * 100)}%, ${toFixed(l * 100)}%)`;\r\n    }\r\n    const rgbMatch = /^rgba?\\([^\\(\\)]+\\)$/;\r\n    const hslMatch = /^hsla?\\([^\\(\\)]+\\)$/;\r\n    const hexMatch = /^#[0-9a-f]+$/i;\r\n    function parse($color) {\r\n        const c = $color.trim().toLowerCase();\r\n        if ($color.includes(\"(from \")) {\r\n            return domParseColor(c);\r\n        }\r\n        if (c.match(rgbMatch)) {\r\n            if (c.startsWith(\"rgb(#\") || c.startsWith(\"rgba(#\")) {\r\n                return domParseColor(c);\r\n            }\r\n            return parseRGB(c);\r\n        }\r\n        if (c.match(hslMatch)) {\r\n            return parseHSL(c);\r\n        }\r\n        if (c.match(hexMatch)) {\r\n            return parseHex(c);\r\n        }\r\n        if (knownColors.has(c)) {\r\n            return getColorByName(c);\r\n        }\r\n        if (systemColors.has(c)) {\r\n            return getSystemColor(c);\r\n        }\r\n        if ($color === \"transparent\") {\r\n            return {r: 0, g: 0, b: 0, a: 0};\r\n        }\r\n        if (\r\n            (c.startsWith(\"color(\") || c.startsWith(\"color-mix(\")) &&\r\n            c.endsWith(\")\")\r\n        ) {\r\n            return domParseColor(c);\r\n        }\r\n        if (c.startsWith(\"light-dark(\") && c.endsWith(\")\")) {\r\n            const match = c.match(\r\n                /^light-dark\\(\\s*([a-z]+(\\(.*\\))?),\\s*([a-z]+(\\(.*\\))?)\\s*\\)$/\r\n            );\r\n            if (match) {\r\n                const schemeColor = isSystemDarkModeEnabled()\r\n                    ? match[3]\r\n                    : match[1];\r\n                return parse(schemeColor);\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    function getNumbers($color) {\r\n        const numbers = [];\r\n        let prevPos = 0;\r\n        let isMining = false;\r\n        const startIndex = $color.indexOf(\"(\");\r\n        $color = $color.substring(startIndex + 1, $color.length - 1);\r\n        for (let i = 0; i < $color.length; i++) {\r\n            const c = $color[i];\r\n            if ((c >= \"0\" && c <= \"9\") || c === \".\" || c === \"+\" || c === \"-\") {\r\n                isMining = true;\r\n            } else if (isMining && (c === \" \" || c === \",\" || c === \"/\")) {\r\n                numbers.push($color.substring(prevPos, i));\r\n                isMining = false;\r\n                prevPos = i + 1;\r\n            } else if (!isMining) {\r\n                prevPos = i + 1;\r\n            }\r\n        }\r\n        if (isMining) {\r\n            numbers.push($color.substring(prevPos, $color.length));\r\n        }\r\n        return numbers;\r\n    }\r\n    function getNumbersFromString(str, range, units) {\r\n        const raw = getNumbers(str);\r\n        const unitsList = Object.entries(units);\r\n        const numbers = raw\r\n            .map((r) => r.trim())\r\n            .map((r, i) => {\r\n                let n;\r\n                const unit = unitsList.find(([u]) => r.endsWith(u));\r\n                if (unit) {\r\n                    n =\r\n                        (parseFloat(r.substring(0, r.length - unit[0].length)) /\r\n                            unit[1]) *\r\n                        range[i];\r\n                } else {\r\n                    n = parseFloat(r);\r\n                }\r\n                if (range[i] > 1) {\r\n                    return Math.round(n);\r\n                }\r\n                return n;\r\n            });\r\n        return numbers;\r\n    }\r\n    const rgbRange = [255, 255, 255, 1];\r\n    const rgbUnits = {\"%\": 100};\r\n    function parseRGB($rgb) {\r\n        const [r, g, b, a = 1] = getNumbersFromString($rgb, rgbRange, rgbUnits);\r\n        if (r == null || g == null || b == null || a == null) {\r\n            return null;\r\n        }\r\n        return {r, g, b, a};\r\n    }\r\n    const hslRange = [360, 1, 1, 1];\r\n    const hslUnits = {\"%\": 100, \"deg\": 360, \"rad\": 2 * Math.PI, \"turn\": 1};\r\n    function parseHSL($hsl) {\r\n        const [h, s, l, a = 1] = getNumbersFromString($hsl, hslRange, hslUnits);\r\n        if (h == null || s == null || l == null || a == null) {\r\n            return null;\r\n        }\r\n        return hslToRGB({h, s, l, a});\r\n    }\r\n    function parseHex($hex) {\r\n        const h = $hex.substring(1);\r\n        switch (h.length) {\r\n            case 3:\r\n            case 4: {\r\n                const [r, g, b] = [0, 1, 2].map((i) =>\r\n                    parseInt(`${h[i]}${h[i]}`, 16)\r\n                );\r\n                const a =\r\n                    h.length === 3 ? 1 : parseInt(`${h[3]}${h[3]}`, 16) / 255;\r\n                return {r, g, b, a};\r\n            }\r\n            case 6:\r\n            case 8: {\r\n                const [r, g, b] = [0, 2, 4].map((i) =>\r\n                    parseInt(h.substring(i, i + 2), 16)\r\n                );\r\n                const a =\r\n                    h.length === 6 ? 1 : parseInt(h.substring(6, 8), 16) / 255;\r\n                return {r, g, b, a};\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    function getColorByName($color) {\r\n        const n = knownColors.get($color);\r\n        return {\r\n            r: (n >> 16) & 255,\r\n            g: (n >> 8) & 255,\r\n            b: (n >> 0) & 255,\r\n            a: 1\r\n        };\r\n    }\r\n    function getSystemColor($color) {\r\n        const n = systemColors.get($color);\r\n        return {\r\n            r: (n >> 16) & 255,\r\n            g: (n >> 8) & 255,\r\n            b: (n >> 0) & 255,\r\n            a: 1\r\n        };\r\n    }\r\n    function lowerCalcExpression(color) {\r\n        let searchIndex = 0;\r\n        const replaceBetweenIndices = (start, end, replacement) => {\r\n            color =\r\n                color.substring(0, start) + replacement + color.substring(end);\r\n        };\r\n        while ((searchIndex = color.indexOf(\"calc(\")) !== -1) {\r\n            const range = getParenthesesRange(color, searchIndex);\r\n            if (!range) {\r\n                break;\r\n            }\r\n            let slice = color.slice(range.start + 1, range.end - 1);\r\n            const includesPercentage = slice.includes(\"%\");\r\n            slice = slice.split(\"%\").join(\"\");\r\n            const output = Math.round(evalMath(slice));\r\n            replaceBetweenIndices(\r\n                range.start - 4,\r\n                range.end,\r\n                output + (includesPercentage ? \"%\" : \"\")\r\n            );\r\n        }\r\n        return color;\r\n    }\r\n    const knownColors = new Map(\r\n        Object.entries({\r\n            aliceblue: 0xf0f8ff,\r\n            antiquewhite: 0xfaebd7,\r\n            aqua: 0x00ffff,\r\n            aquamarine: 0x7fffd4,\r\n            azure: 0xf0ffff,\r\n            beige: 0xf5f5dc,\r\n            bisque: 0xffe4c4,\r\n            black: 0x000000,\r\n            blanchedalmond: 0xffebcd,\r\n            blue: 0x0000ff,\r\n            blueviolet: 0x8a2be2,\r\n            brown: 0xa52a2a,\r\n            burlywood: 0xdeb887,\r\n            cadetblue: 0x5f9ea0,\r\n            chartreuse: 0x7fff00,\r\n            chocolate: 0xd2691e,\r\n            coral: 0xff7f50,\r\n            cornflowerblue: 0x6495ed,\r\n            cornsilk: 0xfff8dc,\r\n            crimson: 0xdc143c,\r\n            cyan: 0x00ffff,\r\n            darkblue: 0x00008b,\r\n            darkcyan: 0x008b8b,\r\n            darkgoldenrod: 0xb8860b,\r\n            darkgray: 0xa9a9a9,\r\n            darkgrey: 0xa9a9a9,\r\n            darkgreen: 0x006400,\r\n            darkkhaki: 0xbdb76b,\r\n            darkmagenta: 0x8b008b,\r\n            darkolivegreen: 0x556b2f,\r\n            darkorange: 0xff8c00,\r\n            darkorchid: 0x9932cc,\r\n            darkred: 0x8b0000,\r\n            darksalmon: 0xe9967a,\r\n            darkseagreen: 0x8fbc8f,\r\n            darkslateblue: 0x483d8b,\r\n            darkslategray: 0x2f4f4f,\r\n            darkslategrey: 0x2f4f4f,\r\n            darkturquoise: 0x00ced1,\r\n            darkviolet: 0x9400d3,\r\n            deeppink: 0xff1493,\r\n            deepskyblue: 0x00bfff,\r\n            dimgray: 0x696969,\r\n            dimgrey: 0x696969,\r\n            dodgerblue: 0x1e90ff,\r\n            firebrick: 0xb22222,\r\n            floralwhite: 0xfffaf0,\r\n            forestgreen: 0x228b22,\r\n            fuchsia: 0xff00ff,\r\n            gainsboro: 0xdcdcdc,\r\n            ghostwhite: 0xf8f8ff,\r\n            gold: 0xffd700,\r\n            goldenrod: 0xdaa520,\r\n            gray: 0x808080,\r\n            grey: 0x808080,\r\n            green: 0x008000,\r\n            greenyellow: 0xadff2f,\r\n            honeydew: 0xf0fff0,\r\n            hotpink: 0xff69b4,\r\n            indianred: 0xcd5c5c,\r\n            indigo: 0x4b0082,\r\n            ivory: 0xfffff0,\r\n            khaki: 0xf0e68c,\r\n            lavender: 0xe6e6fa,\r\n            lavenderblush: 0xfff0f5,\r\n            lawngreen: 0x7cfc00,\r\n            lemonchiffon: 0xfffacd,\r\n            lightblue: 0xadd8e6,\r\n            lightcoral: 0xf08080,\r\n            lightcyan: 0xe0ffff,\r\n            lightgoldenrodyellow: 0xfafad2,\r\n            lightgray: 0xd3d3d3,\r\n            lightgrey: 0xd3d3d3,\r\n            lightgreen: 0x90ee90,\r\n            lightpink: 0xffb6c1,\r\n            lightsalmon: 0xffa07a,\r\n            lightseagreen: 0x20b2aa,\r\n            lightskyblue: 0x87cefa,\r\n            lightslategray: 0x778899,\r\n            lightslategrey: 0x778899,\r\n            lightsteelblue: 0xb0c4de,\r\n            lightyellow: 0xffffe0,\r\n            lime: 0x00ff00,\r\n            limegreen: 0x32cd32,\r\n            linen: 0xfaf0e6,\r\n            magenta: 0xff00ff,\r\n            maroon: 0x800000,\r\n            mediumaquamarine: 0x66cdaa,\r\n            mediumblue: 0x0000cd,\r\n            mediumorchid: 0xba55d3,\r\n            mediumpurple: 0x9370db,\r\n            mediumseagreen: 0x3cb371,\r\n            mediumslateblue: 0x7b68ee,\r\n            mediumspringgreen: 0x00fa9a,\r\n            mediumturquoise: 0x48d1cc,\r\n            mediumvioletred: 0xc71585,\r\n            midnightblue: 0x191970,\r\n            mintcream: 0xf5fffa,\r\n            mistyrose: 0xffe4e1,\r\n            moccasin: 0xffe4b5,\r\n            navajowhite: 0xffdead,\r\n            navy: 0x000080,\r\n            oldlace: 0xfdf5e6,\r\n            olive: 0x808000,\r\n            olivedrab: 0x6b8e23,\r\n            orange: 0xffa500,\r\n            orangered: 0xff4500,\r\n            orchid: 0xda70d6,\r\n            palegoldenrod: 0xeee8aa,\r\n            palegreen: 0x98fb98,\r\n            paleturquoise: 0xafeeee,\r\n            palevioletred: 0xdb7093,\r\n            papayawhip: 0xffefd5,\r\n            peachpuff: 0xffdab9,\r\n            peru: 0xcd853f,\r\n            pink: 0xffc0cb,\r\n            plum: 0xdda0dd,\r\n            powderblue: 0xb0e0e6,\r\n            purple: 0x800080,\r\n            rebeccapurple: 0x663399,\r\n            red: 0xff0000,\r\n            rosybrown: 0xbc8f8f,\r\n            royalblue: 0x4169e1,\r\n            saddlebrown: 0x8b4513,\r\n            salmon: 0xfa8072,\r\n            sandybrown: 0xf4a460,\r\n            seagreen: 0x2e8b57,\r\n            seashell: 0xfff5ee,\r\n            sienna: 0xa0522d,\r\n            silver: 0xc0c0c0,\r\n            skyblue: 0x87ceeb,\r\n            slateblue: 0x6a5acd,\r\n            slategray: 0x708090,\r\n            slategrey: 0x708090,\r\n            snow: 0xfffafa,\r\n            springgreen: 0x00ff7f,\r\n            steelblue: 0x4682b4,\r\n            tan: 0xd2b48c,\r\n            teal: 0x008080,\r\n            thistle: 0xd8bfd8,\r\n            tomato: 0xff6347,\r\n            turquoise: 0x40e0d0,\r\n            violet: 0xee82ee,\r\n            wheat: 0xf5deb3,\r\n            white: 0xffffff,\r\n            whitesmoke: 0xf5f5f5,\r\n            yellow: 0xffff00,\r\n            yellowgreen: 0x9acd32\r\n        })\r\n    );\r\n    const systemColors = new Map(\r\n        Object.entries({\r\n            \"ActiveBorder\": 0x3b99fc,\r\n            \"ActiveCaption\": 0x000000,\r\n            \"AppWorkspace\": 0xaaaaaa,\r\n            \"Background\": 0x6363ce,\r\n            \"ButtonFace\": 0xffffff,\r\n            \"ButtonHighlight\": 0xe9e9e9,\r\n            \"ButtonShadow\": 0x9fa09f,\r\n            \"ButtonText\": 0x000000,\r\n            \"CaptionText\": 0x000000,\r\n            \"GrayText\": 0x7f7f7f,\r\n            \"Highlight\": 0xb2d7ff,\r\n            \"HighlightText\": 0x000000,\r\n            \"InactiveBorder\": 0xffffff,\r\n            \"InactiveCaption\": 0xffffff,\r\n            \"InactiveCaptionText\": 0x000000,\r\n            \"InfoBackground\": 0xfbfcc5,\r\n            \"InfoText\": 0x000000,\r\n            \"Menu\": 0xf6f6f6,\r\n            \"MenuText\": 0xffffff,\r\n            \"Scrollbar\": 0xaaaaaa,\r\n            \"ThreeDDarkShadow\": 0x000000,\r\n            \"ThreeDFace\": 0xc0c0c0,\r\n            \"ThreeDHighlight\": 0xffffff,\r\n            \"ThreeDLightShadow\": 0xffffff,\r\n            \"ThreeDShadow\": 0x000000,\r\n            \"Window\": 0xececec,\r\n            \"WindowFrame\": 0xaaaaaa,\r\n            \"WindowText\": 0x000000,\r\n            \"-webkit-focus-ring-color\": 0xe59700\r\n        }).map(([key, value]) => [key.toLowerCase(), value])\r\n    );\r\n    function getSRGBLightness(r, g, b) {\r\n        return (0.2126 * r + 0.7152 * g + 0.0722 * b) / 255;\r\n    }\r\n    let canvas$1;\r\n    let context$1;\r\n    function domParseColor($color) {\r\n        if (!context$1) {\r\n            canvas$1 = document.createElement(\"canvas\");\r\n            canvas$1.width = 1;\r\n            canvas$1.height = 1;\r\n            context$1 = canvas$1.getContext(\"2d\", {willReadFrequently: true});\r\n        }\r\n        context$1.fillStyle = $color;\r\n        context$1.fillRect(0, 0, 1, 1);\r\n        const d = context$1.getImageData(0, 0, 1, 1).data;\r\n        const color = `rgba(${d[0]}, ${d[1]}, ${d[2]}, ${(d[3] / 255).toFixed(2)})`;\r\n        return parseRGB(color);\r\n    }\r\n\r\n    function throttle(callback) {\r\n        let pending = false;\r\n        let frameId = null;\r\n        let lastArgs;\r\n        const throttled = (...args) => {\r\n            lastArgs = args;\r\n            if (frameId) {\r\n                pending = true;\r\n            } else {\r\n                callback(...lastArgs);\r\n                frameId = requestAnimationFrame(() => {\r\n                    frameId = null;\r\n                    if (pending) {\r\n                        callback(...lastArgs);\r\n                        pending = false;\r\n                    }\r\n                });\r\n            }\r\n        };\r\n        const cancel = () => {\r\n            cancelAnimationFrame(frameId);\r\n            pending = false;\r\n            frameId = null;\r\n        };\r\n        return Object.assign(throttled, {cancel});\r\n    }\r\n    function createAsyncTasksQueue() {\r\n        const tasks = [];\r\n        let frameId = null;\r\n        function runTasks() {\r\n            let task;\r\n            while ((task = tasks.shift())) {\r\n                task();\r\n            }\r\n            frameId = null;\r\n        }\r\n        function add(task) {\r\n            tasks.push(task);\r\n            if (!frameId) {\r\n                frameId = requestAnimationFrame(runTasks);\r\n            }\r\n        }\r\n        function cancel() {\r\n            tasks.splice(0);\r\n            cancelAnimationFrame(frameId);\r\n            frameId = null;\r\n        }\r\n        return {add, cancel};\r\n    }\r\n    const delayTokens = new Set();\r\n    function requestAnimationFrameOnce(token, callback) {\r\n        if (delayTokens.has(token)) {\r\n            return;\r\n        }\r\n        delayTokens.add(token);\r\n        requestAnimationFrame(() => {\r\n            delayTokens.delete(token);\r\n            callback();\r\n        });\r\n    }\r\n\r\n    function hexify(number) {\r\n        return (number < 16 ? \"0\" : \"\") + number.toString(16);\r\n    }\r\n    function generateUID() {\r\n        if (\"randomUUID\" in crypto) {\r\n            const uuid = crypto.randomUUID();\r\n            return (\r\n                uuid.substring(0, 8) +\r\n                uuid.substring(9, 13) +\r\n                uuid.substring(14, 18) +\r\n                uuid.substring(19, 23) +\r\n                uuid.substring(24)\r\n            );\r\n        }\r\n        if (\"getRandomValues\" in crypto) {\r\n            return Array.from(crypto.getRandomValues(new Uint8Array(16)))\r\n                .map((x) => hexify(x))\r\n                .join(\"\");\r\n        }\r\n        return Math.floor(Math.random() * 2 ** 55).toString(36);\r\n    }\r\n\r\n    let documentVisibilityListener = null;\r\n    let documentIsVisible_ = !document.hidden;\r\n    const listenerOptions = {\r\n        capture: true,\r\n        passive: true\r\n    };\r\n    function watchForDocumentVisibility() {\r\n        document.addEventListener(\r\n            \"visibilitychange\",\r\n            documentVisibilityListener,\r\n            listenerOptions\r\n        );\r\n        window.addEventListener(\r\n            \"pageshow\",\r\n            documentVisibilityListener,\r\n            listenerOptions\r\n        );\r\n        window.addEventListener(\r\n            \"focus\",\r\n            documentVisibilityListener,\r\n            listenerOptions\r\n        );\r\n    }\r\n    function stopWatchingForDocumentVisibility() {\r\n        document.removeEventListener(\r\n            \"visibilitychange\",\r\n            documentVisibilityListener,\r\n            listenerOptions\r\n        );\r\n        window.removeEventListener(\r\n            \"pageshow\",\r\n            documentVisibilityListener,\r\n            listenerOptions\r\n        );\r\n        window.removeEventListener(\r\n            \"focus\",\r\n            documentVisibilityListener,\r\n            listenerOptions\r\n        );\r\n    }\r\n    function setDocumentVisibilityListener(callback) {\r\n        const alreadyWatching = Boolean(documentVisibilityListener);\r\n        documentVisibilityListener = () => {\r\n            if (!document.hidden) {\r\n                removeDocumentVisibilityListener();\r\n                callback();\r\n                documentIsVisible_ = true;\r\n            }\r\n        };\r\n        if (!alreadyWatching) {\r\n            watchForDocumentVisibility();\r\n        }\r\n    }\r\n    function removeDocumentVisibilityListener() {\r\n        stopWatchingForDocumentVisibility();\r\n        documentVisibilityListener = null;\r\n    }\r\n    function documentIsVisible() {\r\n        return documentIsVisible_;\r\n    }\r\n\r\n    function getDuration(time) {\r\n        let duration = 0;\r\n        if (time.seconds) {\r\n            duration += time.seconds * 1000;\r\n        }\r\n        if (time.minutes) {\r\n            duration += time.minutes * 60 * 1000;\r\n        }\r\n        if (time.hours) {\r\n            duration += time.hours * 60 * 60 * 1000;\r\n        }\r\n        if (time.days) {\r\n            duration += time.days * 24 * 60 * 60 * 1000;\r\n        }\r\n        return duration;\r\n    }\r\n\r\n    function logInfo(...args) {}\r\n    function logWarn(...args) {}\r\n\r\n    function removeNode(node) {\r\n        node && node.parentNode && node.parentNode.removeChild(node);\r\n    }\r\n    function watchForNodePosition(node, mode, onRestore = Function.prototype) {\r\n        const MAX_ATTEMPTS_COUNT = 10;\r\n        const RETRY_TIMEOUT = getDuration({seconds: 2});\r\n        const ATTEMPTS_INTERVAL = getDuration({seconds: 10});\r\n        const prevSibling = node.previousSibling;\r\n        let parent = node.parentNode;\r\n        if (!parent) {\r\n            throw new Error(\r\n                \"Unable to watch for node position: parent element not found\"\r\n            );\r\n        }\r\n        if (mode === \"prev-sibling\" && !prevSibling) {\r\n            throw new Error(\r\n                \"Unable to watch for node position: there is no previous sibling\"\r\n            );\r\n        }\r\n        let attempts = 0;\r\n        let start = null;\r\n        let timeoutId = null;\r\n        const restore = throttle(() => {\r\n            if (timeoutId) {\r\n                return;\r\n            }\r\n            attempts++;\r\n            const now = Date.now();\r\n            if (start == null) {\r\n                start = now;\r\n            } else if (attempts >= MAX_ATTEMPTS_COUNT) {\r\n                if (now - start < ATTEMPTS_INTERVAL) {\r\n                    timeoutId = setTimeout(() => {\r\n                        start = null;\r\n                        attempts = 0;\r\n                        timeoutId = null;\r\n                        restore();\r\n                    }, RETRY_TIMEOUT);\r\n                    return;\r\n                }\r\n                start = now;\r\n                attempts = 1;\r\n            }\r\n            if (mode === \"head\") {\r\n                if (prevSibling && prevSibling.parentNode !== parent) {\r\n                    stop();\r\n                    return;\r\n                }\r\n            }\r\n            if (mode === \"prev-sibling\") {\r\n                if (prevSibling.parentNode == null) {\r\n                    stop();\r\n                    return;\r\n                }\r\n                if (prevSibling.parentNode !== parent) {\r\n                    updateParent(prevSibling.parentNode);\r\n                }\r\n            }\r\n            if (mode === \"head\" && !parent.isConnected) {\r\n                parent = document.head;\r\n            }\r\n            parent.insertBefore(\r\n                node,\r\n                prevSibling && prevSibling.isConnected\r\n                    ? prevSibling.nextSibling\r\n                    : parent.firstChild\r\n            );\r\n            observer.takeRecords();\r\n            onRestore && onRestore();\r\n        });\r\n        const observer = new MutationObserver(() => {\r\n            if (\r\n                (mode === \"head\" &&\r\n                    (node.parentNode !== parent ||\r\n                        !node.parentNode.isConnected)) ||\r\n                (mode === \"prev-sibling\" &&\r\n                    node.previousSibling !== prevSibling)\r\n            ) {\r\n                restore();\r\n            }\r\n        });\r\n        const run = () => {\r\n            observer.observe(parent, {childList: true});\r\n        };\r\n        const stop = () => {\r\n            clearTimeout(timeoutId);\r\n            observer.disconnect();\r\n            restore.cancel();\r\n        };\r\n        const skip = () => {\r\n            observer.takeRecords();\r\n        };\r\n        const updateParent = (parentNode) => {\r\n            parent = parentNode;\r\n            stop();\r\n            run();\r\n        };\r\n        run();\r\n        return {run, stop, skip};\r\n    }\r\n    function iterateShadowHosts(root, iterator) {\r\n        if (root == null) {\r\n            return;\r\n        }\r\n        const walker = document.createTreeWalker(\r\n            root,\r\n            NodeFilter.SHOW_ELEMENT,\r\n            {\r\n                acceptNode(node) {\r\n                    return node.shadowRoot == null\r\n                        ? NodeFilter.FILTER_SKIP\r\n                        : NodeFilter.FILTER_ACCEPT;\r\n                }\r\n            }\r\n        );\r\n        for (\r\n            let node = root.shadowRoot ? walker.currentNode : walker.nextNode();\r\n            node != null;\r\n            node = walker.nextNode()\r\n        ) {\r\n            if (node.classList.contains(\"surfingkeys_hints_host\")) {\r\n                continue;\r\n            }\r\n            iterator(node);\r\n            iterateShadowHosts(node.shadowRoot, iterator);\r\n        }\r\n    }\r\n    let isDOMReady = () => {\r\n        return (\r\n            document.readyState === \"complete\" ||\r\n            document.readyState === \"interactive\"\r\n        );\r\n    };\r\n    function setIsDOMReady(newFunc) {\r\n        isDOMReady = newFunc;\r\n    }\r\n    const readyStateListeners = new Set();\r\n    function addDOMReadyListener(listener) {\r\n        isDOMReady() ? listener() : readyStateListeners.add(listener);\r\n    }\r\n    function removeDOMReadyListener(listener) {\r\n        readyStateListeners.delete(listener);\r\n    }\r\n    function isReadyStateComplete() {\r\n        return document.readyState === \"complete\";\r\n    }\r\n    const readyStateCompleteListeners = new Set();\r\n    function addReadyStateCompleteListener(listener) {\r\n        isReadyStateComplete()\r\n            ? listener()\r\n            : readyStateCompleteListeners.add(listener);\r\n    }\r\n    function cleanReadyStateCompleteListeners() {\r\n        readyStateCompleteListeners.clear();\r\n    }\r\n    if (!isDOMReady()) {\r\n        const onReadyStateChange = () => {\r\n            if (isDOMReady()) {\r\n                readyStateListeners.forEach((listener) => listener());\r\n                readyStateListeners.clear();\r\n                if (isReadyStateComplete()) {\r\n                    document.removeEventListener(\r\n                        \"readystatechange\",\r\n                        onReadyStateChange\r\n                    );\r\n                    readyStateCompleteListeners.forEach((listener) =>\r\n                        listener()\r\n                    );\r\n                    readyStateCompleteListeners.clear();\r\n                }\r\n            }\r\n        };\r\n        document.addEventListener(\"readystatechange\", onReadyStateChange);\r\n    }\r\n    const HUGE_MUTATIONS_COUNT = 1000;\r\n    function isHugeMutation(mutations) {\r\n        if (mutations.length > HUGE_MUTATIONS_COUNT) {\r\n            return true;\r\n        }\r\n        let addedNodesCount = 0;\r\n        for (let i = 0; i < mutations.length; i++) {\r\n            addedNodesCount += mutations[i].addedNodes.length;\r\n            if (addedNodesCount > HUGE_MUTATIONS_COUNT) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    function getElementsTreeOperations(mutations) {\r\n        const additions = new Set();\r\n        const deletions = new Set();\r\n        const moves = new Set();\r\n        mutations.forEach((m) => {\r\n            forEach(m.addedNodes, (n) => {\r\n                if (n instanceof Element && n.isConnected) {\r\n                    additions.add(n);\r\n                }\r\n            });\r\n            forEach(m.removedNodes, (n) => {\r\n                if (n instanceof Element) {\r\n                    if (n.isConnected) {\r\n                        moves.add(n);\r\n                        additions.delete(n);\r\n                    } else {\r\n                        deletions.add(n);\r\n                    }\r\n                }\r\n            });\r\n        });\r\n        const duplicateAdditions = [];\r\n        const duplicateDeletions = [];\r\n        additions.forEach((node) => {\r\n            if (additions.has(node.parentElement)) {\r\n                duplicateAdditions.push(node);\r\n            }\r\n        });\r\n        deletions.forEach((node) => {\r\n            if (deletions.has(node.parentElement)) {\r\n                duplicateDeletions.push(node);\r\n            }\r\n        });\r\n        duplicateAdditions.forEach((node) => additions.delete(node));\r\n        duplicateDeletions.forEach((node) => deletions.delete(node));\r\n        return {additions, moves, deletions};\r\n    }\r\n    const optimizedTreeObservers = new Map();\r\n    const optimizedTreeCallbacks = new WeakMap();\r\n    function createOptimizedTreeObserver(root, callbacks) {\r\n        let observer;\r\n        let observerCallbacks;\r\n        let domReadyListener;\r\n        if (optimizedTreeObservers.has(root)) {\r\n            observer = optimizedTreeObservers.get(root);\r\n            observerCallbacks = optimizedTreeCallbacks.get(observer);\r\n        } else {\r\n            let hadHugeMutationsBefore = false;\r\n            let subscribedForReadyState = false;\r\n            observer = new MutationObserver((mutations) => {\r\n                if (isHugeMutation(mutations)) {\r\n                    if (!hadHugeMutationsBefore || isDOMReady()) {\r\n                        observerCallbacks.forEach(({onHugeMutations}) =>\r\n                            onHugeMutations(root)\r\n                        );\r\n                    } else if (!subscribedForReadyState) {\r\n                        domReadyListener = () =>\r\n                            observerCallbacks.forEach(({onHugeMutations}) =>\r\n                                onHugeMutations(root)\r\n                            );\r\n                        addDOMReadyListener(domReadyListener);\r\n                        subscribedForReadyState = true;\r\n                    }\r\n                    hadHugeMutationsBefore = true;\r\n                } else {\r\n                    const elementsOperations =\r\n                        getElementsTreeOperations(mutations);\r\n                    observerCallbacks.forEach(({onMinorMutations}) =>\r\n                        onMinorMutations(root, elementsOperations)\r\n                    );\r\n                }\r\n            });\r\n            observer.observe(root, {childList: true, subtree: true});\r\n            optimizedTreeObservers.set(root, observer);\r\n            observerCallbacks = new Set();\r\n            optimizedTreeCallbacks.set(observer, observerCallbacks);\r\n        }\r\n        observerCallbacks.add(callbacks);\r\n        return {\r\n            disconnect() {\r\n                observerCallbacks.delete(callbacks);\r\n                if (domReadyListener) {\r\n                    removeDOMReadyListener(domReadyListener);\r\n                }\r\n                if (observerCallbacks.size === 0) {\r\n                    observer.disconnect();\r\n                    optimizedTreeCallbacks.delete(observer);\r\n                    optimizedTreeObservers.delete(root);\r\n                }\r\n            }\r\n        };\r\n    }\r\n\r\n    function iterateCSSRules(rules, iterate, onImportError) {\r\n        forEach(rules, (rule) => {\r\n            if (isStyleRule(rule)) {\r\n                iterate(rule);\r\n            } else if (isImportRule(rule)) {\r\n                try {\r\n                    iterateCSSRules(\r\n                        rule.styleSheet.cssRules,\r\n                        iterate,\r\n                        onImportError\r\n                    );\r\n                } catch (err) {\r\n                    onImportError?.();\r\n                }\r\n            } else if (isMediaRule(rule)) {\r\n                const media = Array.from(rule.media);\r\n                const isScreenOrAllOrQuery = media.some(\r\n                    (m) =>\r\n                        m.startsWith(\"screen\") ||\r\n                        m.startsWith(\"all\") ||\r\n                        m.startsWith(\"(\")\r\n                );\r\n                const isPrintOrSpeech = media.some(\r\n                    (m) => m.startsWith(\"print\") || m.startsWith(\"speech\")\r\n                );\r\n                if (isScreenOrAllOrQuery || !isPrintOrSpeech) {\r\n                    iterateCSSRules(rule.cssRules, iterate, onImportError);\r\n                }\r\n            } else if (isSupportsRule(rule)) {\r\n                if (CSS.supports(rule.conditionText)) {\r\n                    iterateCSSRules(rule.cssRules, iterate, onImportError);\r\n                }\r\n            } else if (isLayerRule(rule)) {\r\n                iterateCSSRules(rule.cssRules, iterate, onImportError);\r\n            } else;\r\n        });\r\n    }\r\n    const shorthandVarDependantProperties = [\r\n        \"background\",\r\n        \"border\",\r\n        \"border-color\",\r\n        \"border-bottom\",\r\n        \"border-left\",\r\n        \"border-right\",\r\n        \"border-top\",\r\n        \"outline\",\r\n        \"outline-color\"\r\n    ];\r\n    const shorthandVarDepPropRegexps = isSafari\r\n        ? shorthandVarDependantProperties.map((prop) => {\r\n              const regexp = new RegExp(`${prop}:\\\\s*(.*?)\\\\s*;`);\r\n              return [prop, regexp];\r\n          })\r\n        : null;\r\n    function iterateCSSDeclarations(style, iterate) {\r\n        forEach(style, (property) => {\r\n            const value = style.getPropertyValue(property).trim();\r\n            if (!value) {\r\n                return;\r\n            }\r\n            iterate(property, value);\r\n        });\r\n        const cssText = style.cssText;\r\n        if (cssText.includes(\"var(\")) {\r\n            if (isSafari) {\r\n                shorthandVarDepPropRegexps.forEach(([prop, regexp]) => {\r\n                    const match = cssText.match(regexp);\r\n                    if (match && match[1]) {\r\n                        const val = match[1].trim();\r\n                        iterate(prop, val);\r\n                    }\r\n                });\r\n            } else {\r\n                shorthandVarDependantProperties.forEach((prop) => {\r\n                    const val = style.getPropertyValue(prop);\r\n                    if (val && val.includes(\"var(\")) {\r\n                        iterate(prop, val);\r\n                    }\r\n                });\r\n            }\r\n        }\r\n        if (\r\n            cssText.includes(\"background-color: ;\") &&\r\n            !style.getPropertyValue(\"background\")\r\n        ) {\r\n            handleEmptyShorthand(\"background\", style, iterate);\r\n        }\r\n        if (\r\n            cssText.includes(\"border-\") &&\r\n            cssText.includes(\"-color: ;\") &&\r\n            !style.getPropertyValue(\"border\")\r\n        ) {\r\n            handleEmptyShorthand(\"border\", style, iterate);\r\n        }\r\n    }\r\n    function handleEmptyShorthand(shorthand, style, iterate) {\r\n        const parentRule = style.parentRule;\r\n        if (isStyleRule(parentRule)) {\r\n            const sourceCSSText =\r\n                parentRule.parentStyleSheet?.ownerNode?.textContent;\r\n            if (sourceCSSText) {\r\n                let escapedSelector = escapeRegExpSpecialChars(\r\n                    parentRule.selectorText\r\n                );\r\n                escapedSelector = escapedSelector.replaceAll(/\\s+/g, \"\\\\s*\");\r\n                escapedSelector = escapedSelector.replaceAll(/::/g, \"::?\");\r\n                const regexp = new RegExp(\r\n                    `${escapedSelector}\\\\s*{[^}]*${shorthand}:\\\\s*([^;}]+)`\r\n                );\r\n                const match = sourceCSSText.match(regexp);\r\n                if (match) {\r\n                    iterate(shorthand, match[1]);\r\n                }\r\n            } else if (shorthand === \"background\") {\r\n                iterate(\"background-color\", \"#ffffff\");\r\n            }\r\n        }\r\n    }\r\n    const cssURLRegex = /url\\((('.*?')|(\".*?\")|([^\\)]*?))\\)/g;\r\n    const cssImportRegex =\r\n        /@import\\s*(url\\()?(('.+?')|(\".+?\")|([^\\)]*?))\\)? ?(screen)?;?/gi;\r\n    function getCSSURLValue(cssURL) {\r\n        return cssURL\r\n            .trim()\r\n            .replace(/[\\n\\r\\\\]+/g, \"\")\r\n            .replace(/^url\\((.*)\\)$/, \"$1\")\r\n            .trim()\r\n            .replace(/^\"(.*)\"$/, \"$1\")\r\n            .replace(/^'(.*)'$/, \"$1\")\r\n            .replace(/(?:\\\\(.))/g, \"$1\");\r\n    }\r\n    function getCSSBaseBath(url) {\r\n        const cssURL = parseURL(url);\r\n        return `${cssURL.origin}${cssURL.pathname.replace(/\\?.*$/, \"\").replace(/(\\/)([^\\/]+)$/i, \"$1\")}`;\r\n    }\r\n    function replaceCSSRelativeURLsWithAbsolute($css, cssBasePath) {\r\n        return $css.replace(cssURLRegex, (match) => {\r\n            try {\r\n                const url = getCSSURLValue(match);\r\n                const absoluteURL = getAbsoluteURL(cssBasePath, url);\r\n                const escapedURL = absoluteURL.replaceAll(\"'\", \"\\\\'\");\r\n                return `url('${escapedURL}')`;\r\n            } catch (err) {\r\n                return match;\r\n            }\r\n        });\r\n    }\r\n    const fontFaceRegex = /@font-face\\s*{[^}]*}/g;\r\n    function replaceCSSFontFace($css) {\r\n        return $css.replace(fontFaceRegex, \"\");\r\n    }\r\n    const styleRules = new WeakSet();\r\n    const importRules = new WeakSet();\r\n    const mediaRules = new WeakSet();\r\n    const supportsRules = new WeakSet();\r\n    const layerRules = new WeakSet();\r\n    function isStyleRule(rule) {\r\n        if (!rule) {\r\n            return false;\r\n        }\r\n        if (styleRules.has(rule)) {\r\n            return true;\r\n        }\r\n        if (rule.selectorText) {\r\n            styleRules.add(rule);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    function isImportRule(rule) {\r\n        if (!rule) {\r\n            return false;\r\n        }\r\n        if (styleRules.has(rule)) {\r\n            return false;\r\n        }\r\n        if (importRules.has(rule)) {\r\n            return true;\r\n        }\r\n        if (rule.href) {\r\n            importRules.add(rule);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    function isMediaRule(rule) {\r\n        if (!rule) {\r\n            return false;\r\n        }\r\n        if (styleRules.has(rule)) {\r\n            return false;\r\n        }\r\n        if (mediaRules.has(rule)) {\r\n            return true;\r\n        }\r\n        if (rule.media) {\r\n            mediaRules.add(rule);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    function isSupportsRule(rule) {\r\n        if (!rule) {\r\n            return false;\r\n        }\r\n        if (styleRules.has(rule)) {\r\n            return false;\r\n        }\r\n        if (supportsRules.has(rule)) {\r\n            return true;\r\n        }\r\n        if (rule instanceof CSSSupportsRule) {\r\n            supportsRules.add(rule);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    function isLayerRule(rule) {\r\n        if (!rule) {\r\n            return false;\r\n        }\r\n        if (styleRules.has(rule)) {\r\n            return false;\r\n        }\r\n        if (layerRules.has(rule)) {\r\n            return true;\r\n        }\r\n        if (isLayerRuleSupported && rule instanceof CSSLayerBlockRule) {\r\n            layerRules.add(rule);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    const sheetsScopes = new WeakMap();\r\n    function defineSheetScope(sheet, node) {\r\n        sheetsScopes.set(sheet, node);\r\n    }\r\n    function getSheetScope(sheet) {\r\n        if (!sheet.ownerNode) {\r\n            return null;\r\n        }\r\n        if (sheetsScopes.has(sheet)) {\r\n            return sheetsScopes.get(sheet);\r\n        }\r\n        let node = sheet.ownerNode;\r\n        while (node) {\r\n            if (node instanceof ShadowRoot || node instanceof Document) {\r\n                defineSheetScope(sheet, node);\r\n                return node;\r\n            }\r\n            node = node.parentNode;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    const gradientLength = \"gradient\".length;\r\n    const conicGradient = \"conic-\";\r\n    const conicGradientLength = conicGradient.length;\r\n    const radialGradient = \"radial-\";\r\n    const linearGradient = \"linear-\";\r\n    function parseGradient(value) {\r\n        const result = [];\r\n        let index = 0;\r\n        let startIndex = conicGradient.length;\r\n        while ((index = value.indexOf(\"gradient\", startIndex)) !== -1) {\r\n            let typeGradient;\r\n            [linearGradient, radialGradient, conicGradient].find(\r\n                (possibleType) => {\r\n                    if (index - possibleType.length >= 0) {\r\n                        const possibleGradient = value.substring(\r\n                            index - possibleType.length,\r\n                            index\r\n                        );\r\n                        if (possibleGradient === possibleType) {\r\n                            if (\r\n                                value.slice(\r\n                                    index - possibleType.length - 10,\r\n                                    index - possibleType.length - 1\r\n                                ) === \"repeating\"\r\n                            ) {\r\n                                typeGradient = `repeating-${possibleType}gradient`;\r\n                                return true;\r\n                            }\r\n                            if (\r\n                                value.slice(\r\n                                    index - possibleType.length - 8,\r\n                                    index - possibleType.length - 1\r\n                                ) === \"-webkit\"\r\n                            ) {\r\n                                typeGradient = `-webkit-${possibleType}gradient`;\r\n                                return true;\r\n                            }\r\n                            typeGradient = `${possibleType}gradient`;\r\n                            return true;\r\n                        }\r\n                    }\r\n                }\r\n            );\r\n            if (!typeGradient) {\r\n                break;\r\n            }\r\n            const {start, end} = getParenthesesRange(\r\n                value,\r\n                index + gradientLength\r\n            );\r\n            const match = value.substring(start + 1, end - 1);\r\n            startIndex = end + 1 + conicGradientLength;\r\n            result.push({\r\n                typeGradient,\r\n                match,\r\n                offset: typeGradient.length + 2,\r\n                index: index - typeGradient.length + gradientLength,\r\n                hasComma: true\r\n            });\r\n        }\r\n        if (result.length) {\r\n            result[result.length - 1].hasComma = false;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    const STORAGE_KEY_IMAGE_DETAILS_LIST = \"__darkreader__imageDetails_v2_list\";\r\n    const STORAGE_KEY_IMAGE_DETAILS_PREFIX = \"__darkreader__imageDetails_v2_\";\r\n    const STORAGE_KEY_CSS_FETCH_PREFIX = \"__darkreader__cssFetch_\";\r\n    let imageCacheTimeout = 0;\r\n    const imageDetailsCacheQueue = new Map();\r\n    const cachedImageUrls = [];\r\n    function writeImageDetailsQueue() {\r\n        imageDetailsCacheQueue.forEach((details, url) => {\r\n            if (url && url.startsWith(\"https://\")) {\r\n                try {\r\n                    const json = JSON.stringify(details);\r\n                    sessionStorage.setItem(\r\n                        `${STORAGE_KEY_IMAGE_DETAILS_PREFIX}${url}`,\r\n                        json\r\n                    );\r\n                    cachedImageUrls.push(url);\r\n                } catch (err) {}\r\n            }\r\n        });\r\n        imageDetailsCacheQueue.clear();\r\n        sessionStorage.setItem(\r\n            STORAGE_KEY_IMAGE_DETAILS_LIST,\r\n            JSON.stringify(cachedImageUrls)\r\n        );\r\n    }\r\n    function writeImageDetailsCache(url, imageDetails) {\r\n        if (!url || !url.startsWith(\"https://\")) {\r\n            return;\r\n        }\r\n        imageDetailsCacheQueue.set(url, imageDetails);\r\n        clearTimeout(imageCacheTimeout);\r\n        imageCacheTimeout = setTimeout(writeImageDetailsQueue, 1000);\r\n    }\r\n    function readImageDetailsCache(targetMap) {\r\n        try {\r\n            const jsonList = sessionStorage.getItem(\r\n                STORAGE_KEY_IMAGE_DETAILS_LIST\r\n            );\r\n            if (!jsonList) {\r\n                return;\r\n            }\r\n            const list = JSON.parse(jsonList);\r\n            list.forEach((url) => {\r\n                const json = sessionStorage.getItem(\r\n                    `${STORAGE_KEY_IMAGE_DETAILS_PREFIX}${url}`\r\n                );\r\n                if (json) {\r\n                    const details = JSON.parse(json);\r\n                    targetMap.set(url, details);\r\n                }\r\n            });\r\n        } catch (err) {}\r\n    }\r\n    function writeCSSFetchCache(url, cssText) {\r\n        const key = `${STORAGE_KEY_CSS_FETCH_PREFIX}${url}`;\r\n        try {\r\n            sessionStorage.setItem(key, cssText);\r\n        } catch (err) {}\r\n    }\r\n    function readCSSFetchCache(url) {\r\n        const key = `${STORAGE_KEY_CSS_FETCH_PREFIX}${url}`;\r\n        try {\r\n            return sessionStorage.getItem(key) ?? null;\r\n        } catch (err) {}\r\n        return null;\r\n    }\r\n\r\n    function toSVGMatrix(matrix) {\r\n        return matrix\r\n            .slice(0, 4)\r\n            .map((m) => m.map((m) => m.toFixed(3)).join(\" \"))\r\n            .join(\" \");\r\n    }\r\n    function getSVGFilterMatrixValue(config) {\r\n        return toSVGMatrix(createFilterMatrix(config));\r\n    }\r\n\r\n    const MAX_FRAME_DURATION = 1000 / 60;\r\n    class AsyncQueue {\r\n        constructor() {\r\n            this.queue = [];\r\n            this.timerId = null;\r\n        }\r\n        addTask(task) {\r\n            this.queue.push(task);\r\n            this.scheduleFrame();\r\n        }\r\n        stop() {\r\n            if (this.timerId !== null) {\r\n                cancelAnimationFrame(this.timerId);\r\n                this.timerId = null;\r\n            }\r\n            this.queue = [];\r\n        }\r\n        scheduleFrame() {\r\n            if (this.timerId) {\r\n                return;\r\n            }\r\n            this.timerId = requestAnimationFrame(() => {\r\n                this.timerId = null;\r\n                const start = Date.now();\r\n                let cb;\r\n                while ((cb = this.queue.shift())) {\r\n                    cb();\r\n                    if (Date.now() - start >= MAX_FRAME_DURATION) {\r\n                        this.scheduleFrame();\r\n                        break;\r\n                    }\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    const resolvers$1 = new Map();\r\n    const rejectors = new Map();\r\n    async function bgFetch(request) {\r\n        if (window.DarkReader?.Plugins?.fetch) {\r\n            return window.DarkReader.Plugins.fetch(request);\r\n        }\r\n        return new Promise((resolve, reject) => {\r\n            const id = generateUID();\r\n            resolvers$1.set(id, resolve);\r\n            rejectors.set(id, reject);\r\n            chrome.runtime.sendMessage({\r\n                type: MessageTypeCStoBG.FETCH,\r\n                data: request,\r\n                id\r\n            });\r\n        });\r\n    }\r\n    chrome.runtime.onMessage.addListener(({type, data, error, id}) => {\r\n        if (type === MessageTypeBGtoCS.FETCH_RESPONSE) {\r\n            const resolve = resolvers$1.get(id);\r\n            const reject = rejectors.get(id);\r\n            resolvers$1.delete(id);\r\n            rejectors.delete(id);\r\n            if (error) {\r\n                reject && reject(error);\r\n            } else {\r\n                resolve && resolve(data);\r\n            }\r\n        }\r\n    });\r\n\r\n    const imageManager = new AsyncQueue();\r\n    async function getImageDetails(url) {\r\n        return new Promise(async (resolve, reject) => {\r\n            try {\r\n                const dataURL = url.startsWith(\"data:\")\r\n                    ? url\r\n                    : await getDataURL(url);\r\n                const blob =\r\n                    tryConvertDataURLToBlobSync(dataURL) ??\r\n                    (await loadAsBlob(url));\r\n                let image;\r\n                if (dataURL.startsWith(\"data:image/svg+xml\")) {\r\n                    image = await loadImage(dataURL);\r\n                } else {\r\n                    image =\r\n                        (await tryCreateImageBitmap(blob)) ??\r\n                        (await loadImage(dataURL));\r\n                }\r\n                imageManager.addTask(() => {\r\n                    const analysis = analyzeImage(image);\r\n                    resolve({\r\n                        src: url,\r\n                        dataURL: analysis.isLarge ? \"\" : dataURL,\r\n                        width: image.width,\r\n                        height: image.height,\r\n                        ...analysis\r\n                    });\r\n                });\r\n            } catch (error) {\r\n                reject(error);\r\n            }\r\n        });\r\n    }\r\n    async function getDataURL(url) {\r\n        const parsedURL = new URL(url);\r\n        if (parsedURL.origin === location.origin) {\r\n            return await loadAsDataURL(url);\r\n        }\r\n        return await bgFetch({url, responseType: \"data-url\"});\r\n    }\r\n    async function tryCreateImageBitmap(blob) {\r\n        try {\r\n            return await createImageBitmap(blob);\r\n        } catch (err) {\r\n            logWarn(\r\n                `Unable to create image bitmap for type ${blob.type}: ${String(err)}`\r\n            );\r\n            return null;\r\n        }\r\n    }\r\n    const INCOMPLETE_DOC_LOADING_IMAGE_LIMIT = 256;\r\n    let loadingImagesCount = 0;\r\n    async function loadImage(url) {\r\n        return new Promise((resolve, reject) => {\r\n            const image = new Image();\r\n            image.onload = () => resolve(image);\r\n            image.onerror = () => reject(`Unable to load image ${url}`);\r\n            if (\r\n                ++loadingImagesCount <= INCOMPLETE_DOC_LOADING_IMAGE_LIMIT ||\r\n                isReadyStateComplete()\r\n            ) {\r\n                image.src = url;\r\n            } else {\r\n                addReadyStateCompleteListener(() => (image.src = url));\r\n            }\r\n        });\r\n    }\r\n    const MAX_ANALYSIS_PIXELS_COUNT = 32 * 32;\r\n    let canvas;\r\n    let context;\r\n    function createCanvas() {\r\n        const maxWidth = MAX_ANALYSIS_PIXELS_COUNT;\r\n        const maxHeight = MAX_ANALYSIS_PIXELS_COUNT;\r\n        canvas = document.createElement(\"canvas\");\r\n        canvas.width = maxWidth;\r\n        canvas.height = maxHeight;\r\n        context = canvas.getContext(\"2d\", {willReadFrequently: true});\r\n        context.imageSmoothingEnabled = false;\r\n    }\r\n    function removeCanvas() {\r\n        canvas = null;\r\n        context = null;\r\n    }\r\n    const LARGE_IMAGE_PIXELS_COUNT = 512 * 512;\r\n    function analyzeImage(image) {\r\n        if (!canvas) {\r\n            createCanvas();\r\n        }\r\n        let sw;\r\n        let sh;\r\n        if (image instanceof HTMLImageElement) {\r\n            sw = image.naturalWidth;\r\n            sh = image.naturalHeight;\r\n        } else {\r\n            sw = image.width;\r\n            sh = image.height;\r\n        }\r\n        if (sw === 0 || sh === 0) {\r\n            return {\r\n                isDark: false,\r\n                isLight: false,\r\n                isTransparent: false,\r\n                isLarge: false\r\n            };\r\n        }\r\n        const isLarge = sw * sh > LARGE_IMAGE_PIXELS_COUNT;\r\n        const sourcePixelsCount = sw * sh;\r\n        const k = Math.min(\r\n            1,\r\n            Math.sqrt(MAX_ANALYSIS_PIXELS_COUNT / sourcePixelsCount)\r\n        );\r\n        const width = Math.ceil(sw * k);\r\n        const height = Math.ceil(sh * k);\r\n        context.clearRect(0, 0, width, height);\r\n        context.drawImage(image, 0, 0, sw, sh, 0, 0, width, height);\r\n        const imageData = context.getImageData(0, 0, width, height);\r\n        const d = imageData.data;\r\n        const TRANSPARENT_ALPHA_THRESHOLD = 0.05;\r\n        const DARK_LIGHTNESS_THRESHOLD = 0.4;\r\n        const LIGHT_LIGHTNESS_THRESHOLD = 0.7;\r\n        let transparentPixelsCount = 0;\r\n        let darkPixelsCount = 0;\r\n        let lightPixelsCount = 0;\r\n        let i, x, y;\r\n        let r, g, b, a;\r\n        let l;\r\n        for (y = 0; y < height; y++) {\r\n            for (x = 0; x < width; x++) {\r\n                i = 4 * (y * width + x);\r\n                r = d[i + 0];\r\n                g = d[i + 1];\r\n                b = d[i + 2];\r\n                a = d[i + 3];\r\n                if (a / 255 < TRANSPARENT_ALPHA_THRESHOLD) {\r\n                    transparentPixelsCount++;\r\n                } else {\r\n                    l = getSRGBLightness(r, g, b);\r\n                    if (l < DARK_LIGHTNESS_THRESHOLD) {\r\n                        darkPixelsCount++;\r\n                    }\r\n                    if (l > LIGHT_LIGHTNESS_THRESHOLD) {\r\n                        lightPixelsCount++;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        const totalPixelsCount = width * height;\r\n        const opaquePixelsCount = totalPixelsCount - transparentPixelsCount;\r\n        const DARK_IMAGE_THRESHOLD = 0.7;\r\n        const LIGHT_IMAGE_THRESHOLD = 0.7;\r\n        const TRANSPARENT_IMAGE_THRESHOLD = 0.1;\r\n        return {\r\n            isDark: darkPixelsCount / opaquePixelsCount >= DARK_IMAGE_THRESHOLD,\r\n            isLight:\r\n                lightPixelsCount / opaquePixelsCount >= LIGHT_IMAGE_THRESHOLD,\r\n            isTransparent:\r\n                transparentPixelsCount / totalPixelsCount >=\r\n                TRANSPARENT_IMAGE_THRESHOLD,\r\n            isLarge\r\n        };\r\n    }\r\n    let isBlobURLSupported = null;\r\n    let canUseProxy = false;\r\n    let blobURLCheckRequested = false;\r\n    const blobURLCheckAwaiters = [];\r\n    document.addEventListener(\r\n        \"__darkreader__inlineScriptsAllowed\",\r\n        () => (canUseProxy = true),\r\n        {once: true}\r\n    );\r\n    async function requestBlobURLCheck() {\r\n        if (!canUseProxy) {\r\n            return;\r\n        }\r\n        if (blobURLCheckRequested) {\r\n            return await new Promise((resolve) =>\r\n                blobURLCheckAwaiters.push(resolve)\r\n            );\r\n        }\r\n        blobURLCheckRequested = true;\r\n        await new Promise((resolve) => {\r\n            document.addEventListener(\r\n                \"__darkreader__blobURLCheckResponse\",\r\n                (e) => {\r\n                    isBlobURLSupported = e.detail.blobURLAllowed;\r\n                    resolve();\r\n                    blobURLCheckAwaiters.forEach((r) => r());\r\n                    blobURLCheckAwaiters.splice(0);\r\n                },\r\n                {once: true}\r\n            );\r\n            document.dispatchEvent(\r\n                new CustomEvent(\"__darkreader__blobURLCheckRequest\")\r\n            );\r\n        });\r\n    }\r\n    function isBlobURLCheckResultReady() {\r\n        return isBlobURLSupported != null || !canUseProxy;\r\n    }\r\n    function onCSPError(err) {\r\n        if (err.blockedURI === \"blob\") {\r\n            isBlobURLSupported = false;\r\n            document.removeEventListener(\"securitypolicyviolation\", onCSPError);\r\n        }\r\n    }\r\n    document.addEventListener(\"securitypolicyviolation\", onCSPError);\r\n    const objectURLs = new Set();\r\n    function getFilteredImageURL({dataURL, width, height}, theme) {\r\n        if (dataURL.startsWith(\"data:image/svg+xml\")) {\r\n            dataURL = escapeXML(dataURL);\r\n        }\r\n        const matrix = getSVGFilterMatrixValue(theme);\r\n        const svg = [\r\n            `<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"${width}\" height=\"${height}\">`,\r\n            \"<defs>\",\r\n            '<filter id=\"darkreader-image-filter\">',\r\n            `<feColorMatrix type=\"matrix\" values=\"${matrix}\" />`,\r\n            \"</filter>\",\r\n            \"</defs>\",\r\n            `<image width=\"${width}\" height=\"${height}\" filter=\"url(#darkreader-image-filter)\" xlink:href=\"${dataURL}\" />`,\r\n            \"</svg>\"\r\n        ].join(\"\");\r\n        if (!isBlobURLSupported) {\r\n            return `data:image/svg+xml;base64,${btoa(svg)}`;\r\n        }\r\n        const bytes = new Uint8Array(svg.length);\r\n        for (let i = 0; i < svg.length; i++) {\r\n            bytes[i] = svg.charCodeAt(i);\r\n        }\r\n        const blob = new Blob([bytes], {type: \"image/svg+xml\"});\r\n        const objectURL = URL.createObjectURL(blob);\r\n        objectURLs.add(objectURL);\r\n        return objectURL;\r\n    }\r\n    const xmlEscapeChars = {\r\n        \"<\": \"&lt;\",\r\n        \">\": \"&gt;\",\r\n        \"&\": \"&amp;\",\r\n        \"'\": \"&apos;\",\r\n        '\"': \"&quot;\"\r\n    };\r\n    function escapeXML(str) {\r\n        return str.replace(/[<>&'\"]/g, (c) => xmlEscapeChars[c] ?? c);\r\n    }\r\n    const dataURLBlobURLs = new Map();\r\n    function tryConvertDataURLToBlobSync(dataURL) {\r\n        const colonIndex = dataURL.indexOf(\":\");\r\n        const semicolonIndex = dataURL.indexOf(\";\", colonIndex + 1);\r\n        const commaIndex = dataURL.indexOf(\",\", semicolonIndex + 1);\r\n        const encoding = dataURL\r\n            .substring(semicolonIndex + 1, commaIndex)\r\n            .toLocaleLowerCase();\r\n        const mediaType = dataURL.substring(colonIndex + 1, semicolonIndex);\r\n        if (encoding !== \"base64\" || !mediaType) {\r\n            return null;\r\n        }\r\n        const characters = atob(dataURL.substring(commaIndex + 1));\r\n        const bytes = new Uint8Array(characters.length);\r\n        for (let i = 0; i < characters.length; i++) {\r\n            bytes[i] = characters.charCodeAt(i);\r\n        }\r\n        return new Blob([bytes], {type: mediaType});\r\n    }\r\n    async function tryConvertDataURLToBlobURL(dataURL) {\r\n        if (!isBlobURLSupported) {\r\n            return null;\r\n        }\r\n        const hash = getHashCode(dataURL);\r\n        let blobURL = dataURLBlobURLs.get(hash);\r\n        if (blobURL) {\r\n            return blobURL;\r\n        }\r\n        let blob = tryConvertDataURLToBlobSync(dataURL);\r\n        if (!blob) {\r\n            const response = await fetch(dataURL);\r\n            blob = await response.blob();\r\n        }\r\n        blobURL = URL.createObjectURL(blob);\r\n        dataURLBlobURLs.set(hash, blobURL);\r\n        return blobURL;\r\n    }\r\n    function cleanImageProcessingCache() {\r\n        imageManager && imageManager.stop();\r\n        removeCanvas();\r\n        objectURLs.forEach((u) => URL.revokeObjectURL(u));\r\n        objectURLs.clear();\r\n        dataURLBlobURLs.forEach((u) => URL.revokeObjectURL(u));\r\n        dataURLBlobURLs.clear();\r\n    }\r\n\r\n    let variablesSheet;\r\n    const registeredColors = new Map();\r\n    function registerVariablesSheet(sheet) {\r\n        variablesSheet = sheet;\r\n        const types = [\"background\", \"text\", \"border\"];\r\n        registeredColors.forEach((registered) => {\r\n            types.forEach((type) => {\r\n                if (registered[type]) {\r\n                    const {variable, value} = registered[type];\r\n                    variablesSheet?.cssRules[0].style.setProperty(\r\n                        variable,\r\n                        value\r\n                    );\r\n                }\r\n            });\r\n        });\r\n    }\r\n    function releaseVariablesSheet() {\r\n        variablesSheet = null;\r\n        clearColorPalette();\r\n    }\r\n    function getRegisteredVariableValue(type, registered) {\r\n        return `var(${registered[type].variable}, ${registered[type].value})`;\r\n    }\r\n    function getRegisteredColor(type, parsed) {\r\n        const hex = rgbToHexString(parsed);\r\n        const registered = registeredColors.get(hex);\r\n        if (registered?.[type]) {\r\n            return getRegisteredVariableValue(type, registered);\r\n        }\r\n        return null;\r\n    }\r\n    function registerColor(type, parsed, value) {\r\n        const hex = rgbToHexString(parsed);\r\n        let registered;\r\n        if (registeredColors.has(hex)) {\r\n            registered = registeredColors.get(hex);\r\n        } else {\r\n            const parsed = parseColorWithCache(hex);\r\n            registered = {parsed};\r\n            registeredColors.set(hex, registered);\r\n        }\r\n        const variable = `--darkreader-${type}-${hex.replace(\"#\", \"\")}`;\r\n        registered[type] = {variable, value};\r\n        if (variablesSheet?.cssRules[0]?.style) {\r\n            variablesSheet?.cssRules[0].style.setProperty(variable, value);\r\n        }\r\n        return getRegisteredVariableValue(type, registered);\r\n    }\r\n    function getColorPalette() {\r\n        const background = [];\r\n        const border = [];\r\n        const text = [];\r\n        registeredColors.forEach((registered) => {\r\n            if (registered.background) {\r\n                background.push(registered.parsed);\r\n            }\r\n            if (registered.border) {\r\n                border.push(registered.parsed);\r\n            }\r\n            if (registered.text) {\r\n                text.push(registered.parsed);\r\n            }\r\n        });\r\n        return {background, border, text};\r\n    }\r\n    function clearColorPalette() {\r\n        registeredColors.clear();\r\n    }\r\n\r\n    function getBgPole(theme) {\r\n        const isDarkScheme = theme.mode === 1;\r\n        const prop = isDarkScheme\r\n            ? \"darkSchemeBackgroundColor\"\r\n            : \"lightSchemeBackgroundColor\";\r\n        return theme[prop];\r\n    }\r\n    function getFgPole(theme) {\r\n        const isDarkScheme = theme.mode === 1;\r\n        const prop = isDarkScheme\r\n            ? \"darkSchemeTextColor\"\r\n            : \"lightSchemeTextColor\";\r\n        return theme[prop];\r\n    }\r\n    const colorModificationCache = new Map();\r\n    function clearColorModificationCache() {\r\n        colorModificationCache.clear();\r\n    }\r\n    const rgbCacheKeys = [\"r\", \"g\", \"b\", \"a\"];\r\n    const themeCacheKeys$1 = [\r\n        \"mode\",\r\n        \"brightness\",\r\n        \"contrast\",\r\n        \"grayscale\",\r\n        \"sepia\",\r\n        \"darkSchemeBackgroundColor\",\r\n        \"darkSchemeTextColor\",\r\n        \"lightSchemeBackgroundColor\",\r\n        \"lightSchemeTextColor\"\r\n    ];\r\n    function getCacheId(rgb, theme) {\r\n        let resultId = \"\";\r\n        rgbCacheKeys.forEach((key) => {\r\n            resultId += `${rgb[key]};`;\r\n        });\r\n        themeCacheKeys$1.forEach((key) => {\r\n            resultId += `${theme[key]};`;\r\n        });\r\n        return resultId;\r\n    }\r\n    function modifyColorWithCache(\r\n        rgb,\r\n        theme,\r\n        modifyHSL,\r\n        poleColor,\r\n        anotherPoleColor\r\n    ) {\r\n        let fnCache;\r\n        if (colorModificationCache.has(modifyHSL)) {\r\n            fnCache = colorModificationCache.get(modifyHSL);\r\n        } else {\r\n            fnCache = new Map();\r\n            colorModificationCache.set(modifyHSL, fnCache);\r\n        }\r\n        const id = getCacheId(rgb, theme);\r\n        if (fnCache.has(id)) {\r\n            return fnCache.get(id);\r\n        }\r\n        const hsl = rgbToHSL(rgb);\r\n        const pole = poleColor == null ? null : parseToHSLWithCache(poleColor);\r\n        const anotherPole =\r\n            anotherPoleColor == null\r\n                ? null\r\n                : parseToHSLWithCache(anotherPoleColor);\r\n        const modified = modifyHSL(hsl, pole, anotherPole);\r\n        const {r, g, b, a} = hslToRGB(modified);\r\n        const matrix = createFilterMatrix(theme);\r\n        const [rf, gf, bf] = applyColorMatrix([r, g, b], matrix);\r\n        const color =\r\n            a === 1\r\n                ? rgbToHexString({r: rf, g: gf, b: bf})\r\n                : rgbToString({r: rf, g: gf, b: bf, a});\r\n        fnCache.set(id, color);\r\n        return color;\r\n    }\r\n    function modifyAndRegisterColor(type, rgb, theme, modifier) {\r\n        const registered = getRegisteredColor(type, rgb);\r\n        if (registered) {\r\n            return registered;\r\n        }\r\n        const value = modifier(rgb, theme);\r\n        return registerColor(type, rgb, value);\r\n    }\r\n    function modifyLightSchemeColor(rgb, theme) {\r\n        const poleBg = getBgPole(theme);\r\n        const poleFg = getFgPole(theme);\r\n        return modifyColorWithCache(\r\n            rgb,\r\n            theme,\r\n            modifyLightModeHSL,\r\n            poleFg,\r\n            poleBg\r\n        );\r\n    }\r\n    function modifyLightModeHSL({h, s, l, a}, poleFg, poleBg) {\r\n        const isDark = l < 0.5;\r\n        let isNeutral;\r\n        if (isDark) {\r\n            isNeutral = l < 0.2 || s < 0.12;\r\n        } else {\r\n            const isBlue = h > 200 && h < 280;\r\n            isNeutral = s < 0.24 || (l > 0.8 && isBlue);\r\n        }\r\n        let hx = h;\r\n        let sx = l;\r\n        if (isNeutral) {\r\n            if (isDark) {\r\n                hx = poleFg.h;\r\n                sx = poleFg.s;\r\n            } else {\r\n                hx = poleBg.h;\r\n                sx = poleBg.s;\r\n            }\r\n        }\r\n        const lx = scale(l, 0, 1, poleFg.l, poleBg.l);\r\n        return {h: hx, s: sx, l: lx, a};\r\n    }\r\n    const MAX_BG_LIGHTNESS = 0.4;\r\n    function modifyBgHSL({h, s, l, a}, pole) {\r\n        const isDark = l < 0.5;\r\n        const isBlue = h > 200 && h < 280;\r\n        const isNeutral = s < 0.12 || (l > 0.8 && isBlue);\r\n        if (isDark) {\r\n            const lx = scale(l, 0, 0.5, 0, MAX_BG_LIGHTNESS);\r\n            if (isNeutral) {\r\n                const hx = pole.h;\r\n                const sx = pole.s;\r\n                return {h: hx, s: sx, l: lx, a};\r\n            }\r\n            return {h, s, l: lx, a};\r\n        }\r\n        let lx = scale(l, 0.5, 1, MAX_BG_LIGHTNESS, pole.l);\r\n        if (isNeutral) {\r\n            const hx = pole.h;\r\n            const sx = pole.s;\r\n            return {h: hx, s: sx, l: lx, a};\r\n        }\r\n        let hx = h;\r\n        const isYellow = h > 60 && h < 180;\r\n        if (isYellow) {\r\n            const isCloserToGreen = h > 120;\r\n            if (isCloserToGreen) {\r\n                hx = scale(h, 120, 180, 135, 180);\r\n            } else {\r\n                hx = scale(h, 60, 120, 60, 105);\r\n            }\r\n        }\r\n        if (hx > 40 && hx < 80) {\r\n            lx *= 0.75;\r\n        }\r\n        return {h: hx, s, l: lx, a};\r\n    }\r\n    function _modifyBackgroundColor(rgb, theme) {\r\n        if (theme.mode === 0) {\r\n            return modifyLightSchemeColor(rgb, theme);\r\n        }\r\n        const pole = getBgPole(theme);\r\n        return modifyColorWithCache(\r\n            rgb,\r\n            {...theme, mode: 0},\r\n            modifyBgHSL,\r\n            pole\r\n        );\r\n    }\r\n    function modifyBackgroundColor(\r\n        rgb,\r\n        theme,\r\n        shouldRegisterColorVariable = true\r\n    ) {\r\n        if (!shouldRegisterColorVariable) {\r\n            return _modifyBackgroundColor(rgb, theme);\r\n        }\r\n        return modifyAndRegisterColor(\r\n            \"background\",\r\n            rgb,\r\n            theme,\r\n            _modifyBackgroundColor\r\n        );\r\n    }\r\n    const MIN_FG_LIGHTNESS = 0.55;\r\n    function modifyBlueFgHue(hue) {\r\n        return scale(hue, 205, 245, 205, 220);\r\n    }\r\n    function modifyFgHSL({h, s, l, a}, pole) {\r\n        const isLight = l > 0.5;\r\n        const isNeutral = l < 0.2 || s < 0.24;\r\n        const isBlue = !isNeutral && h > 205 && h < 245;\r\n        if (isLight) {\r\n            const lx = scale(l, 0.5, 1, MIN_FG_LIGHTNESS, pole.l);\r\n            if (isNeutral) {\r\n                const hx = pole.h;\r\n                const sx = pole.s;\r\n                return {h: hx, s: sx, l: lx, a};\r\n            }\r\n            let hx = h;\r\n            if (isBlue) {\r\n                hx = modifyBlueFgHue(h);\r\n            }\r\n            return {h: hx, s, l: lx, a};\r\n        }\r\n        if (isNeutral) {\r\n            const hx = pole.h;\r\n            const sx = pole.s;\r\n            const lx = scale(l, 0, 0.5, pole.l, MIN_FG_LIGHTNESS);\r\n            return {h: hx, s: sx, l: lx, a};\r\n        }\r\n        let hx = h;\r\n        let lx;\r\n        if (isBlue) {\r\n            hx = modifyBlueFgHue(h);\r\n            lx = scale(l, 0, 0.5, pole.l, Math.min(1, MIN_FG_LIGHTNESS + 0.05));\r\n        } else {\r\n            lx = scale(l, 0, 0.5, pole.l, MIN_FG_LIGHTNESS);\r\n        }\r\n        return {h: hx, s, l: lx, a};\r\n    }\r\n    function _modifyForegroundColor(rgb, theme) {\r\n        if (theme.mode === 0) {\r\n            return modifyLightSchemeColor(rgb, theme);\r\n        }\r\n        const pole = getFgPole(theme);\r\n        return modifyColorWithCache(\r\n            rgb,\r\n            {...theme, mode: 0},\r\n            modifyFgHSL,\r\n            pole\r\n        );\r\n    }\r\n    function modifyForegroundColor(\r\n        rgb,\r\n        theme,\r\n        shouldRegisterColorVariable = true\r\n    ) {\r\n        if (!shouldRegisterColorVariable) {\r\n            return _modifyForegroundColor(rgb, theme);\r\n        }\r\n        return modifyAndRegisterColor(\r\n            \"text\",\r\n            rgb,\r\n            theme,\r\n            _modifyForegroundColor\r\n        );\r\n    }\r\n    function modifyBorderHSL({h, s, l, a}, poleFg, poleBg) {\r\n        const isDark = l < 0.5;\r\n        const isNeutral = l < 0.2 || s < 0.24;\r\n        let hx = h;\r\n        let sx = s;\r\n        if (isNeutral) {\r\n            if (isDark) {\r\n                hx = poleFg.h;\r\n                sx = poleFg.s;\r\n            } else {\r\n                hx = poleBg.h;\r\n                sx = poleBg.s;\r\n            }\r\n        }\r\n        const lx = scale(l, 0, 1, 0.5, 0.2);\r\n        return {h: hx, s: sx, l: lx, a};\r\n    }\r\n    function _modifyBorderColor(rgb, theme) {\r\n        if (theme.mode === 0) {\r\n            return modifyLightSchemeColor(rgb, theme);\r\n        }\r\n        const poleFg = getFgPole(theme);\r\n        const poleBg = getBgPole(theme);\r\n        return modifyColorWithCache(\r\n            rgb,\r\n            {...theme, mode: 0},\r\n            modifyBorderHSL,\r\n            poleFg,\r\n            poleBg\r\n        );\r\n    }\r\n    function modifyBorderColor(rgb, theme, shouldRegisterColorVariable = true) {\r\n        if (!shouldRegisterColorVariable) {\r\n            return _modifyBorderColor(rgb, theme);\r\n        }\r\n        return modifyAndRegisterColor(\"border\", rgb, theme, _modifyBorderColor);\r\n    }\r\n    function modifyShadowColor(rgb, theme) {\r\n        return modifyBackgroundColor(rgb, theme);\r\n    }\r\n    function modifyGradientColor(rgb, theme) {\r\n        return modifyBackgroundColor(rgb, theme);\r\n    }\r\n\r\n    function getPriority(ruleStyle, property) {\r\n        return Boolean(ruleStyle && ruleStyle.getPropertyPriority(property));\r\n    }\r\n    function getModifiableCSSDeclaration(\r\n        property,\r\n        value,\r\n        rule,\r\n        variablesStore,\r\n        ignoreImageSelectors,\r\n        isCancelled\r\n    ) {\r\n        let modifier = null;\r\n        if (property.startsWith(\"--\")) {\r\n            modifier = getVariableModifier(\r\n                variablesStore,\r\n                property,\r\n                value,\r\n                rule,\r\n                ignoreImageSelectors,\r\n                isCancelled\r\n            );\r\n        } else if (value.includes(\"var(\")) {\r\n            modifier = getVariableDependantModifier(\r\n                variablesStore,\r\n                property,\r\n                value\r\n            );\r\n        } else if (property === \"color-scheme\") {\r\n            modifier = getColorSchemeModifier();\r\n        } else if (property === \"scrollbar-color\") {\r\n            modifier = getScrollbarColorModifier(value);\r\n        } else if (\r\n            (property.includes(\"color\") &&\r\n                property !== \"-webkit-print-color-adjust\") ||\r\n            property === \"fill\" ||\r\n            property === \"stroke\" ||\r\n            property === \"stop-color\"\r\n        ) {\r\n            if (\r\n                property.startsWith(\"border\") &&\r\n                property !== \"border-color\" &&\r\n                value === \"initial\"\r\n            ) {\r\n                const borderSideProp = property.substring(\r\n                    0,\r\n                    property.length - 6\r\n                );\r\n                const borderSideVal =\r\n                    rule.style.getPropertyValue(borderSideProp);\r\n                if (\r\n                    borderSideVal.startsWith(\"0px\") ||\r\n                    borderSideVal === \"none\"\r\n                ) {\r\n                    property = borderSideProp;\r\n                    modifier = borderSideVal;\r\n                } else {\r\n                    modifier = value;\r\n                }\r\n            } else {\r\n                modifier = getColorModifier(property, value, rule);\r\n            }\r\n        } else if (\r\n            property === \"background-image\" ||\r\n            property === \"list-style-image\"\r\n        ) {\r\n            modifier = getBgImageModifier(\r\n                value,\r\n                rule,\r\n                ignoreImageSelectors,\r\n                isCancelled\r\n            );\r\n        } else if (property.includes(\"shadow\")) {\r\n            modifier = getShadowModifier(value);\r\n        }\r\n        if (!modifier) {\r\n            return null;\r\n        }\r\n        return {\r\n            property,\r\n            value: modifier,\r\n            important: getPriority(rule.style, property),\r\n            sourceValue: value\r\n        };\r\n    }\r\n    function joinSelectors(...selectors) {\r\n        return selectors.filter(Boolean).join(\", \");\r\n    }\r\n    const hostsWithOddScrollbars = [\"calendar.google.com\"];\r\n    function getModifiedUserAgentStyle(theme, isIFrame, styleSystemControls) {\r\n        const lines = [];\r\n        if (!isIFrame) {\r\n            lines.push(\"html {\");\r\n            lines.push(\r\n                `    background-color: ${modifyBackgroundColor({r: 255, g: 255, b: 255}, theme)} !important;`\r\n            );\r\n            lines.push(\"}\");\r\n        }\r\n        if (isCSSColorSchemePropSupported && theme.mode === 1) {\r\n            lines.push(\"html {\");\r\n            lines.push(`    color-scheme: dark !important;`);\r\n            lines.push(\"}\");\r\n            lines.push(\"iframe {\");\r\n            lines.push(`    color-scheme: dark !important;`);\r\n            lines.push(\"}\");\r\n        }\r\n        const bgSelectors = joinSelectors(\r\n            isIFrame ? \"\" : \"html, body\",\r\n            styleSystemControls ? \"input, textarea, select, button, dialog\" : \"\"\r\n        );\r\n        if (bgSelectors) {\r\n            lines.push(`${bgSelectors} {`);\r\n            lines.push(\r\n                `    background-color: ${modifyBackgroundColor({r: 255, g: 255, b: 255}, theme)};`\r\n            );\r\n            lines.push(\"}\");\r\n        }\r\n        lines.push(\r\n            `${joinSelectors(\"html, body\", styleSystemControls ? \"input, textarea, select, button\" : \"\")} {`\r\n        );\r\n        lines.push(\r\n            `    border-color: ${modifyBorderColor({r: 76, g: 76, b: 76}, theme)};`\r\n        );\r\n        lines.push(\r\n            `    color: ${modifyForegroundColor({r: 0, g: 0, b: 0}, theme)};`\r\n        );\r\n        lines.push(\"}\");\r\n        lines.push(\"a {\");\r\n        lines.push(\r\n            `    color: ${modifyForegroundColor({r: 0, g: 64, b: 255}, theme)};`\r\n        );\r\n        lines.push(\"}\");\r\n        lines.push(\"table {\");\r\n        lines.push(\r\n            `    border-color: ${modifyBorderColor({r: 128, g: 128, b: 128}, theme)};`\r\n        );\r\n        lines.push(\"}\");\r\n        lines.push(\"mark {\");\r\n        lines.push(\r\n            `    color: ${modifyForegroundColor({r: 0, g: 0, b: 0}, theme)};`\r\n        );\r\n        lines.push(\"}\");\r\n        lines.push(\"::placeholder {\");\r\n        lines.push(\r\n            `    color: ${modifyForegroundColor({r: 169, g: 169, b: 169}, theme)};`\r\n        );\r\n        lines.push(\"}\");\r\n        lines.push(\"input:-webkit-autofill,\");\r\n        lines.push(\"textarea:-webkit-autofill,\");\r\n        lines.push(\"select:-webkit-autofill {\");\r\n        lines.push(\r\n            `    background-color: ${modifyBackgroundColor({r: 250, g: 255, b: 189}, theme)} !important;`\r\n        );\r\n        lines.push(\r\n            `    color: ${modifyForegroundColor({r: 0, g: 0, b: 0}, theme)} !important;`\r\n        );\r\n        lines.push(\"}\");\r\n        if (\r\n            theme.scrollbarColor &&\r\n            !hostsWithOddScrollbars.includes(location.hostname)\r\n        ) {\r\n            lines.push(getModifiedScrollbarStyle(theme));\r\n        }\r\n        if (theme.selectionColor) {\r\n            lines.push(getModifiedSelectionStyle(theme));\r\n        }\r\n        if (isLayerRuleSupported) {\r\n            lines.unshift(\"@layer {\");\r\n            lines.push(\"}\");\r\n        }\r\n        return lines.join(\"\\n\");\r\n    }\r\n    function getSelectionColor(theme) {\r\n        let backgroundColorSelection;\r\n        let foregroundColorSelection;\r\n        if (theme.selectionColor === \"auto\") {\r\n            backgroundColorSelection = modifyBackgroundColor(\r\n                {r: 0, g: 96, b: 212},\r\n                {...theme, grayscale: 0}\r\n            );\r\n            foregroundColorSelection = modifyForegroundColor(\r\n                {r: 255, g: 255, b: 255},\r\n                {...theme, grayscale: 0}\r\n            );\r\n        } else {\r\n            const rgb = parseColorWithCache(theme.selectionColor);\r\n            const hsl = rgbToHSL(rgb);\r\n            backgroundColorSelection = theme.selectionColor;\r\n            if (hsl.l < 0.5) {\r\n                foregroundColorSelection = \"#FFF\";\r\n            } else {\r\n                foregroundColorSelection = \"#000\";\r\n            }\r\n        }\r\n        return {backgroundColorSelection, foregroundColorSelection};\r\n    }\r\n    function getModifiedSelectionStyle(theme) {\r\n        const lines = [];\r\n        const modifiedSelectionColor = getSelectionColor(theme);\r\n        const backgroundColorSelection =\r\n            modifiedSelectionColor.backgroundColorSelection;\r\n        const foregroundColorSelection =\r\n            modifiedSelectionColor.foregroundColorSelection;\r\n        [\"::selection\", \"::-moz-selection\"].forEach((selection) => {\r\n            lines.push(`${selection} {`);\r\n            lines.push(\r\n                `    background-color: ${backgroundColorSelection} !important;`\r\n            );\r\n            lines.push(`    color: ${foregroundColorSelection} !important;`);\r\n            lines.push(\"}\");\r\n        });\r\n        return lines.join(\"\\n\");\r\n    }\r\n    function getModifiedScrollbarStyle(theme) {\r\n        let colorTrack;\r\n        let colorThumb;\r\n        if (theme.scrollbarColor === \"auto\") {\r\n            colorTrack = modifyBackgroundColor({r: 241, g: 241, b: 241}, theme);\r\n            colorThumb = modifyBackgroundColor({r: 176, g: 176, b: 176}, theme);\r\n        } else {\r\n            const rgb = parseColorWithCache(theme.scrollbarColor);\r\n            const hsl = rgbToHSL(rgb);\r\n            const darken = (darker) => ({\r\n                ...hsl,\r\n                l: clamp(hsl.l - darker, 0, 1)\r\n            });\r\n            colorTrack = hslToString(darken(0.4));\r\n            colorThumb = hslToString(hsl);\r\n        }\r\n        return [\r\n            `* {`,\r\n            `    scrollbar-color: ${colorThumb} ${colorTrack};`,\r\n            `}`\r\n        ].join(\"\\n\");\r\n    }\r\n    function getModifiedFallbackStyle(theme, {strict}) {\r\n        const factory = defaultFallbackFactory;\r\n        return factory(theme, {strict});\r\n    }\r\n    function defaultFallbackFactory(theme, {strict}) {\r\n        const lines = [];\r\n        lines.push(\r\n            `html, body, ${strict ? \"body :not(iframe)\" : \"body > :not(iframe)\"} {`\r\n        );\r\n        lines.push(\r\n            `    background-color: ${modifyBackgroundColor({r: 255, g: 255, b: 255}, theme)} !important;`\r\n        );\r\n        lines.push(\r\n            `    border-color: ${modifyBorderColor({r: 64, g: 64, b: 64}, theme)} !important;`\r\n        );\r\n        lines.push(\r\n            `    color: ${modifyForegroundColor({r: 0, g: 0, b: 0}, theme)} !important;`\r\n        );\r\n        lines.push(\"}\");\r\n        lines.push(`div[style*=\"background-color: rgb(135, 135, 135)\"] {`);\r\n        lines.push(`    background-color: #878787 !important;`);\r\n        lines.push(\"}\");\r\n        return lines.join(\"\\n\");\r\n    }\r\n    const unparsableColors = new Set([\r\n        \"inherit\",\r\n        \"transparent\",\r\n        \"initial\",\r\n        \"currentcolor\",\r\n        \"none\",\r\n        \"unset\",\r\n        \"auto\"\r\n    ]);\r\n    function getColorModifier(prop, value, rule) {\r\n        if (unparsableColors.has(value.toLowerCase())) {\r\n            return value;\r\n        }\r\n        const rgb = parseColorWithCache(value);\r\n        if (!rgb) {\r\n            return null;\r\n        }\r\n        if (prop.includes(\"background\")) {\r\n            if (\r\n                (rule.style.webkitMaskImage &&\r\n                    rule.style.webkitMaskImage !== \"none\") ||\r\n                (rule.style.webkitMask &&\r\n                    !rule.style.webkitMask.startsWith(\"none\")) ||\r\n                (rule.style.mask && rule.style.mask !== \"none\") ||\r\n                (rule.style.getPropertyValue(\"mask-image\") &&\r\n                    rule.style.getPropertyValue(\"mask-image\") !== \"none\")\r\n            ) {\r\n                return (theme) => modifyForegroundColor(rgb, theme);\r\n            }\r\n            return (theme) => modifyBackgroundColor(rgb, theme);\r\n        }\r\n        if (prop.includes(\"border\") || prop.includes(\"outline\")) {\r\n            return (theme) => modifyBorderColor(rgb, theme);\r\n        }\r\n        return (theme) => modifyForegroundColor(rgb, theme);\r\n    }\r\n    const imageDetailsCache = new Map();\r\n    const awaitingForImageLoading = new Map();\r\n    let didTryLoadCache = false;\r\n    function shouldIgnoreImage(selectorText, selectors) {\r\n        if (!selectorText || selectors.length === 0) {\r\n            return false;\r\n        }\r\n        if (selectors.some((s) => s === \"*\")) {\r\n            return true;\r\n        }\r\n        const ruleSelectors = selectorText.split(/,\\s*/g);\r\n        for (let i = 0; i < selectors.length; i++) {\r\n            const ignoredSelector = selectors[i];\r\n            if (ignoredSelector.startsWith(\"^\")) {\r\n                const beginning = ignoredSelector.slice(1);\r\n                if (ruleSelectors.some((s) => s.startsWith(beginning))) {\r\n                    return true;\r\n                }\r\n            } else if (ignoredSelector.endsWith(\"$\")) {\r\n                const ending = ignoredSelector.slice(\r\n                    0,\r\n                    ignoredSelector.length - 1\r\n                );\r\n                if (ruleSelectors.some((s) => s.endsWith(ending))) {\r\n                    return true;\r\n                }\r\n            } else if (ruleSelectors.some((s) => s === ignoredSelector)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    const imageSelectorQueue = new Map();\r\n    const imageSelectorValues = new Map();\r\n    const imageSelectorNodeQueue = new Set();\r\n    let imageSelectorQueueFrameId = null;\r\n    let classObserver = null;\r\n    function checkImageSelectors(node) {\r\n        for (const [selector, callbacks] of imageSelectorQueue) {\r\n            if (\r\n                node.querySelector(selector) ||\r\n                (node instanceof Element && node.matches(selector))\r\n            ) {\r\n                imageSelectorQueue.delete(selector);\r\n                callbacks.forEach((cb) => cb());\r\n            }\r\n        }\r\n        if (!classObserver) {\r\n            classObserver = new MutationObserver((mutations) => {\r\n                mutations.forEach((mutation) => {\r\n                    imageSelectorNodeQueue.add(mutation.target);\r\n                    if (!imageSelectorQueueFrameId) {\r\n                        imageSelectorQueueFrameId = requestAnimationFrame(\r\n                            () => {\r\n                                imageSelectorNodeQueue.forEach((element) => {\r\n                                    checkImageSelectors(element);\r\n                                });\r\n                                imageSelectorNodeQueue.clear();\r\n                                imageSelectorQueueFrameId = null;\r\n                            }\r\n                        );\r\n                    }\r\n                });\r\n            });\r\n            classObserver.observe(document.documentElement, {\r\n                attributes: true,\r\n                attributeFilter: [\"class\"],\r\n                subtree: true\r\n            });\r\n        }\r\n    }\r\n    function getBgImageModifier(\r\n        value,\r\n        rule,\r\n        ignoreImageSelectors,\r\n        isCancelled\r\n    ) {\r\n        try {\r\n            if (shouldIgnoreImage(rule.selectorText, ignoreImageSelectors)) {\r\n                return value;\r\n            }\r\n            const gradients = parseGradient(value);\r\n            const urls = getMatches(cssURLRegex, value);\r\n            if (urls.length === 0 && gradients.length === 0) {\r\n                return value;\r\n            }\r\n            const getIndices = (matches) => {\r\n                let index = 0;\r\n                return matches.map((match) => {\r\n                    const valueIndex = value.indexOf(match, index);\r\n                    index = valueIndex + match.length;\r\n                    return {match, index: valueIndex};\r\n                });\r\n            };\r\n            const matches = gradients\r\n                .map((i) => ({type: \"gradient\", ...i}))\r\n                .concat(\r\n                    getIndices(urls).map((i) => ({\r\n                        type: \"url\",\r\n                        offset: 0,\r\n                        ...i\r\n                    }))\r\n                )\r\n                .sort((a, b) => (a.index > b.index ? 1 : -1));\r\n            const getGradientModifier = (gradient) => {\r\n                const {typeGradient, match, hasComma} = gradient;\r\n                const partsRegex =\r\n                    /([^\\(\\),]+(\\([^\\(\\)]*(\\([^\\(\\)]*\\)*[^\\(\\)]*)?\\))?([^\\(\\), ]|( (?!calc)))*),?/g;\r\n                const colorStopRegex =\r\n                    /^(from|color-stop|to)\\(([^\\(\\)]*?,\\s*)?(.*?)\\)$/;\r\n                const parts = getMatches(partsRegex, match, 1).map((part) => {\r\n                    part = part.trim();\r\n                    let rgb = parseColorWithCache(part);\r\n                    if (rgb) {\r\n                        return (theme) => modifyGradientColor(rgb, theme);\r\n                    }\r\n                    const space = part.lastIndexOf(\" \");\r\n                    rgb = parseColorWithCache(part.substring(0, space));\r\n                    if (rgb) {\r\n                        return (theme) =>\r\n                            `${modifyGradientColor(rgb, theme)} ${part.substring(space + 1)}`;\r\n                    }\r\n                    const colorStopMatch = part.match(colorStopRegex);\r\n                    if (colorStopMatch) {\r\n                        rgb = parseColorWithCache(colorStopMatch[3]);\r\n                        if (rgb) {\r\n                            return (theme) =>\r\n                                `${colorStopMatch[1]}(${colorStopMatch[2] ? `${colorStopMatch[2]}, ` : \"\"}${modifyGradientColor(rgb, theme)})`;\r\n                        }\r\n                    }\r\n                    return () => part;\r\n                });\r\n                return (theme) => {\r\n                    return `${typeGradient}(${parts.map((modify) => modify(theme)).join(\", \")})${hasComma ? \", \" : \"\"}`;\r\n                };\r\n            };\r\n            const getURLModifier = (urlValue) => {\r\n                if (!didTryLoadCache) {\r\n                    didTryLoadCache = true;\r\n                    readImageDetailsCache(imageDetailsCache);\r\n                }\r\n                let url = getCSSURLValue(urlValue);\r\n                const isURLEmpty = url.length === 0;\r\n                const {parentStyleSheet} = rule;\r\n                const ownerNode = parentStyleSheet?.ownerNode;\r\n                const scope =\r\n                    (parentStyleSheet && getSheetScope(parentStyleSheet)) ??\r\n                    document;\r\n                const baseURL =\r\n                    parentStyleSheet && parentStyleSheet.href\r\n                        ? getCSSBaseBath(parentStyleSheet.href)\r\n                        : ownerNode?.baseURI || location.origin;\r\n                url = getAbsoluteURL(baseURL, url);\r\n                return async (theme) => {\r\n                    if (isURLEmpty) {\r\n                        return \"url('')\";\r\n                    }\r\n                    let selector = rule.selectorText;\r\n                    if (selector) {\r\n                        if (selector.includes(\"::before\")) {\r\n                            selector = selector.replaceAll(\"::before\", \"\");\r\n                        }\r\n                        if (selector.includes(\"::after\")) {\r\n                            selector = selector.replaceAll(\"::after\", \"\");\r\n                        }\r\n                        if (!scope.querySelector(selector)) {\r\n                            await new Promise((resolve) => {\r\n                                if (imageSelectorQueue.has(selector)) {\r\n                                    imageSelectorQueue\r\n                                        .get(selector)\r\n                                        .push(resolve);\r\n                                } else {\r\n                                    imageSelectorQueue.set(selector, [resolve]);\r\n                                    imageSelectorValues.set(selector, urlValue);\r\n                                }\r\n                            });\r\n                        }\r\n                    }\r\n                    let imageDetails = null;\r\n                    if (imageDetailsCache.has(url)) {\r\n                        imageDetails = imageDetailsCache.get(url);\r\n                    } else {\r\n                        try {\r\n                            if (!isBlobURLCheckResultReady()) {\r\n                                await requestBlobURLCheck();\r\n                            }\r\n                            if (awaitingForImageLoading.has(url)) {\r\n                                const awaiters =\r\n                                    awaitingForImageLoading.get(url);\r\n                                imageDetails = await new Promise((resolve) =>\r\n                                    awaiters.push(resolve)\r\n                                );\r\n                                if (!imageDetails) {\r\n                                    return null;\r\n                                }\r\n                            } else {\r\n                                awaitingForImageLoading.set(url, []);\r\n                                imageDetails = await getImageDetails(url);\r\n                                imageDetailsCache.set(url, imageDetails);\r\n                                writeImageDetailsCache(url, imageDetails);\r\n                                awaitingForImageLoading\r\n                                    .get(url)\r\n                                    .forEach((resolve) =>\r\n                                        resolve(imageDetails)\r\n                                    );\r\n                                awaitingForImageLoading.delete(url);\r\n                            }\r\n                            if (isCancelled()) {\r\n                                return null;\r\n                            }\r\n                        } catch (err) {\r\n                            logWarn(err);\r\n                            if (awaitingForImageLoading.has(url)) {\r\n                                awaitingForImageLoading\r\n                                    .get(url)\r\n                                    .forEach((resolve) => resolve(null));\r\n                                awaitingForImageLoading.delete(url);\r\n                            }\r\n                        }\r\n                    }\r\n                    if (imageDetails) {\r\n                        const bgImageValue = getBgImageValue(\r\n                            imageDetails,\r\n                            theme\r\n                        );\r\n                        if (bgImageValue) {\r\n                            return bgImageValue;\r\n                        }\r\n                    }\r\n                    if (url.startsWith(\"data:\")) {\r\n                        const blobURL = await tryConvertDataURLToBlobURL(url);\r\n                        if (blobURL) {\r\n                            return `url(\"${blobURL}\")`;\r\n                        }\r\n                    }\r\n                    return `url(\"${url}\")`;\r\n                };\r\n            };\r\n            const getBgImageValue = (imageDetails, theme) => {\r\n                const {isDark, isLight, isTransparent, isLarge, width} =\r\n                    imageDetails;\r\n                let result;\r\n                const logSrc = imageDetails.src.startsWith(\"data:\")\r\n                    ? \"data:\"\r\n                    : imageDetails.src;\r\n                if (isLarge && isLight && !isTransparent && theme.mode === 1) {\r\n                    logInfo(`Hiding large light image ${logSrc}`);\r\n                    result = \"none\";\r\n                } else if (\r\n                    isDark &&\r\n                    isTransparent &&\r\n                    theme.mode === 1 &&\r\n                    width > 2\r\n                ) {\r\n                    logInfo(`Inverting dark image ${logSrc}`);\r\n                    const inverted = getFilteredImageURL(imageDetails, {\r\n                        ...theme,\r\n                        sepia: clamp(theme.sepia + 10, 0, 100)\r\n                    });\r\n                    result = `url(\"${inverted}\")`;\r\n                } else if (isLight && !isTransparent && theme.mode === 1) {\r\n                    logInfo(`Dimming light image ${logSrc}`);\r\n                    const dimmed = getFilteredImageURL(imageDetails, theme);\r\n                    result = `url(\"${dimmed}\")`;\r\n                } else if (theme.mode === 0 && isLight) {\r\n                    logInfo(`Applying filter to image ${logSrc}`);\r\n                    const filtered = getFilteredImageURL(imageDetails, {\r\n                        ...theme,\r\n                        brightness: clamp(theme.brightness - 10, 5, 200),\r\n                        sepia: clamp(theme.sepia + 10, 0, 100)\r\n                    });\r\n                    result = `url(\"${filtered}\")`;\r\n                } else {\r\n                    logInfo(`Not modifying the image ${logSrc}`);\r\n                    result = null;\r\n                }\r\n                return result;\r\n            };\r\n            const modifiers = [];\r\n            let matchIndex = 0;\r\n            let prevHasComma = false;\r\n            matches.forEach(\r\n                ({type, match, index, typeGradient, hasComma, offset}, i) => {\r\n                    const matchStart = index;\r\n                    const prefixStart = matchIndex;\r\n                    const matchEnd = matchStart + match.length + offset;\r\n                    matchIndex = matchEnd;\r\n                    if (prefixStart !== matchStart) {\r\n                        if (prevHasComma) {\r\n                            modifiers.push(() => {\r\n                                let betweenValue = value.substring(\r\n                                    prefixStart,\r\n                                    matchStart\r\n                                );\r\n                                if (betweenValue[0] === \",\") {\r\n                                    betweenValue = betweenValue.substring(1);\r\n                                }\r\n                                return betweenValue;\r\n                            });\r\n                        } else {\r\n                            modifiers.push(() =>\r\n                                value.substring(prefixStart, matchStart)\r\n                            );\r\n                        }\r\n                    }\r\n                    prevHasComma = hasComma || false;\r\n                    if (type === \"url\") {\r\n                        modifiers.push(getURLModifier(match));\r\n                    } else if (type === \"gradient\") {\r\n                        modifiers.push(\r\n                            getGradientModifier({\r\n                                match,\r\n                                index,\r\n                                typeGradient: typeGradient,\r\n                                hasComma: hasComma || false,\r\n                                offset\r\n                            })\r\n                        );\r\n                    }\r\n                    if (i === matches.length - 1) {\r\n                        modifiers.push(() => value.substring(matchEnd));\r\n                    }\r\n                }\r\n            );\r\n            return (theme) => {\r\n                const results = modifiers\r\n                    .filter(Boolean)\r\n                    .map((modify) => modify(theme));\r\n                if (results.some((r) => r instanceof Promise)) {\r\n                    return Promise.all(results).then((asyncResults) => {\r\n                        return asyncResults.filter(Boolean).join(\"\");\r\n                    });\r\n                }\r\n                const combinedResult = results.join(\"\");\r\n                if (combinedResult.endsWith(\", initial\")) {\r\n                    return combinedResult.slice(0, -9);\r\n                }\r\n                return combinedResult;\r\n            };\r\n        } catch (err) {\r\n            return null;\r\n        }\r\n    }\r\n    function getShadowModifierWithInfo(value) {\r\n        try {\r\n            let index = 0;\r\n            const colorMatches = getMatches(\r\n                /(^|\\s)(?!calc)([a-z]+\\(.+?\\)|#[0-9a-f]+|[a-z]+)(.*?(inset|outset)?($|,))/gi,\r\n                value,\r\n                2\r\n            );\r\n            let notParsed = 0;\r\n            const modifiers = colorMatches.map((match, i) => {\r\n                const prefixIndex = index;\r\n                const matchIndex = value.indexOf(match, index);\r\n                const matchEnd = matchIndex + match.length;\r\n                index = matchEnd;\r\n                const rgb = parseColorWithCache(match);\r\n                if (!rgb) {\r\n                    notParsed++;\r\n                    return () => value.substring(prefixIndex, matchEnd);\r\n                }\r\n                return (theme) =>\r\n                    `${value.substring(prefixIndex, matchIndex)}${modifyShadowColor(rgb, theme)}${i === colorMatches.length - 1 ? value.substring(matchEnd) : \"\"}`;\r\n            });\r\n            return (theme) => {\r\n                const modified = modifiers\r\n                    .map((modify) => modify(theme))\r\n                    .join(\"\");\r\n                return {\r\n                    matchesLength: colorMatches.length,\r\n                    unparsableMatchesLength: notParsed,\r\n                    result: modified\r\n                };\r\n            };\r\n        } catch (err) {\r\n            return null;\r\n        }\r\n    }\r\n    function getShadowModifier(value) {\r\n        const shadowModifier = getShadowModifierWithInfo(value);\r\n        if (!shadowModifier) {\r\n            return null;\r\n        }\r\n        return (theme) => shadowModifier(theme).result;\r\n    }\r\n    function getScrollbarColorModifier(value) {\r\n        const colorsMatch = value.match(\r\n            /^\\s*([a-z]+(\\(.*\\))?)\\s+([a-z]+(\\(.*\\))?)\\s*$/\r\n        );\r\n        if (!colorsMatch) {\r\n            return value;\r\n        }\r\n        const thumb = parseColorWithCache(colorsMatch[1]);\r\n        const track = parseColorWithCache(colorsMatch[3]);\r\n        if (!thumb || !track) {\r\n            return null;\r\n        }\r\n        return (theme) =>\r\n            `${modifyForegroundColor(thumb, theme)} ${modifyBackgroundColor(thumb, theme)}`;\r\n    }\r\n    function getColorSchemeModifier() {\r\n        return (theme) => (theme.mode === 0 ? \"dark light\" : \"dark\");\r\n    }\r\n    function getVariableModifier(\r\n        variablesStore,\r\n        prop,\r\n        value,\r\n        rule,\r\n        ignoredImgSelectors,\r\n        isCancelled\r\n    ) {\r\n        return variablesStore.getModifierForVariable({\r\n            varName: prop,\r\n            sourceValue: value,\r\n            rule,\r\n            ignoredImgSelectors,\r\n            isCancelled\r\n        });\r\n    }\r\n    function getVariableDependantModifier(variablesStore, prop, value) {\r\n        return variablesStore.getModifierForVarDependant(prop, value);\r\n    }\r\n    function cleanModificationCache() {\r\n        clearColorModificationCache();\r\n        imageDetailsCache.clear();\r\n        cleanImageProcessingCache();\r\n        awaitingForImageLoading.clear();\r\n        imageSelectorQueue.clear();\r\n        classObserver?.disconnect();\r\n        classObserver = null;\r\n    }\r\n\r\n    const VAR_TYPE_BG_COLOR = 1 << 0;\r\n    const VAR_TYPE_TEXT_COLOR = 1 << 1;\r\n    const VAR_TYPE_BORDER_COLOR = 1 << 2;\r\n    const VAR_TYPE_BG_IMG = 1 << 3;\r\n    class VariablesStore {\r\n        constructor() {\r\n            this.varTypes = new Map();\r\n            this.rulesQueue = new Set();\r\n            this.inlineStyleQueue = [];\r\n            this.definedVars = new Set();\r\n            this.varRefs = new Map();\r\n            this.unknownColorVars = new Set();\r\n            this.unknownBgVars = new Set();\r\n            this.undefinedVars = new Set();\r\n            this.initialVarTypes = new Map();\r\n            this.changedTypeVars = new Set();\r\n            this.typeChangeSubscriptions = new Map();\r\n            this.unstableVarValues = new Map();\r\n        }\r\n        clear() {\r\n            this.varTypes.clear();\r\n            this.rulesQueue.clear();\r\n            this.inlineStyleQueue.splice(0);\r\n            this.definedVars.clear();\r\n            this.varRefs.clear();\r\n            this.unknownColorVars.clear();\r\n            this.unknownBgVars.clear();\r\n            this.undefinedVars.clear();\r\n            this.initialVarTypes.clear();\r\n            this.changedTypeVars.clear();\r\n            this.typeChangeSubscriptions.clear();\r\n            this.unstableVarValues.clear();\r\n        }\r\n        isVarType(varName, typeNum) {\r\n            return (\r\n                this.varTypes.has(varName) &&\r\n                (this.varTypes.get(varName) & typeNum) > 0\r\n            );\r\n        }\r\n        addRulesForMatching(rules) {\r\n            this.rulesQueue.add(rules);\r\n        }\r\n        addInlineStyleForMatching(style) {\r\n            this.inlineStyleQueue.push(style);\r\n        }\r\n        matchVariablesAndDependents() {\r\n            if (\r\n                this.rulesQueue.size === 0 &&\r\n                this.inlineStyleQueue.length === 0\r\n            ) {\r\n                return;\r\n            }\r\n            this.changedTypeVars.clear();\r\n            this.initialVarTypes = new Map(this.varTypes);\r\n            this.collectRootVariables();\r\n            this.collectVariablesAndVarDep();\r\n            this.collectRootVarDependents();\r\n            this.varRefs.forEach((refs, v) => {\r\n                refs.forEach((r) => {\r\n                    if (this.varTypes.has(v)) {\r\n                        this.resolveVariableType(r, this.varTypes.get(v));\r\n                    }\r\n                });\r\n            });\r\n            this.unknownColorVars.forEach((v) => {\r\n                if (this.unknownBgVars.has(v)) {\r\n                    this.unknownColorVars.delete(v);\r\n                    this.unknownBgVars.delete(v);\r\n                    this.resolveVariableType(v, VAR_TYPE_BG_COLOR);\r\n                } else if (\r\n                    this.isVarType(\r\n                        v,\r\n                        VAR_TYPE_BG_COLOR |\r\n                            VAR_TYPE_TEXT_COLOR |\r\n                            VAR_TYPE_BORDER_COLOR\r\n                    )\r\n                ) {\r\n                    this.unknownColorVars.delete(v);\r\n                } else {\r\n                    this.undefinedVars.add(v);\r\n                }\r\n            });\r\n            this.unknownBgVars.forEach((v) => {\r\n                const hasColor =\r\n                    this.findVarRef(v, (ref) => {\r\n                        return (\r\n                            this.unknownColorVars.has(ref) ||\r\n                            this.isVarType(\r\n                                ref,\r\n                                VAR_TYPE_BG_COLOR |\r\n                                    VAR_TYPE_TEXT_COLOR |\r\n                                    VAR_TYPE_BORDER_COLOR\r\n                            )\r\n                        );\r\n                    }) != null;\r\n                if (hasColor) {\r\n                    this.iterateVarRefs(v, (ref) => {\r\n                        this.resolveVariableType(ref, VAR_TYPE_BG_COLOR);\r\n                    });\r\n                } else if (\r\n                    this.isVarType(v, VAR_TYPE_BG_COLOR | VAR_TYPE_BG_IMG)\r\n                ) {\r\n                    this.unknownBgVars.delete(v);\r\n                } else {\r\n                    this.undefinedVars.add(v);\r\n                }\r\n            });\r\n            this.changedTypeVars.forEach((varName) => {\r\n                if (this.typeChangeSubscriptions.has(varName)) {\r\n                    this.typeChangeSubscriptions\r\n                        .get(varName)\r\n                        .forEach((callback) => {\r\n                            callback();\r\n                        });\r\n                }\r\n            });\r\n            this.changedTypeVars.clear();\r\n        }\r\n        getModifierForVariable(options) {\r\n            return (theme) => {\r\n                const {\r\n                    varName,\r\n                    sourceValue,\r\n                    rule,\r\n                    ignoredImgSelectors,\r\n                    isCancelled\r\n                } = options;\r\n                const getDeclarations = () => {\r\n                    const declarations = [];\r\n                    const addModifiedValue = (\r\n                        typeNum,\r\n                        varNameWrapper,\r\n                        colorModifier\r\n                    ) => {\r\n                        if (!this.isVarType(varName, typeNum)) {\r\n                            return;\r\n                        }\r\n                        const property = varNameWrapper(varName);\r\n                        let modifiedValue;\r\n                        if (isVarDependant(sourceValue)) {\r\n                            if (isConstructedColorVar(sourceValue)) {\r\n                                let value = insertVarValues(\r\n                                    sourceValue,\r\n                                    this.unstableVarValues\r\n                                );\r\n                                if (!value) {\r\n                                    value =\r\n                                        typeNum === VAR_TYPE_BG_COLOR\r\n                                            ? \"#ffffff\"\r\n                                            : \"#000000\";\r\n                                }\r\n                                modifiedValue = colorModifier(value, theme);\r\n                            } else {\r\n                                modifiedValue = replaceCSSVariablesNames(\r\n                                    sourceValue,\r\n                                    (v) => varNameWrapper(v),\r\n                                    (fallback) => colorModifier(fallback, theme)\r\n                                );\r\n                            }\r\n                        } else {\r\n                            modifiedValue = colorModifier(sourceValue, theme);\r\n                        }\r\n                        declarations.push({\r\n                            property,\r\n                            value: modifiedValue\r\n                        });\r\n                    };\r\n                    addModifiedValue(\r\n                        VAR_TYPE_BG_COLOR,\r\n                        wrapBgColorVariableName,\r\n                        tryModifyBgColor\r\n                    );\r\n                    addModifiedValue(\r\n                        VAR_TYPE_TEXT_COLOR,\r\n                        wrapTextColorVariableName,\r\n                        tryModifyTextColor\r\n                    );\r\n                    addModifiedValue(\r\n                        VAR_TYPE_BORDER_COLOR,\r\n                        wrapBorderColorVariableName,\r\n                        tryModifyBorderColor\r\n                    );\r\n                    if (this.isVarType(varName, VAR_TYPE_BG_IMG)) {\r\n                        const property = wrapBgImgVariableName(varName);\r\n                        let modifiedValue = sourceValue;\r\n                        if (isVarDependant(sourceValue)) {\r\n                            modifiedValue = replaceCSSVariablesNames(\r\n                                sourceValue,\r\n                                (v) => wrapBgColorVariableName(v),\r\n                                (fallback) => tryModifyBgColor(fallback, theme)\r\n                            );\r\n                        }\r\n                        const bgModifier = getBgImageModifier(\r\n                            modifiedValue,\r\n                            rule,\r\n                            ignoredImgSelectors,\r\n                            isCancelled\r\n                        );\r\n                        modifiedValue =\r\n                            typeof bgModifier === \"function\"\r\n                                ? bgModifier(theme)\r\n                                : bgModifier;\r\n                        declarations.push({\r\n                            property,\r\n                            value: modifiedValue\r\n                        });\r\n                    }\r\n                    return declarations;\r\n                };\r\n                const callbacks = new Set();\r\n                const addListener = (onTypeChange) => {\r\n                    const callback = () => {\r\n                        const decs = getDeclarations();\r\n                        onTypeChange(decs);\r\n                    };\r\n                    callbacks.add(callback);\r\n                    this.subscribeForVarTypeChange(varName, callback);\r\n                };\r\n                const removeListeners = () => {\r\n                    callbacks.forEach((callback) => {\r\n                        this.unsubscribeFromVariableTypeChanges(\r\n                            varName,\r\n                            callback\r\n                        );\r\n                    });\r\n                };\r\n                return {\r\n                    declarations: getDeclarations(),\r\n                    onTypeChange: {addListener, removeListeners}\r\n                };\r\n            };\r\n        }\r\n        getModifierForVarDependant(property, sourceValue) {\r\n            const isConstructedColor = sourceValue.match(/^\\s*(rgb|hsl)a?\\(/);\r\n            const isSimpleConstructedColor = sourceValue.match(\r\n                /^rgba?\\(var\\(--[\\-_A-Za-z0-9]+\\)(\\s*,?\\/?\\s*0?\\.\\d+)?\\)$/\r\n            );\r\n            if (isConstructedColor && !isSimpleConstructedColor) {\r\n                const isBg = property.startsWith(\"background\");\r\n                const isText = isTextColorProperty(property);\r\n                return (theme) => {\r\n                    let value = insertVarValues(\r\n                        sourceValue,\r\n                        this.unstableVarValues\r\n                    );\r\n                    if (!value) {\r\n                        value = isBg ? \"#ffffff\" : \"#000000\";\r\n                    }\r\n                    const modifier = isBg\r\n                        ? tryModifyBgColor\r\n                        : isText\r\n                          ? tryModifyTextColor\r\n                          : tryModifyBorderColor;\r\n                    return modifier(value, theme);\r\n                };\r\n            }\r\n            if (\r\n                property === \"background-color\" ||\r\n                (isSimpleConstructedColor && property === \"background\")\r\n            ) {\r\n                return (theme) => {\r\n                    const defaultFallback = tryModifyBgColor(\r\n                        isConstructedColor ? \"255, 255, 255\" : \"#ffffff\",\r\n                        theme\r\n                    );\r\n                    return replaceCSSVariablesNames(\r\n                        sourceValue,\r\n                        (v) => wrapBgColorVariableName(v),\r\n                        (fallback) => tryModifyBgColor(fallback, theme),\r\n                        defaultFallback\r\n                    );\r\n                };\r\n            }\r\n            if (isTextColorProperty(property)) {\r\n                return (theme) => {\r\n                    const defaultFallback = tryModifyTextColor(\r\n                        isConstructedColor ? \"0, 0, 0\" : \"#000000\",\r\n                        theme\r\n                    );\r\n                    return replaceCSSVariablesNames(\r\n                        sourceValue,\r\n                        (v) => wrapTextColorVariableName(v),\r\n                        (fallback) => tryModifyTextColor(fallback, theme),\r\n                        defaultFallback\r\n                    );\r\n                };\r\n            }\r\n            if (\r\n                property === \"background\" ||\r\n                property === \"background-image\" ||\r\n                property === \"box-shadow\"\r\n            ) {\r\n                return (theme) => {\r\n                    const unknownVars = new Set();\r\n                    const modify = () => {\r\n                        const variableReplaced = replaceCSSVariablesNames(\r\n                            sourceValue,\r\n                            (v) => {\r\n                                if (this.isVarType(v, VAR_TYPE_BG_COLOR)) {\r\n                                    return wrapBgColorVariableName(v);\r\n                                }\r\n                                if (this.isVarType(v, VAR_TYPE_BG_IMG)) {\r\n                                    return wrapBgImgVariableName(v);\r\n                                }\r\n                                unknownVars.add(v);\r\n                                return v;\r\n                            },\r\n                            (fallback) => tryModifyBgColor(fallback, theme)\r\n                        );\r\n                        if (property === \"box-shadow\") {\r\n                            const shadowModifier =\r\n                                getShadowModifierWithInfo(variableReplaced);\r\n                            const modifiedShadow = shadowModifier(theme);\r\n                            if (\r\n                                modifiedShadow.unparsableMatchesLength !==\r\n                                modifiedShadow.matchesLength\r\n                            ) {\r\n                                return modifiedShadow.result;\r\n                            }\r\n                        }\r\n                        return variableReplaced;\r\n                    };\r\n                    const modified = modify();\r\n                    if (unknownVars.size > 0) {\r\n                        const isFallbackResolved = modified.match(\r\n                            /^var\\(.*?, (var\\(--darkreader-bg--.*\\))|(#[0-9A-Fa-f]+)|([a-z]+)|(rgba?\\(.+\\))|(hsla?\\(.+\\))\\)$/\r\n                        );\r\n                        if (isFallbackResolved) {\r\n                            return modified;\r\n                        }\r\n                        return new Promise((resolve) => {\r\n                            for (const unknownVar of unknownVars.values()) {\r\n                                const callback = () => {\r\n                                    this.unsubscribeFromVariableTypeChanges(\r\n                                        unknownVar,\r\n                                        callback\r\n                                    );\r\n                                    const newValue = modify();\r\n                                    resolve(newValue);\r\n                                };\r\n                                this.subscribeForVarTypeChange(\r\n                                    unknownVar,\r\n                                    callback\r\n                                );\r\n                            }\r\n                        });\r\n                    }\r\n                    return modified;\r\n                };\r\n            }\r\n            if (\r\n                property.startsWith(\"border\") ||\r\n                property.startsWith(\"outline\")\r\n            ) {\r\n                return (theme) => {\r\n                    return replaceCSSVariablesNames(\r\n                        sourceValue,\r\n                        (v) => wrapBorderColorVariableName(v),\r\n                        (fallback) => tryModifyBorderColor(fallback, theme)\r\n                    );\r\n                };\r\n            }\r\n            return null;\r\n        }\r\n        subscribeForVarTypeChange(varName, callback) {\r\n            if (!this.typeChangeSubscriptions.has(varName)) {\r\n                this.typeChangeSubscriptions.set(varName, new Set());\r\n            }\r\n            const rootStore = this.typeChangeSubscriptions.get(varName);\r\n            if (!rootStore.has(callback)) {\r\n                rootStore.add(callback);\r\n            }\r\n        }\r\n        unsubscribeFromVariableTypeChanges(varName, callback) {\r\n            if (this.typeChangeSubscriptions.has(varName)) {\r\n                this.typeChangeSubscriptions.get(varName).delete(callback);\r\n            }\r\n        }\r\n        collectVariablesAndVarDep() {\r\n            this.rulesQueue.forEach((rules) => {\r\n                iterateCSSRules(rules, (rule) => {\r\n                    if (rule.style) {\r\n                        this.collectVarsFromCSSDeclarations(rule.style);\r\n                    }\r\n                });\r\n            });\r\n            this.inlineStyleQueue.forEach((style) => {\r\n                this.collectVarsFromCSSDeclarations(style);\r\n            });\r\n            this.rulesQueue.clear();\r\n            this.inlineStyleQueue.splice(0);\r\n        }\r\n        collectVarsFromCSSDeclarations(style) {\r\n            iterateCSSDeclarations(style, (property, value) => {\r\n                if (isVariable(property)) {\r\n                    this.inspectVariable(property, value);\r\n                }\r\n                if (isVarDependant(value)) {\r\n                    this.inspectVarDependant(property, value);\r\n                }\r\n            });\r\n        }\r\n        shouldProcessRootVariables() {\r\n            return (\r\n                this.rulesQueue.size > 0 &&\r\n                document.documentElement.getAttribute(\"style\")?.includes(\"--\")\r\n            );\r\n        }\r\n        collectRootVariables() {\r\n            if (!this.shouldProcessRootVariables()) {\r\n                return;\r\n            }\r\n            iterateCSSDeclarations(\r\n                document.documentElement.style,\r\n                (property, value) => {\r\n                    if (isVariable(property)) {\r\n                        this.inspectVariable(property, value);\r\n                    }\r\n                }\r\n            );\r\n        }\r\n        inspectVariable(varName, value) {\r\n            this.unstableVarValues.set(varName, value);\r\n            if (isVarDependant(value) && isConstructedColorVar(value)) {\r\n                this.unknownColorVars.add(varName);\r\n                this.definedVars.add(varName);\r\n            }\r\n            if (this.definedVars.has(varName)) {\r\n                return;\r\n            }\r\n            this.definedVars.add(varName);\r\n            const isColor = Boolean(\r\n                value.match(rawRGBSpaceRegex) ||\r\n                    value.match(rawRGBCommaRegex) ||\r\n                    parseColorWithCache(value)\r\n            );\r\n            if (isColor) {\r\n                this.unknownColorVars.add(varName);\r\n            } else if (\r\n                value.includes(\"url(\") ||\r\n                value.includes(\"linear-gradient(\") ||\r\n                value.includes(\"radial-gradient(\")\r\n            ) {\r\n                this.resolveVariableType(varName, VAR_TYPE_BG_IMG);\r\n            }\r\n        }\r\n        resolveVariableType(varName, typeNum) {\r\n            const initialType = this.initialVarTypes.get(varName) || 0;\r\n            const currentType = this.varTypes.get(varName) || 0;\r\n            const newType = currentType | typeNum;\r\n            this.varTypes.set(varName, newType);\r\n            if (newType !== initialType || this.undefinedVars.has(varName)) {\r\n                this.changedTypeVars.add(varName);\r\n                this.undefinedVars.delete(varName);\r\n            }\r\n            this.unknownColorVars.delete(varName);\r\n            this.unknownBgVars.delete(varName);\r\n        }\r\n        collectRootVarDependents() {\r\n            if (!this.shouldProcessRootVariables()) {\r\n                return;\r\n            }\r\n            iterateCSSDeclarations(\r\n                document.documentElement.style,\r\n                (property, value) => {\r\n                    if (isVarDependant(value)) {\r\n                        this.inspectVarDependant(property, value);\r\n                    }\r\n                }\r\n            );\r\n        }\r\n        inspectVarDependant(property, value) {\r\n            if (isVariable(property)) {\r\n                this.iterateVarDeps(value, (ref) => {\r\n                    if (!this.varRefs.has(property)) {\r\n                        this.varRefs.set(property, new Set());\r\n                    }\r\n                    this.varRefs.get(property).add(ref);\r\n                });\r\n            } else if (\r\n                property === \"background-color\" ||\r\n                property === \"box-shadow\"\r\n            ) {\r\n                this.iterateVarDeps(value, (v) =>\r\n                    this.resolveVariableType(v, VAR_TYPE_BG_COLOR)\r\n                );\r\n            } else if (isTextColorProperty(property)) {\r\n                this.iterateVarDeps(value, (v) =>\r\n                    this.resolveVariableType(v, VAR_TYPE_TEXT_COLOR)\r\n                );\r\n            } else if (\r\n                property.startsWith(\"border\") ||\r\n                property.startsWith(\"outline\")\r\n            ) {\r\n                this.iterateVarDeps(value, (v) =>\r\n                    this.resolveVariableType(v, VAR_TYPE_BORDER_COLOR)\r\n                );\r\n            } else if (\r\n                property === \"background\" ||\r\n                property === \"background-image\"\r\n            ) {\r\n                this.iterateVarDeps(value, (v) => {\r\n                    if (\r\n                        this.isVarType(v, VAR_TYPE_BG_COLOR | VAR_TYPE_BG_IMG)\r\n                    ) {\r\n                        return;\r\n                    }\r\n                    const isBgColor =\r\n                        this.findVarRef(v, (ref) => {\r\n                            return (\r\n                                this.unknownColorVars.has(ref) ||\r\n                                this.isVarType(\r\n                                    ref,\r\n                                    VAR_TYPE_BG_COLOR |\r\n                                        VAR_TYPE_TEXT_COLOR |\r\n                                        VAR_TYPE_BORDER_COLOR\r\n                                )\r\n                            );\r\n                        }) != null;\r\n                    this.iterateVarRefs(v, (ref) => {\r\n                        if (isBgColor) {\r\n                            this.resolveVariableType(ref, VAR_TYPE_BG_COLOR);\r\n                        } else {\r\n                            this.unknownBgVars.add(ref);\r\n                        }\r\n                    });\r\n                });\r\n            }\r\n        }\r\n        iterateVarDeps(value, iterator) {\r\n            const varDeps = new Set();\r\n            iterateVarDependencies(value, (v) => varDeps.add(v));\r\n            varDeps.forEach((v) => iterator(v));\r\n        }\r\n        findVarRef(varName, iterator, stack = new Set()) {\r\n            if (stack.has(varName)) {\r\n                return null;\r\n            }\r\n            stack.add(varName);\r\n            const result = iterator(varName);\r\n            if (result) {\r\n                return varName;\r\n            }\r\n            const refs = this.varRefs.get(varName);\r\n            if (!refs || refs.size === 0) {\r\n                return null;\r\n            }\r\n            for (const ref of refs) {\r\n                const found = this.findVarRef(ref, iterator, stack);\r\n                if (found) {\r\n                    return found;\r\n                }\r\n            }\r\n            return null;\r\n        }\r\n        iterateVarRefs(varName, iterator) {\r\n            this.findVarRef(varName, (ref) => {\r\n                iterator(ref);\r\n                return false;\r\n            });\r\n        }\r\n        setOnRootVariableChange(callback) {\r\n            this.onRootVariableDefined = callback;\r\n        }\r\n        putRootVars(styleElement, theme) {\r\n            const sheet = styleElement.sheet;\r\n            if (sheet.cssRules.length > 0) {\r\n                sheet.deleteRule(0);\r\n            }\r\n            const declarations = new Map();\r\n            iterateCSSDeclarations(\r\n                document.documentElement.style,\r\n                (property, value) => {\r\n                    if (isVariable(property)) {\r\n                        if (this.isVarType(property, VAR_TYPE_BG_COLOR)) {\r\n                            declarations.set(\r\n                                wrapBgColorVariableName(property),\r\n                                tryModifyBgColor(value, theme)\r\n                            );\r\n                        }\r\n                        if (this.isVarType(property, VAR_TYPE_TEXT_COLOR)) {\r\n                            declarations.set(\r\n                                wrapTextColorVariableName(property),\r\n                                tryModifyTextColor(value, theme)\r\n                            );\r\n                        }\r\n                        if (this.isVarType(property, VAR_TYPE_BORDER_COLOR)) {\r\n                            declarations.set(\r\n                                wrapBorderColorVariableName(property),\r\n                                tryModifyBorderColor(value, theme)\r\n                            );\r\n                        }\r\n                        this.subscribeForVarTypeChange(\r\n                            property,\r\n                            this.onRootVariableDefined\r\n                        );\r\n                    }\r\n                }\r\n            );\r\n            const cssLines = [];\r\n            cssLines.push(\":root {\");\r\n            for (const [property, value] of declarations) {\r\n                cssLines.push(`    ${property}: ${value};`);\r\n            }\r\n            cssLines.push(\"}\");\r\n            const cssText = cssLines.join(\"\\n\");\r\n            sheet.insertRule(cssText);\r\n        }\r\n    }\r\n    const variablesStore = new VariablesStore();\r\n    function getVariableRange(input, searchStart = 0) {\r\n        const start = input.indexOf(\"var(\", searchStart);\r\n        if (start >= 0) {\r\n            const range = getParenthesesRange(input, start + 3);\r\n            if (range) {\r\n                return {start, end: range.end};\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    function getVariablesMatches(input) {\r\n        const ranges = [];\r\n        let i = 0;\r\n        let range;\r\n        while ((range = getVariableRange(input, i))) {\r\n            const {start, end} = range;\r\n            ranges.push({start, end, value: input.substring(start, end)});\r\n            i = range.end + 1;\r\n        }\r\n        return ranges;\r\n    }\r\n    function replaceVariablesMatches(input, replacer) {\r\n        const matches = getVariablesMatches(input);\r\n        const matchesCount = matches.length;\r\n        if (matchesCount === 0) {\r\n            return input;\r\n        }\r\n        const inputLength = input.length;\r\n        const replacements = matches.map((m) =>\r\n            replacer(m.value, matches.length)\r\n        );\r\n        const parts = [];\r\n        parts.push(input.substring(0, matches[0].start));\r\n        for (let i = 0; i < matchesCount; i++) {\r\n            parts.push(replacements[i]);\r\n            const start = matches[i].end;\r\n            const end =\r\n                i < matchesCount - 1 ? matches[i + 1].start : inputLength;\r\n            parts.push(input.substring(start, end));\r\n        }\r\n        return parts.join(\"\");\r\n    }\r\n    function getVariableNameAndFallback(match) {\r\n        const commaIndex = match.indexOf(\",\");\r\n        let name;\r\n        let fallback;\r\n        if (commaIndex >= 0) {\r\n            name = match.substring(4, commaIndex).trim();\r\n            fallback = match.substring(commaIndex + 1, match.length - 1).trim();\r\n        } else {\r\n            name = match.substring(4, match.length - 1).trim();\r\n            fallback = \"\";\r\n        }\r\n        return {name, fallback};\r\n    }\r\n    function replaceCSSVariablesNames(\r\n        value,\r\n        nameReplacer,\r\n        fallbackReplacer,\r\n        finalFallback\r\n    ) {\r\n        const matchReplacer = (match) => {\r\n            const {name, fallback} = getVariableNameAndFallback(match);\r\n            const newName = nameReplacer(name);\r\n            if (!fallback) {\r\n                if (finalFallback) {\r\n                    return `var(${newName}, ${finalFallback})`;\r\n                }\r\n                return `var(${newName})`;\r\n            }\r\n            let newFallback;\r\n            if (isVarDependant(fallback)) {\r\n                newFallback = replaceCSSVariablesNames(\r\n                    fallback,\r\n                    nameReplacer,\r\n                    fallbackReplacer\r\n                );\r\n            } else if (fallbackReplacer) {\r\n                newFallback = fallbackReplacer(fallback);\r\n            } else {\r\n                newFallback = fallback;\r\n            }\r\n            return `var(${newName}, ${newFallback})`;\r\n        };\r\n        return replaceVariablesMatches(value, matchReplacer);\r\n    }\r\n    function iterateVarDependencies(value, iterator) {\r\n        replaceCSSVariablesNames(value, (varName) => {\r\n            iterator(varName);\r\n            return varName;\r\n        });\r\n    }\r\n    function wrapBgColorVariableName(name) {\r\n        return `--darkreader-bg${name}`;\r\n    }\r\n    function wrapTextColorVariableName(name) {\r\n        return `--darkreader-text${name}`;\r\n    }\r\n    function wrapBorderColorVariableName(name) {\r\n        return `--darkreader-border${name}`;\r\n    }\r\n    function wrapBgImgVariableName(name) {\r\n        return `--darkreader-bgimg${name}`;\r\n    }\r\n    function isVariable(property) {\r\n        return property.startsWith(\"--\");\r\n    }\r\n    function isVarDependant(value) {\r\n        return value.includes(\"var(\");\r\n    }\r\n    function isConstructedColorVar(value) {\r\n        return (\r\n            value.match(/^\\s*(rgb|hsl)a?\\(/) ||\r\n            value.match(/^(((\\d{1,3})|(var\\([\\-_A-Za-z0-9]+\\))),?\\s*?){3}$/)\r\n        );\r\n    }\r\n    const textColorProps = [\r\n        \"color\",\r\n        \"caret-color\",\r\n        \"-webkit-text-fill-color\",\r\n        \"fill\",\r\n        \"stroke\"\r\n    ];\r\n    function isTextColorProperty(property) {\r\n        return textColorProps.includes(property);\r\n    }\r\n    const rawRGBSpaceRegex = /^(\\d{1,3})\\s+(\\d{1,3})\\s+(\\d{1,3})$/;\r\n    const rawRGBCommaRegex = /^(\\d{1,3}),\\s*(\\d{1,3}),\\s*(\\d{1,3})$/;\r\n    function parseRawColorValue(input) {\r\n        const match =\r\n            input.match(rawRGBSpaceRegex) ?? input.match(rawRGBCommaRegex);\r\n        if (match) {\r\n            const color = `rgb(${match[1]}, ${match[2]}, ${match[3]})`;\r\n            return {isRaw: true, color};\r\n        }\r\n        return {isRaw: false, color: input};\r\n    }\r\n    function handleRawColorValue(input, theme, modifyFunction) {\r\n        const {isRaw, color} = parseRawColorValue(input);\r\n        const rgb = parseColorWithCache(color);\r\n        if (rgb) {\r\n            const outputColor = modifyFunction(rgb, theme);\r\n            if (isRaw) {\r\n                const outputInRGB = parseColorWithCache(outputColor);\r\n                return outputInRGB\r\n                    ? `${outputInRGB.r}, ${outputInRGB.g}, ${outputInRGB.b}`\r\n                    : outputColor;\r\n            }\r\n            return outputColor;\r\n        }\r\n        return color;\r\n    }\r\n    function tryModifyBgColor(color, theme) {\r\n        return handleRawColorValue(color, theme, modifyBackgroundColor);\r\n    }\r\n    function tryModifyTextColor(color, theme) {\r\n        return handleRawColorValue(color, theme, modifyForegroundColor);\r\n    }\r\n    function tryModifyBorderColor(color, theme) {\r\n        return handleRawColorValue(color, theme, modifyBorderColor);\r\n    }\r\n    function insertVarValues(source, varValues, fullStack = new Set()) {\r\n        let containsUnresolvedVar = false;\r\n        const matchReplacer = (match, count) => {\r\n            const {name, fallback} = getVariableNameAndFallback(match);\r\n            const stack = count > 1 ? new Set(fullStack) : fullStack;\r\n            if (stack.has(name)) {\r\n                containsUnresolvedVar = true;\r\n                return null;\r\n            }\r\n            stack.add(name);\r\n            const varValue = varValues.get(name) || fallback;\r\n            let inserted = null;\r\n            if (varValue) {\r\n                if (isVarDependant(varValue)) {\r\n                    inserted = insertVarValues(varValue, varValues, stack);\r\n                } else {\r\n                    inserted = varValue;\r\n                }\r\n            }\r\n            if (!inserted) {\r\n                containsUnresolvedVar = true;\r\n                return null;\r\n            }\r\n            return inserted;\r\n        };\r\n        const replaced = replaceVariablesMatches(source, matchReplacer);\r\n        if (containsUnresolvedVar) {\r\n            return null;\r\n        }\r\n        return replaced;\r\n    }\r\n\r\n    const themeCacheKeys = [\r\n        \"mode\",\r\n        \"brightness\",\r\n        \"contrast\",\r\n        \"grayscale\",\r\n        \"sepia\",\r\n        \"darkSchemeBackgroundColor\",\r\n        \"darkSchemeTextColor\",\r\n        \"lightSchemeBackgroundColor\",\r\n        \"lightSchemeTextColor\"\r\n    ];\r\n    function getThemeKey(theme) {\r\n        let resultKey = \"\";\r\n        themeCacheKeys.forEach((key) => {\r\n            resultKey += `${key}:${theme[key]};`;\r\n        });\r\n        return resultKey;\r\n    }\r\n    const asyncQueue = createAsyncTasksQueue();\r\n    function createStyleSheetModifier() {\r\n        let renderId = 0;\r\n        function getStyleRuleHash(rule) {\r\n            let cssText = rule.cssText;\r\n            if (isMediaRule(rule.parentRule)) {\r\n                cssText = `${rule.parentRule.media.mediaText} { ${cssText} }`;\r\n            }\r\n            return getHashCode(cssText);\r\n        }\r\n        const rulesTextCache = new Set();\r\n        const rulesModCache = new Map();\r\n        const varTypeChangeCleaners = new Set();\r\n        let prevFilterKey = null;\r\n        let hasNonLoadedLink = false;\r\n        let wasRebuilt = false;\r\n        function shouldRebuildStyle() {\r\n            return hasNonLoadedLink && !wasRebuilt;\r\n        }\r\n        function modifySheet(options) {\r\n            const rules = options.sourceCSSRules;\r\n            const {\r\n                theme,\r\n                ignoreImageAnalysis,\r\n                force,\r\n                prepareSheet,\r\n                isAsyncCancelled\r\n            } = options;\r\n            let rulesChanged = rulesModCache.size === 0;\r\n            const notFoundCacheKeys = new Set(rulesModCache.keys());\r\n            const themeKey = getThemeKey(theme);\r\n            const themeChanged = themeKey !== prevFilterKey;\r\n            if (hasNonLoadedLink) {\r\n                wasRebuilt = true;\r\n            }\r\n            const modRules = [];\r\n            iterateCSSRules(\r\n                rules,\r\n                (rule) => {\r\n                    const hash = getStyleRuleHash(rule);\r\n                    let textDiffersFromPrev = false;\r\n                    notFoundCacheKeys.delete(hash);\r\n                    if (!rulesTextCache.has(hash)) {\r\n                        rulesTextCache.add(hash);\r\n                        textDiffersFromPrev = true;\r\n                    }\r\n                    if (textDiffersFromPrev) {\r\n                        rulesChanged = true;\r\n                    } else {\r\n                        modRules.push(rulesModCache.get(hash));\r\n                        return;\r\n                    }\r\n                    if (rule.style.all === \"revert\") {\r\n                        return;\r\n                    }\r\n                    const modDecs = [];\r\n                    rule.style &&\r\n                        iterateCSSDeclarations(\r\n                            rule.style,\r\n                            (property, value) => {\r\n                                const mod = getModifiableCSSDeclaration(\r\n                                    property,\r\n                                    value,\r\n                                    rule,\r\n                                    variablesStore,\r\n                                    ignoreImageAnalysis,\r\n                                    isAsyncCancelled\r\n                                );\r\n                                if (mod) {\r\n                                    modDecs.push(mod);\r\n                                }\r\n                            }\r\n                        );\r\n                    let modRule = null;\r\n                    if (modDecs.length > 0) {\r\n                        const parentRule = rule.parentRule;\r\n                        modRule = {\r\n                            selector: rule.selectorText,\r\n                            declarations: modDecs,\r\n                            parentRule\r\n                        };\r\n                        modRules.push(modRule);\r\n                    }\r\n                    rulesModCache.set(hash, modRule);\r\n                },\r\n                () => {\r\n                    hasNonLoadedLink = true;\r\n                }\r\n            );\r\n            notFoundCacheKeys.forEach((key) => {\r\n                rulesTextCache.delete(key);\r\n                rulesModCache.delete(key);\r\n            });\r\n            prevFilterKey = themeKey;\r\n            if (!force && !rulesChanged && !themeChanged) {\r\n                return;\r\n            }\r\n            renderId++;\r\n            function setRule(target, index, rule) {\r\n                const {selector, declarations} = rule;\r\n                let selectorText = selector;\r\n                const emptyIsWhereSelector =\r\n                    isChromium &&\r\n                    selector.startsWith(\":is(\") &&\r\n                    (selector.includes(\":is()\") ||\r\n                        selector.includes(\":where()\") ||\r\n                        (selector.includes(\":where(\") &&\r\n                            selector.includes(\":-moz\")));\r\n                const viewTransitionSelector =\r\n                    selector.includes(\"::view-transition-\");\r\n                if (emptyIsWhereSelector || viewTransitionSelector) {\r\n                    selectorText = \".darkreader-unsupported-selector\";\r\n                }\r\n                let ruleText = `${selectorText} {`;\r\n                for (const dec of declarations) {\r\n                    const {property, value, important} = dec;\r\n                    if (value) {\r\n                        ruleText += ` ${property}: ${value}${important ? \" !important\" : \"\"};`;\r\n                    }\r\n                }\r\n                ruleText += \" }\";\r\n                target.insertRule(ruleText, index);\r\n            }\r\n            const asyncDeclarations = new Map();\r\n            const varDeclarations = new Map();\r\n            let asyncDeclarationCounter = 0;\r\n            let varDeclarationCounter = 0;\r\n            const rootReadyGroup = {rule: null, rules: [], isGroup: true};\r\n            const groupRefs = new WeakMap();\r\n            function getGroup(rule) {\r\n                if (rule == null) {\r\n                    return rootReadyGroup;\r\n                }\r\n                if (groupRefs.has(rule)) {\r\n                    return groupRefs.get(rule);\r\n                }\r\n                const group = {rule, rules: [], isGroup: true};\r\n                groupRefs.set(rule, group);\r\n                const parentGroup = getGroup(rule.parentRule);\r\n                parentGroup.rules.push(group);\r\n                return group;\r\n            }\r\n            varTypeChangeCleaners.forEach((clear) => clear());\r\n            varTypeChangeCleaners.clear();\r\n            modRules\r\n                .filter((r) => r)\r\n                .forEach(({selector, declarations, parentRule}) => {\r\n                    const group = getGroup(parentRule);\r\n                    const readyStyleRule = {\r\n                        selector,\r\n                        declarations: [],\r\n                        isGroup: false\r\n                    };\r\n                    const readyDeclarations = readyStyleRule.declarations;\r\n                    group.rules.push(readyStyleRule);\r\n                    function handleAsyncDeclaration(\r\n                        property,\r\n                        modified,\r\n                        important,\r\n                        sourceValue\r\n                    ) {\r\n                        const asyncKey = ++asyncDeclarationCounter;\r\n                        const asyncDeclaration = {\r\n                            property,\r\n                            value: null,\r\n                            important,\r\n                            asyncKey,\r\n                            sourceValue\r\n                        };\r\n                        readyDeclarations.push(asyncDeclaration);\r\n                        const currentRenderId = renderId;\r\n                        modified.then((asyncValue) => {\r\n                            if (\r\n                                !asyncValue ||\r\n                                isAsyncCancelled() ||\r\n                                currentRenderId !== renderId\r\n                            ) {\r\n                                return;\r\n                            }\r\n                            asyncDeclaration.value = asyncValue;\r\n                            asyncQueue.add(() => {\r\n                                if (\r\n                                    isAsyncCancelled() ||\r\n                                    currentRenderId !== renderId\r\n                                ) {\r\n                                    return;\r\n                                }\r\n                                rebuildAsyncRule(asyncKey);\r\n                            });\r\n                        });\r\n                    }\r\n                    function handleVarDeclarations(\r\n                        property,\r\n                        modified,\r\n                        important,\r\n                        sourceValue\r\n                    ) {\r\n                        const {declarations: varDecs, onTypeChange} = modified;\r\n                        const varKey = ++varDeclarationCounter;\r\n                        const currentRenderId = renderId;\r\n                        const initialIndex = readyDeclarations.length;\r\n                        let oldDecs = [];\r\n                        if (varDecs.length === 0) {\r\n                            const tempDec = {\r\n                                property,\r\n                                value: sourceValue,\r\n                                important,\r\n                                sourceValue,\r\n                                varKey\r\n                            };\r\n                            readyDeclarations.push(tempDec);\r\n                            oldDecs = [tempDec];\r\n                        }\r\n                        varDecs.forEach((mod) => {\r\n                            if (mod.value instanceof Promise) {\r\n                                handleAsyncDeclaration(\r\n                                    mod.property,\r\n                                    mod.value,\r\n                                    important,\r\n                                    sourceValue\r\n                                );\r\n                            } else {\r\n                                const readyDec = {\r\n                                    property: mod.property,\r\n                                    value: mod.value,\r\n                                    important,\r\n                                    sourceValue,\r\n                                    varKey\r\n                                };\r\n                                readyDeclarations.push(readyDec);\r\n                                oldDecs.push(readyDec);\r\n                            }\r\n                        });\r\n                        onTypeChange.addListener((newDecs) => {\r\n                            if (\r\n                                isAsyncCancelled() ||\r\n                                currentRenderId !== renderId\r\n                            ) {\r\n                                return;\r\n                            }\r\n                            const readyVarDecs = newDecs.map((mod) => {\r\n                                return {\r\n                                    property: mod.property,\r\n                                    value: mod.value,\r\n                                    important,\r\n                                    sourceValue,\r\n                                    varKey\r\n                                };\r\n                            });\r\n                            const index = readyDeclarations.indexOf(\r\n                                oldDecs[0],\r\n                                initialIndex\r\n                            );\r\n                            readyDeclarations.splice(\r\n                                index,\r\n                                oldDecs.length,\r\n                                ...readyVarDecs\r\n                            );\r\n                            oldDecs = readyVarDecs;\r\n                            rebuildVarRule(varKey);\r\n                        });\r\n                        varTypeChangeCleaners.add(() =>\r\n                            onTypeChange.removeListeners()\r\n                        );\r\n                    }\r\n                    declarations.forEach(\r\n                        ({property, value, important, sourceValue}) => {\r\n                            if (typeof value === \"function\") {\r\n                                const modified = value(theme);\r\n                                if (modified instanceof Promise) {\r\n                                    handleAsyncDeclaration(\r\n                                        property,\r\n                                        modified,\r\n                                        important,\r\n                                        sourceValue\r\n                                    );\r\n                                } else if (property.startsWith(\"--\")) {\r\n                                    handleVarDeclarations(\r\n                                        property,\r\n                                        modified,\r\n                                        important,\r\n                                        sourceValue\r\n                                    );\r\n                                } else {\r\n                                    readyDeclarations.push({\r\n                                        property,\r\n                                        value: modified,\r\n                                        important,\r\n                                        sourceValue\r\n                                    });\r\n                                }\r\n                            } else {\r\n                                readyDeclarations.push({\r\n                                    property,\r\n                                    value,\r\n                                    important,\r\n                                    sourceValue\r\n                                });\r\n                            }\r\n                        }\r\n                    );\r\n                });\r\n            const sheet = prepareSheet();\r\n            function buildStyleSheet() {\r\n                function createTarget(group, parent) {\r\n                    const {rule} = group;\r\n                    if (isMediaRule(rule)) {\r\n                        const {media} = rule;\r\n                        const index = parent.cssRules.length;\r\n                        parent.insertRule(\r\n                            `@media ${media.mediaText} {}`,\r\n                            index\r\n                        );\r\n                        return parent.cssRules[index];\r\n                    }\r\n                    if (isLayerRule(rule)) {\r\n                        const {name} = rule;\r\n                        const index = parent.cssRules.length;\r\n                        parent.insertRule(`@layer ${name} {}`, index);\r\n                        return parent.cssRules[index];\r\n                    }\r\n                    return parent;\r\n                }\r\n                function iterateReadyRules(group, target, styleIterator) {\r\n                    group.rules.forEach((r) => {\r\n                        if (r.isGroup) {\r\n                            const t = createTarget(r, target);\r\n                            iterateReadyRules(r, t, styleIterator);\r\n                        } else {\r\n                            styleIterator(r, target);\r\n                        }\r\n                    });\r\n                }\r\n                iterateReadyRules(rootReadyGroup, sheet, (rule, target) => {\r\n                    const index = target.cssRules.length;\r\n                    rule.declarations.forEach(({asyncKey, varKey}) => {\r\n                        if (asyncKey != null) {\r\n                            asyncDeclarations.set(asyncKey, {\r\n                                rule,\r\n                                target,\r\n                                index\r\n                            });\r\n                        }\r\n                        if (varKey != null) {\r\n                            varDeclarations.set(varKey, {rule, target, index});\r\n                        }\r\n                    });\r\n                    setRule(target, index, rule);\r\n                });\r\n            }\r\n            function rebuildAsyncRule(key) {\r\n                const {rule, target, index} = asyncDeclarations.get(key);\r\n                target.deleteRule(index);\r\n                setRule(target, index, rule);\r\n                asyncDeclarations.delete(key);\r\n            }\r\n            function rebuildVarRule(key) {\r\n                const {rule, target, index} = varDeclarations.get(key);\r\n                target.deleteRule(index);\r\n                setRule(target, index, rule);\r\n            }\r\n            buildStyleSheet();\r\n        }\r\n        return {modifySheet, shouldRebuildStyle};\r\n    }\r\n\r\n    let canUseSheetProxy$1 = false;\r\n    document.addEventListener(\r\n        \"__darkreader__inlineScriptsAllowed\",\r\n        () => (canUseSheetProxy$1 = true),\r\n        {once: true}\r\n    );\r\n    const overrides$1 = new WeakSet();\r\n    const overridesBySource = new WeakMap();\r\n    function canHaveAdoptedStyleSheets(node) {\r\n        return Array.isArray(node.adoptedStyleSheets);\r\n    }\r\n    function createAdoptedStyleSheetOverride(node) {\r\n        let cancelAsyncOperations = false;\r\n        function iterateSourceSheets(iterator) {\r\n            node.adoptedStyleSheets.forEach((sheet) => {\r\n                if (!overrides$1.has(sheet)) {\r\n                    iterator(sheet);\r\n                }\r\n                defineSheetScope(sheet, node);\r\n            });\r\n        }\r\n        function injectSheet(sheet, override) {\r\n            const newSheets = [...node.adoptedStyleSheets];\r\n            const sheetIndex = newSheets.indexOf(sheet);\r\n            const overrideIndex = newSheets.indexOf(override);\r\n            if (overrideIndex >= 0) {\r\n                newSheets.splice(overrideIndex, 1);\r\n            }\r\n            newSheets.splice(sheetIndex + 1, 0, override);\r\n            node.adoptedStyleSheets = newSheets;\r\n        }\r\n        function clear() {\r\n            const newSheets = [...node.adoptedStyleSheets];\r\n            for (let i = newSheets.length - 1; i >= 0; i--) {\r\n                const sheet = newSheets[i];\r\n                if (overrides$1.has(sheet)) {\r\n                    newSheets.splice(i, 1);\r\n                }\r\n            }\r\n            if (node.adoptedStyleSheets.length !== newSheets.length) {\r\n                node.adoptedStyleSheets = newSheets;\r\n            }\r\n            sourceSheets = new WeakSet();\r\n            sourceDeclarations = new WeakSet();\r\n        }\r\n        const cleaners = [];\r\n        function destroy() {\r\n            cleaners.forEach((c) => c());\r\n            cleaners.splice(0);\r\n            cancelAsyncOperations = true;\r\n            clear();\r\n            if (frameId) {\r\n                cancelAnimationFrame(frameId);\r\n                frameId = null;\r\n            }\r\n        }\r\n        let rulesChangeKey = 0;\r\n        function getRulesChangeKey() {\r\n            let count = 0;\r\n            iterateSourceSheets((sheet) => {\r\n                count += sheet.cssRules.length;\r\n            });\r\n            if (count === 1) {\r\n                const rule = node.adoptedStyleSheets[0].cssRules[0];\r\n                return rule instanceof CSSStyleRule ? rule.style.length : count;\r\n            }\r\n            return count;\r\n        }\r\n        let sourceSheets = new WeakSet();\r\n        let sourceDeclarations = new WeakSet();\r\n        function render(theme, ignoreImageAnalysis) {\r\n            clear();\r\n            for (let i = node.adoptedStyleSheets.length - 1; i >= 0; i--) {\r\n                const sheet = node.adoptedStyleSheets[i];\r\n                if (overrides$1.has(sheet)) {\r\n                    continue;\r\n                }\r\n                sourceSheets.add(sheet);\r\n                const readyOverride = overridesBySource.get(sheet);\r\n                if (readyOverride) {\r\n                    rulesChangeKey = getRulesChangeKey();\r\n                    injectSheet(sheet, readyOverride);\r\n                    continue;\r\n                }\r\n                const rules = sheet.cssRules;\r\n                const override = new CSSStyleSheet();\r\n                overridesBySource.set(sheet, override);\r\n                iterateCSSRules(rules, (rule) =>\r\n                    sourceDeclarations.add(rule.style)\r\n                );\r\n                const prepareSheet = () => {\r\n                    for (let i = override.cssRules.length - 1; i >= 0; i--) {\r\n                        override.deleteRule(i);\r\n                    }\r\n                    override.insertRule(\"#__darkreader__adoptedOverride {}\");\r\n                    injectSheet(sheet, override);\r\n                    overrides$1.add(override);\r\n                    return override;\r\n                };\r\n                const sheetModifier = createStyleSheetModifier();\r\n                sheetModifier.modifySheet({\r\n                    prepareSheet,\r\n                    sourceCSSRules: rules,\r\n                    theme,\r\n                    ignoreImageAnalysis,\r\n                    force: false,\r\n                    isAsyncCancelled: () => cancelAsyncOperations\r\n                });\r\n            }\r\n            rulesChangeKey = getRulesChangeKey();\r\n        }\r\n        let callbackRequested = false;\r\n        function handleArrayChange(callback) {\r\n            if (callbackRequested) {\r\n                return;\r\n            }\r\n            callbackRequested = true;\r\n            queueMicrotask(() => {\r\n                callbackRequested = false;\r\n                const sheets = node.adoptedStyleSheets.filter(\r\n                    (s) => !overrides$1.has(s)\r\n                );\r\n                sheets.forEach((sheet) => overridesBySource.delete(sheet));\r\n                callback(sheets);\r\n            });\r\n        }\r\n        function checkForUpdates() {\r\n            return getRulesChangeKey() !== rulesChangeKey;\r\n        }\r\n        let frameId = null;\r\n        function watchUsingRAF(callback) {\r\n            frameId = requestAnimationFrame(() => {\r\n                if (canUseSheetProxy$1) {\r\n                    return;\r\n                }\r\n                if (checkForUpdates()) {\r\n                    handleArrayChange(callback);\r\n                }\r\n                watchUsingRAF(callback);\r\n            });\r\n        }\r\n        function addSheetChangeEventListener(type, listener) {\r\n            node.addEventListener(type, listener);\r\n            cleaners.push(() => node.removeEventListener(type, listener));\r\n        }\r\n        function watch(callback) {\r\n            const onAdoptedSheetsChange = () => {\r\n                canUseSheetProxy$1 = true;\r\n                handleArrayChange(callback);\r\n            };\r\n            addSheetChangeEventListener(\r\n                \"__darkreader__adoptedStyleSheetsChange\",\r\n                onAdoptedSheetsChange\r\n            );\r\n            addSheetChangeEventListener(\r\n                \"__darkreader__adoptedStyleSheetChange\",\r\n                onAdoptedSheetsChange\r\n            );\r\n            addSheetChangeEventListener(\r\n                \"__darkreader__adoptedStyleDeclarationChange\",\r\n                onAdoptedSheetsChange\r\n            );\r\n            if (canUseSheetProxy$1) {\r\n                return;\r\n            }\r\n            watchUsingRAF(callback);\r\n        }\r\n        return {\r\n            render,\r\n            destroy,\r\n            watch\r\n        };\r\n    }\r\n    class StyleSheetCommandBuilder {\r\n        constructor() {\r\n            this.cssRules = [];\r\n            this.commands = [];\r\n        }\r\n        insertRule(cssText, index = 0) {\r\n            this.commands.push({type: \"insert\", index, cssText});\r\n            this.cssRules.splice(index, 0, new StyleSheetCommandBuilder());\r\n            return index;\r\n        }\r\n        deleteRule(index) {\r\n            this.commands.push({type: \"delete\", index});\r\n            this.cssRules.splice(index, 1);\r\n        }\r\n        replaceSync(cssText) {\r\n            this.commands.splice(0);\r\n            this.commands.push({type: \"replace\", cssText});\r\n            if (cssText === \"\") {\r\n                this.cssRules.splice(0);\r\n            } else {\r\n                throw new Error(\r\n                    \"StyleSheetCommandBuilder.replaceSync() is not fully supported\"\r\n                );\r\n            }\r\n        }\r\n        getDeepCSSCommands() {\r\n            const deep = [];\r\n            this.commands.forEach((command) => {\r\n                deep.push({\r\n                    type: command.type,\r\n                    cssText: command.type !== \"delete\" ? command.cssText : \"\",\r\n                    path: command.type === \"replace\" ? [] : [command.index]\r\n                });\r\n            });\r\n            this.cssRules.forEach((rule, i) => {\r\n                const childCommands = rule.getDeepCSSCommands();\r\n                childCommands.forEach((c) => c.path.unshift(i));\r\n            });\r\n            return deep;\r\n        }\r\n        clearDeepCSSCommands() {\r\n            this.commands.splice(0);\r\n            this.cssRules.forEach((rule) => rule.clearDeepCSSCommands());\r\n        }\r\n    }\r\n    function createAdoptedStyleSheetFallback() {\r\n        let cancelAsyncOperations = false;\r\n        const builder = new StyleSheetCommandBuilder();\r\n        function render(options) {\r\n            const prepareSheet = () => {\r\n                builder.replaceSync(\"\");\r\n                return builder;\r\n            };\r\n            const sheetModifier = createStyleSheetModifier();\r\n            sheetModifier.modifySheet({\r\n                prepareSheet,\r\n                sourceCSSRules: options.cssRules,\r\n                theme: options.theme,\r\n                ignoreImageAnalysis: options.ignoreImageAnalysis,\r\n                force: false,\r\n                isAsyncCancelled: () => cancelAsyncOperations\r\n            });\r\n        }\r\n        function commands() {\r\n            const commands = builder.getDeepCSSCommands();\r\n            builder.clearDeepCSSCommands();\r\n            return commands;\r\n        }\r\n        function destroy() {\r\n            cancelAsyncOperations = true;\r\n        }\r\n        return {render, destroy, commands};\r\n    }\r\n\r\n    const overrides = {\r\n        \"background-color\": {\r\n            customProp: \"--darkreader-inline-bgcolor\",\r\n            cssProp: \"background-color\",\r\n            dataAttr: \"data-darkreader-inline-bgcolor\"\r\n        },\r\n        \"background-image\": {\r\n            customProp: \"--darkreader-inline-bgimage\",\r\n            cssProp: \"background-image\",\r\n            dataAttr: \"data-darkreader-inline-bgimage\"\r\n        },\r\n        \"border-color\": {\r\n            customProp: \"--darkreader-inline-border\",\r\n            cssProp: \"border-color\",\r\n            dataAttr: \"data-darkreader-inline-border\"\r\n        },\r\n        \"border-bottom-color\": {\r\n            customProp: \"--darkreader-inline-border-bottom\",\r\n            cssProp: \"border-bottom-color\",\r\n            dataAttr: \"data-darkreader-inline-border-bottom\"\r\n        },\r\n        \"border-left-color\": {\r\n            customProp: \"--darkreader-inline-border-left\",\r\n            cssProp: \"border-left-color\",\r\n            dataAttr: \"data-darkreader-inline-border-left\"\r\n        },\r\n        \"border-right-color\": {\r\n            customProp: \"--darkreader-inline-border-right\",\r\n            cssProp: \"border-right-color\",\r\n            dataAttr: \"data-darkreader-inline-border-right\"\r\n        },\r\n        \"border-top-color\": {\r\n            customProp: \"--darkreader-inline-border-top\",\r\n            cssProp: \"border-top-color\",\r\n            dataAttr: \"data-darkreader-inline-border-top\"\r\n        },\r\n        \"box-shadow\": {\r\n            customProp: \"--darkreader-inline-boxshadow\",\r\n            cssProp: \"box-shadow\",\r\n            dataAttr: \"data-darkreader-inline-boxshadow\"\r\n        },\r\n        \"color\": {\r\n            customProp: \"--darkreader-inline-color\",\r\n            cssProp: \"color\",\r\n            dataAttr: \"data-darkreader-inline-color\"\r\n        },\r\n        \"fill\": {\r\n            customProp: \"--darkreader-inline-fill\",\r\n            cssProp: \"fill\",\r\n            dataAttr: \"data-darkreader-inline-fill\"\r\n        },\r\n        \"stroke\": {\r\n            customProp: \"--darkreader-inline-stroke\",\r\n            cssProp: \"stroke\",\r\n            dataAttr: \"data-darkreader-inline-stroke\"\r\n        },\r\n        \"outline-color\": {\r\n            customProp: \"--darkreader-inline-outline\",\r\n            cssProp: \"outline-color\",\r\n            dataAttr: \"data-darkreader-inline-outline\"\r\n        },\r\n        \"stop-color\": {\r\n            customProp: \"--darkreader-inline-stopcolor\",\r\n            cssProp: \"stop-color\",\r\n            dataAttr: \"data-darkreader-inline-stopcolor\"\r\n        }\r\n    };\r\n    const shorthandOverrides = {\r\n        background: {\r\n            customProp: \"--darkreader-inline-bg\",\r\n            cssProp: \"background\",\r\n            dataAttr: \"data-darkreader-inline-bg\"\r\n        }\r\n    };\r\n    const overridesList = Object.values(overrides);\r\n    const normalizedPropList = {};\r\n    overridesList.forEach(\r\n        ({cssProp, customProp}) => (normalizedPropList[customProp] = cssProp)\r\n    );\r\n    const INLINE_STYLE_ATTRS = [\r\n        \"style\",\r\n        \"fill\",\r\n        \"stop-color\",\r\n        \"stroke\",\r\n        \"bgcolor\",\r\n        \"color\",\r\n        \"background\"\r\n    ];\r\n    const INLINE_STYLE_SELECTOR = INLINE_STYLE_ATTRS.map(\r\n        (attr) => `[${attr}]`\r\n    ).join(\", \");\r\n    function getInlineOverrideStyle() {\r\n        const allOverrides = overridesList.concat(\r\n            Object.values(shorthandOverrides)\r\n        );\r\n        return allOverrides\r\n            .map(({dataAttr, customProp, cssProp}) => {\r\n                return [\r\n                    `[${dataAttr}] {`,\r\n                    `  ${cssProp}: var(${customProp}) !important;`,\r\n                    \"}\"\r\n                ].join(\"\\n\");\r\n            })\r\n            .concat([\r\n                \"[data-darkreader-inline-invert] {\",\r\n                \"    filter: invert(100%) hue-rotate(180deg);\",\r\n                \"}\"\r\n            ])\r\n            .join(\"\\n\");\r\n    }\r\n    function getInlineStyleElements(root) {\r\n        const results = [];\r\n        if (root instanceof Element && root.matches(INLINE_STYLE_SELECTOR)) {\r\n            results.push(root);\r\n        }\r\n        if (\r\n            root instanceof Element ||\r\n            (isShadowDomSupported && root instanceof ShadowRoot) ||\r\n            root instanceof Document\r\n        ) {\r\n            push(results, root.querySelectorAll(INLINE_STYLE_SELECTOR));\r\n        }\r\n        return results;\r\n    }\r\n    const treeObservers = new Map();\r\n    const attrObservers = new Map();\r\n    function watchForInlineStyles(elementStyleDidChange, shadowRootDiscovered) {\r\n        deepWatchForInlineStyles(\r\n            document,\r\n            elementStyleDidChange,\r\n            shadowRootDiscovered\r\n        );\r\n        iterateShadowHosts(document.documentElement, (host) => {\r\n            deepWatchForInlineStyles(\r\n                host.shadowRoot,\r\n                elementStyleDidChange,\r\n                shadowRootDiscovered\r\n            );\r\n        });\r\n    }\r\n    function deepWatchForInlineStyles(\r\n        root,\r\n        elementStyleDidChange,\r\n        shadowRootDiscovered\r\n    ) {\r\n        if (treeObservers.has(root)) {\r\n            treeObservers.get(root).disconnect();\r\n            attrObservers.get(root).disconnect();\r\n        }\r\n        const discoveredNodes = new WeakSet();\r\n        function discoverNodes(node) {\r\n            getInlineStyleElements(node).forEach((el) => {\r\n                if (discoveredNodes.has(el)) {\r\n                    return;\r\n                }\r\n                discoveredNodes.add(el);\r\n                elementStyleDidChange(el);\r\n            });\r\n            iterateShadowHosts(node, (n) => {\r\n                if (discoveredNodes.has(node)) {\r\n                    return;\r\n                }\r\n                discoveredNodes.add(node);\r\n                shadowRootDiscovered(n.shadowRoot);\r\n                deepWatchForInlineStyles(\r\n                    n.shadowRoot,\r\n                    elementStyleDidChange,\r\n                    shadowRootDiscovered\r\n                );\r\n            });\r\n            variablesStore.matchVariablesAndDependents();\r\n        }\r\n        const treeObserver = createOptimizedTreeObserver(root, {\r\n            onMinorMutations: (_root, {additions}) => {\r\n                additions.forEach((added) => discoverNodes(added));\r\n            },\r\n            onHugeMutations: () => {\r\n                discoverNodes(root);\r\n            }\r\n        });\r\n        treeObservers.set(root, treeObserver);\r\n        let attemptCount = 0;\r\n        let start = null;\r\n        const ATTEMPTS_INTERVAL = getDuration({seconds: 10});\r\n        const RETRY_TIMEOUT = getDuration({seconds: 2});\r\n        const MAX_ATTEMPTS_COUNT = 50;\r\n        let cache = [];\r\n        let timeoutId = null;\r\n        const handleAttributeMutations = throttle((mutations) => {\r\n            const handledTargets = new Set();\r\n            mutations.forEach((m) => {\r\n                const target = m.target;\r\n                if (handledTargets.has(target)) {\r\n                    return;\r\n                }\r\n                if (INLINE_STYLE_ATTRS.includes(m.attributeName)) {\r\n                    handledTargets.add(target);\r\n                    elementStyleDidChange(target);\r\n                }\r\n            });\r\n            variablesStore.matchVariablesAndDependents();\r\n        });\r\n        const attrObserver = new MutationObserver((mutations) => {\r\n            if (timeoutId) {\r\n                cache.push(...mutations);\r\n                return;\r\n            }\r\n            attemptCount++;\r\n            const now = Date.now();\r\n            if (start == null) {\r\n                start = now;\r\n            } else if (attemptCount >= MAX_ATTEMPTS_COUNT) {\r\n                if (now - start < ATTEMPTS_INTERVAL) {\r\n                    timeoutId = setTimeout(() => {\r\n                        start = null;\r\n                        attemptCount = 0;\r\n                        timeoutId = null;\r\n                        const attributeCache = cache;\r\n                        cache = [];\r\n                        handleAttributeMutations(attributeCache);\r\n                    }, RETRY_TIMEOUT);\r\n                    cache.push(...mutations);\r\n                    return;\r\n                }\r\n                start = now;\r\n                attemptCount = 1;\r\n            }\r\n            handleAttributeMutations(mutations);\r\n        });\r\n        attrObserver.observe(root, {\r\n            attributes: true,\r\n            attributeFilter: INLINE_STYLE_ATTRS.concat(\r\n                overridesList.map(({dataAttr}) => dataAttr)\r\n            ),\r\n            subtree: true\r\n        });\r\n        attrObservers.set(root, attrObserver);\r\n    }\r\n    function stopWatchingForInlineStyles() {\r\n        treeObservers.forEach((o) => o.disconnect());\r\n        attrObservers.forEach((o) => o.disconnect());\r\n        treeObservers.clear();\r\n        attrObservers.clear();\r\n    }\r\n    const inlineStyleCache = new WeakMap();\r\n    const svgInversionCache = new WeakSet();\r\n    const svgAnalysisConditionCache = new WeakMap();\r\n    const themeProps = [\"brightness\", \"contrast\", \"grayscale\", \"sepia\", \"mode\"];\r\n    function shouldAnalyzeSVGAsImage(svg) {\r\n        if (svgAnalysisConditionCache.has(svg)) {\r\n            return svgAnalysisConditionCache.get(svg);\r\n        }\r\n        const shouldAnalyze = Boolean(\r\n            svg &&\r\n                (svg.getAttribute(\"class\")?.includes(\"logo\") ||\r\n                    svg.parentElement?.getAttribute(\"class\")?.includes(\"logo\"))\r\n        );\r\n        svgAnalysisConditionCache.set(svg, shouldAnalyze);\r\n        return shouldAnalyze;\r\n    }\r\n    function getInlineStyleCacheKey(el, theme) {\r\n        return INLINE_STYLE_ATTRS.map(\r\n            (attr) => `${attr}=\"${el.getAttribute(attr)}\"`\r\n        )\r\n            .concat(themeProps.map((prop) => `${prop}=\"${theme[prop]}\"`))\r\n            .join(\" \");\r\n    }\r\n    function shouldIgnoreInlineStyle(element, selectors) {\r\n        for (let i = 0, len = selectors.length; i < len; i++) {\r\n            const ingnoredSelector = selectors[i];\r\n            if (element.matches(ingnoredSelector)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    function overrideInlineStyle(\r\n        element,\r\n        theme,\r\n        ignoreInlineSelectors,\r\n        ignoreImageSelectors\r\n    ) {\r\n        const cacheKey = getInlineStyleCacheKey(element, theme);\r\n        if (cacheKey === inlineStyleCache.get(element)) {\r\n            return;\r\n        }\r\n        const unsetProps = new Set(Object.keys(overrides));\r\n        function setCustomProp(targetCSSProp, modifierCSSProp, cssVal) {\r\n            const mod = getModifiableCSSDeclaration(\r\n                modifierCSSProp,\r\n                cssVal,\r\n                {style: element.style},\r\n                variablesStore,\r\n                ignoreImageSelectors,\r\n                null\r\n            );\r\n            if (!mod) {\r\n                return;\r\n            }\r\n            function setStaticValue(value) {\r\n                const {customProp, dataAttr} =\r\n                    overrides[targetCSSProp] ??\r\n                    shorthandOverrides[targetCSSProp];\r\n                element.style.setProperty(customProp, value);\r\n                if (!element.hasAttribute(dataAttr)) {\r\n                    element.setAttribute(dataAttr, \"\");\r\n                }\r\n                unsetProps.delete(targetCSSProp);\r\n            }\r\n            function setVarDeclaration(mod) {\r\n                let prevDeclarations = [];\r\n                function setProps(declarations) {\r\n                    prevDeclarations.forEach(({property}) => {\r\n                        element.style.removeProperty(property);\r\n                    });\r\n                    declarations.forEach(({property, value}) => {\r\n                        if (!(value instanceof Promise)) {\r\n                            element.style.setProperty(property, value);\r\n                        }\r\n                    });\r\n                    prevDeclarations = declarations;\r\n                }\r\n                setProps(mod.declarations);\r\n                mod.onTypeChange.addListener(setProps);\r\n            }\r\n            function setAsyncValue(promise, sourceValue) {\r\n                promise.then((value) => {\r\n                    if (\r\n                        value &&\r\n                        targetCSSProp === \"background\" &&\r\n                        value.startsWith(\"var(--darkreader-bg--\")\r\n                    ) {\r\n                        setStaticValue(value);\r\n                    }\r\n                    if (value && targetCSSProp === \"background-image\") {\r\n                        if (\r\n                            (element === document.documentElement ||\r\n                                element === document.body) &&\r\n                            value === sourceValue\r\n                        ) {\r\n                            value = \"none\";\r\n                        }\r\n                        setStaticValue(value);\r\n                    }\r\n                    inlineStyleCache.set(\r\n                        element,\r\n                        getInlineStyleCacheKey(element, theme)\r\n                    );\r\n                });\r\n            }\r\n            const value =\r\n                typeof mod.value === \"function\" ? mod.value(theme) : mod.value;\r\n            if (typeof value === \"string\") {\r\n                setStaticValue(value);\r\n            } else if (value instanceof Promise) {\r\n                setAsyncValue(value, cssVal);\r\n            } else if (typeof value === \"object\") {\r\n                setVarDeclaration(value);\r\n            }\r\n        }\r\n        if (ignoreInlineSelectors.length > 0) {\r\n            if (shouldIgnoreInlineStyle(element, ignoreInlineSelectors)) {\r\n                unsetProps.forEach((cssProp) => {\r\n                    element.removeAttribute(overrides[cssProp].dataAttr);\r\n                });\r\n                return;\r\n            }\r\n        }\r\n        const isSVGElement = element instanceof SVGElement;\r\n        const svg = isSVGElement\r\n            ? (element.ownerSVGElement ??\r\n              (element instanceof SVGSVGElement ? element : null))\r\n            : null;\r\n        if (isSVGElement && theme.mode === 1 && svg) {\r\n            if (svgInversionCache.has(svg)) {\r\n                return;\r\n            }\r\n            if (shouldAnalyzeSVGAsImage(svg)) {\r\n                svgInversionCache.add(svg);\r\n                const analyzeSVGAsImage = () => {\r\n                    let svgString = svg.outerHTML;\r\n                    svgString = svgString.replaceAll(\r\n                        '<style class=\"darkreader darkreader--sync\" media=\"screen\"></style>',\r\n                        \"\"\r\n                    );\r\n                    const dataURL = `data:image/svg+xml;base64,${btoa(svgString)}`;\r\n                    getImageDetails(dataURL).then((details) => {\r\n                        if (\r\n                            (details.isDark && details.isTransparent) ||\r\n                            (details.isLarge &&\r\n                                details.isLight &&\r\n                                !details.isTransparent)\r\n                        ) {\r\n                            svg.setAttribute(\r\n                                \"data-darkreader-inline-invert\",\r\n                                \"\"\r\n                            );\r\n                        } else {\r\n                            svg.removeAttribute(\r\n                                \"data-darkreader-inline-invert\"\r\n                            );\r\n                        }\r\n                    });\r\n                };\r\n                analyzeSVGAsImage();\r\n                if (!isDOMReady()) {\r\n                    addDOMReadyListener(analyzeSVGAsImage);\r\n                }\r\n                return;\r\n            }\r\n        }\r\n        if (element.hasAttribute(\"bgcolor\")) {\r\n            let value = element.getAttribute(\"bgcolor\");\r\n            if (\r\n                value.match(/^[0-9a-f]{3}$/i) ||\r\n                value.match(/^[0-9a-f]{6}$/i)\r\n            ) {\r\n                value = `#${value}`;\r\n            }\r\n            setCustomProp(\"background-color\", \"background-color\", value);\r\n        }\r\n        if (\r\n            (element === document.documentElement ||\r\n                element === document.body) &&\r\n            element.hasAttribute(\"background\")\r\n        ) {\r\n            const url = getAbsoluteURL(\r\n                location.href,\r\n                element.getAttribute(\"background\") ?? \"\"\r\n            );\r\n            const value = `url(\"${url}\")`;\r\n            setCustomProp(\"background-image\", \"background-image\", value);\r\n        }\r\n        if (element.hasAttribute(\"color\") && element.rel !== \"mask-icon\") {\r\n            let value = element.getAttribute(\"color\");\r\n            if (\r\n                value.match(/^[0-9a-f]{3}$/i) ||\r\n                value.match(/^[0-9a-f]{6}$/i)\r\n            ) {\r\n                value = `#${value}`;\r\n            }\r\n            setCustomProp(\"color\", \"color\", value);\r\n        }\r\n        if (isSVGElement) {\r\n            if (element.hasAttribute(\"fill\")) {\r\n                const SMALL_SVG_LIMIT = 32;\r\n                const value = element.getAttribute(\"fill\");\r\n                if (value !== \"none\") {\r\n                    if (!(element instanceof SVGTextElement)) {\r\n                        const handleSVGElement = () => {\r\n                            const {width, height} =\r\n                                element.getBoundingClientRect();\r\n                            const isBg =\r\n                                width > SMALL_SVG_LIMIT ||\r\n                                height > SMALL_SVG_LIMIT;\r\n                            setCustomProp(\r\n                                \"fill\",\r\n                                isBg ? \"background-color\" : \"color\",\r\n                                value\r\n                            );\r\n                        };\r\n                        if (isReadyStateComplete()) {\r\n                            handleSVGElement();\r\n                        } else {\r\n                            addReadyStateCompleteListener(handleSVGElement);\r\n                        }\r\n                    } else {\r\n                        setCustomProp(\"fill\", \"color\", value);\r\n                    }\r\n                }\r\n            }\r\n            if (element.hasAttribute(\"stop-color\")) {\r\n                setCustomProp(\r\n                    \"stop-color\",\r\n                    \"background-color\",\r\n                    element.getAttribute(\"stop-color\")\r\n                );\r\n            }\r\n        }\r\n        if (element.hasAttribute(\"stroke\")) {\r\n            const value = element.getAttribute(\"stroke\");\r\n            setCustomProp(\r\n                \"stroke\",\r\n                element instanceof SVGLineElement ||\r\n                    element instanceof SVGTextElement\r\n                    ? \"border-color\"\r\n                    : \"color\",\r\n                value\r\n            );\r\n        }\r\n        element.style &&\r\n            iterateCSSDeclarations(element.style, (property, value) => {\r\n                if (property === \"background-image\" && value.includes(\"url\")) {\r\n                    if (\r\n                        element === document.documentElement ||\r\n                        element === document.body\r\n                    ) {\r\n                        setCustomProp(property, property, value);\r\n                    }\r\n                    return;\r\n                }\r\n                if (\r\n                    overrides.hasOwnProperty(property) ||\r\n                    (property.startsWith(\"--\") && !normalizedPropList[property])\r\n                ) {\r\n                    setCustomProp(property, property, value);\r\n                } else if (\r\n                    property === \"background\" &&\r\n                    value.includes(\"var(\")\r\n                ) {\r\n                    setCustomProp(\"background\", \"background\", value);\r\n                } else {\r\n                    const overriddenProp = normalizedPropList[property];\r\n                    if (\r\n                        overriddenProp &&\r\n                        !element.style.getPropertyValue(overriddenProp) &&\r\n                        !element.hasAttribute(overriddenProp)\r\n                    ) {\r\n                        if (\r\n                            overriddenProp === \"background-color\" &&\r\n                            element.hasAttribute(\"bgcolor\")\r\n                        ) {\r\n                            return;\r\n                        }\r\n                        element.style.setProperty(property, \"\");\r\n                    }\r\n                }\r\n            });\r\n        if (\r\n            element.style &&\r\n            element instanceof SVGTextElement &&\r\n            element.style.fill\r\n        ) {\r\n            setCustomProp(\r\n                \"fill\",\r\n                \"color\",\r\n                element.style.getPropertyValue(\"fill\")\r\n            );\r\n        }\r\n        if (element.getAttribute(\"style\")?.includes(\"--\")) {\r\n            variablesStore.addInlineStyleForMatching(element.style);\r\n        }\r\n        forEach(unsetProps, (cssProp) => {\r\n            element.removeAttribute(overrides[cssProp].dataAttr);\r\n        });\r\n        inlineStyleCache.set(element, getInlineStyleCacheKey(element, theme));\r\n    }\r\n\r\n    const metaThemeColorName = \"theme-color\";\r\n    const metaThemeColorSelector = `meta[name=\"${metaThemeColorName}\"]`;\r\n    let srcMetaThemeColor = null;\r\n    let observer = null;\r\n    function changeMetaThemeColor(meta, theme) {\r\n        srcMetaThemeColor = srcMetaThemeColor || meta.content;\r\n        const color = parseColorWithCache(srcMetaThemeColor);\r\n        if (!color) {\r\n            return;\r\n        }\r\n        meta.content = modifyBackgroundColor(color, theme, false);\r\n    }\r\n    function changeMetaThemeColorWhenAvailable(theme) {\r\n        const meta = document.querySelector(metaThemeColorSelector);\r\n        if (meta) {\r\n            changeMetaThemeColor(meta, theme);\r\n        } else {\r\n            if (observer) {\r\n                observer.disconnect();\r\n            }\r\n            observer = new MutationObserver((mutations) => {\r\n                loop: for (let i = 0; i < mutations.length; i++) {\r\n                    const {addedNodes} = mutations[i];\r\n                    for (let j = 0; j < addedNodes.length; j++) {\r\n                        const node = addedNodes[j];\r\n                        if (\r\n                            node instanceof HTMLMetaElement &&\r\n                            node.name === metaThemeColorName\r\n                        ) {\r\n                            observer.disconnect();\r\n                            observer = null;\r\n                            changeMetaThemeColor(node, theme);\r\n                            break loop;\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n            observer.observe(document.head, {childList: true});\r\n        }\r\n    }\r\n    function restoreMetaThemeColor() {\r\n        if (observer) {\r\n            observer.disconnect();\r\n            observer = null;\r\n        }\r\n        const meta = document.querySelector(metaThemeColorSelector);\r\n        if (meta && srcMetaThemeColor) {\r\n            meta.content = srcMetaThemeColor;\r\n        }\r\n    }\r\n\r\n    const cssCommentsRegex = /\\/\\*[\\s\\S]*?\\*\\//g;\r\n    function removeCSSComments(cssText) {\r\n        return cssText.replace(cssCommentsRegex, \"\");\r\n    }\r\n\r\n    let canUseSheetProxy = false;\r\n    document.addEventListener(\r\n        \"__darkreader__inlineScriptsAllowed\",\r\n        () => (canUseSheetProxy = true),\r\n        {once: true}\r\n    );\r\n    function createSheetWatcher(\r\n        element,\r\n        safeGetSheetRules,\r\n        callback,\r\n        isCancelled\r\n    ) {\r\n        let rafSheetWatcher = null;\r\n        function watchForSheetChanges() {\r\n            watchForSheetChangesUsingProxy();\r\n            if (!(canUseSheetProxy && element.sheet)) {\r\n                rafSheetWatcher = createRAFSheetWatcher(\r\n                    element,\r\n                    safeGetSheetRules,\r\n                    callback,\r\n                    isCancelled\r\n                );\r\n                rafSheetWatcher.start();\r\n            }\r\n        }\r\n        let areSheetChangesPending = false;\r\n        function onSheetChange() {\r\n            canUseSheetProxy = true;\r\n            rafSheetWatcher?.stop();\r\n            if (areSheetChangesPending) {\r\n                return;\r\n            }\r\n            function handleSheetChanges() {\r\n                areSheetChangesPending = false;\r\n                if (isCancelled()) {\r\n                    return;\r\n                }\r\n                callback();\r\n            }\r\n            areSheetChangesPending = true;\r\n            queueMicrotask(handleSheetChanges);\r\n        }\r\n        function watchForSheetChangesUsingProxy() {\r\n            element.addEventListener(\r\n                \"__darkreader__updateSheet\",\r\n                onSheetChange\r\n            );\r\n        }\r\n        function stopWatchingForSheetChangesUsingProxy() {\r\n            element.removeEventListener(\r\n                \"__darkreader__updateSheet\",\r\n                onSheetChange\r\n            );\r\n        }\r\n        function stopWatchingForSheetChanges() {\r\n            stopWatchingForSheetChangesUsingProxy();\r\n            rafSheetWatcher?.stop();\r\n        }\r\n        return {\r\n            start: watchForSheetChanges,\r\n            stop: stopWatchingForSheetChanges\r\n        };\r\n    }\r\n    function createRAFSheetWatcher(\r\n        element,\r\n        safeGetSheetRules,\r\n        callback,\r\n        isCancelled\r\n    ) {\r\n        let rulesChangeKey = null;\r\n        let rulesCheckFrameId = null;\r\n        function getRulesChangeKey() {\r\n            const rules = safeGetSheetRules();\r\n            return rules ? rules.length : null;\r\n        }\r\n        function didRulesKeyChange() {\r\n            return getRulesChangeKey() !== rulesChangeKey;\r\n        }\r\n        function watchForSheetChangesUsingRAF() {\r\n            rulesChangeKey = getRulesChangeKey();\r\n            stopWatchingForSheetChangesUsingRAF();\r\n            const checkForUpdate = () => {\r\n                const cancelled = isCancelled();\r\n                if (!cancelled && didRulesKeyChange()) {\r\n                    rulesChangeKey = getRulesChangeKey();\r\n                    callback();\r\n                }\r\n                if (cancelled || (canUseSheetProxy && element.sheet)) {\r\n                    stopWatchingForSheetChangesUsingRAF();\r\n                    return;\r\n                }\r\n                rulesCheckFrameId = requestAnimationFrame(checkForUpdate);\r\n            };\r\n            checkForUpdate();\r\n        }\r\n        function stopWatchingForSheetChangesUsingRAF() {\r\n            rulesCheckFrameId && cancelAnimationFrame(rulesCheckFrameId);\r\n        }\r\n        return {\r\n            start: watchForSheetChangesUsingRAF,\r\n            stop: stopWatchingForSheetChangesUsingRAF\r\n        };\r\n    }\r\n\r\n    const STYLE_SELECTOR = 'style, link[rel*=\"stylesheet\" i]:not([disabled])';\r\n    function isFontsGoogleApiStyle(element) {\r\n        if (!element.href) {\r\n            return false;\r\n        }\r\n        try {\r\n            const elementURL = new URL(element.href);\r\n            return elementURL.hostname === \"fonts.googleapis.com\";\r\n        } catch (err) {\r\n            logInfo(`Couldn't construct ${element.href} as URL`);\r\n            return false;\r\n        }\r\n    }\r\n    const hostsBreakingOnSVGStyleOverride = [\r\n        \"account.containerstore.com\",\r\n        \"containerstore.com\",\r\n        \"www.onet.pl\"\r\n    ];\r\n    function shouldManageStyle(element) {\r\n        return (\r\n            (element instanceof HTMLStyleElement ||\r\n                (element instanceof SVGStyleElement &&\r\n                    !hostsBreakingOnSVGStyleOverride.includes(\r\n                        location.hostname\r\n                    )) ||\r\n                (element instanceof HTMLLinkElement &&\r\n                    Boolean(element.rel) &&\r\n                    element.rel.toLowerCase().includes(\"stylesheet\") &&\r\n                    Boolean(element.href) &&\r\n                    !element.disabled &&\r\n                    (isFirefox\r\n                        ? !element.href.startsWith(\"moz-extension://\")\r\n                        : true) &&\r\n                    !isFontsGoogleApiStyle(element))) &&\r\n            !element.classList.contains(\"darkreader\") &&\r\n            element.media.toLowerCase() !== \"print\" &&\r\n            !element.classList.contains(\"stylus\")\r\n        );\r\n    }\r\n    function getManageableStyles(node, results = [], deep = true) {\r\n        if (shouldManageStyle(node)) {\r\n            results.push(node);\r\n        } else if (\r\n            node instanceof Element ||\r\n            (isShadowDomSupported && node instanceof ShadowRoot) ||\r\n            node === document\r\n        ) {\r\n            forEach(node.querySelectorAll(STYLE_SELECTOR), (style) =>\r\n                getManageableStyles(style, results, false)\r\n            );\r\n            if (deep) {\r\n                iterateShadowHosts(node, (host) =>\r\n                    getManageableStyles(host.shadowRoot, results, false)\r\n                );\r\n            }\r\n        }\r\n        return results;\r\n    }\r\n    const syncStyleSet = new WeakSet();\r\n    const corsStyleSet = new WeakSet();\r\n    let loadingLinkCounter = 0;\r\n    const rejectorsForLoadingLinks = new Map();\r\n    function cleanLoadingLinks() {\r\n        rejectorsForLoadingLinks.clear();\r\n    }\r\n    function manageStyle(element, {update, loadingStart, loadingEnd}) {\r\n        const prevStyles = [];\r\n        let next = element;\r\n        while (\r\n            (next = next.nextElementSibling) &&\r\n            next.matches(\".darkreader\")\r\n        ) {\r\n            prevStyles.push(next);\r\n        }\r\n        let corsCopy =\r\n            prevStyles.find(\r\n                (el) => el.matches(\".darkreader--cors\") && !corsStyleSet.has(el)\r\n            ) || null;\r\n        let syncStyle =\r\n            prevStyles.find(\r\n                (el) => el.matches(\".darkreader--sync\") && !syncStyleSet.has(el)\r\n            ) || null;\r\n        let corsCopyPositionWatcher = null;\r\n        let syncStylePositionWatcher = null;\r\n        let cancelAsyncOperations = false;\r\n        let isOverrideEmpty = true;\r\n        const isAsyncCancelled = () => cancelAsyncOperations;\r\n        const sheetModifier = createStyleSheetModifier();\r\n        const observer = new MutationObserver((mutations) => {\r\n            if (\r\n                mutations.some((m) => m.type === \"characterData\") &&\r\n                containsCSSImport()\r\n            ) {\r\n                const cssText = (element.textContent ?? \"\").trim();\r\n                createOrUpdateCORSCopy(cssText, location.href).then(update);\r\n            } else {\r\n                update();\r\n            }\r\n        });\r\n        const observerOptions = {\r\n            attributes: true,\r\n            childList: true,\r\n            subtree: true,\r\n            characterData: true\r\n        };\r\n        function containsCSSImport() {\r\n            if (!(element instanceof HTMLStyleElement)) {\r\n                return false;\r\n            }\r\n            const cssText = removeCSSComments(element.textContent ?? \"\").trim();\r\n            return cssText.match(cssImportRegex);\r\n        }\r\n        function hasImports(cssRules, checkCrossOrigin) {\r\n            let result = false;\r\n            if (cssRules) {\r\n                let rule;\r\n                cssRulesLoop: for (\r\n                    let i = 0, len = cssRules.length;\r\n                    i < len;\r\n                    i++\r\n                ) {\r\n                    rule = cssRules[i];\r\n                    if (rule.href) {\r\n                        if (checkCrossOrigin) {\r\n                            if (\r\n                                !rule.href.startsWith(\r\n                                    \"https://fonts.googleapis.com/\"\r\n                                ) &&\r\n                                rule.href.startsWith(\"http\") &&\r\n                                !rule.href.startsWith(location.origin)\r\n                            ) {\r\n                                result = true;\r\n                                break cssRulesLoop;\r\n                            }\r\n                        } else {\r\n                            result = true;\r\n                            break cssRulesLoop;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return result;\r\n        }\r\n        function getRulesSync() {\r\n            if (corsCopy) {\r\n                return corsCopy.sheet.cssRules;\r\n            }\r\n            if (containsCSSImport()) {\r\n                return null;\r\n            }\r\n            const cssRules = safeGetSheetRules();\r\n            if (\r\n                element instanceof HTMLLinkElement &&\r\n                !isRelativeHrefOnAbsolutePath(element.href) &&\r\n                hasImports(cssRules, false)\r\n            ) {\r\n                return null;\r\n            }\r\n            if (hasImports(cssRules, true)) {\r\n                return null;\r\n            }\r\n            return cssRules;\r\n        }\r\n        function insertStyle() {\r\n            if (corsCopy) {\r\n                if (element.nextSibling !== corsCopy) {\r\n                    element.parentNode.insertBefore(\r\n                        corsCopy,\r\n                        element.nextSibling\r\n                    );\r\n                }\r\n                if (corsCopy.nextSibling !== syncStyle) {\r\n                    element.parentNode.insertBefore(\r\n                        syncStyle,\r\n                        corsCopy.nextSibling\r\n                    );\r\n                }\r\n            } else if (element.nextSibling !== syncStyle) {\r\n                element.parentNode.insertBefore(syncStyle, element.nextSibling);\r\n            }\r\n        }\r\n        function createSyncStyle() {\r\n            syncStyle =\r\n                element instanceof SVGStyleElement\r\n                    ? document.createElementNS(\r\n                          \"http://www.w3.org/2000/svg\",\r\n                          \"style\"\r\n                      )\r\n                    : document.createElement(\"style\");\r\n            syncStyle.classList.add(\"darkreader\");\r\n            syncStyle.classList.add(\"darkreader--sync\");\r\n            syncStyle.media = \"screen\";\r\n            if (element.title) {\r\n                syncStyle.title = element.title;\r\n            }\r\n            syncStyleSet.add(syncStyle);\r\n        }\r\n        let isLoadingRules = false;\r\n        let wasLoadingError = false;\r\n        const loadingLinkId = ++loadingLinkCounter;\r\n        async function getRulesAsync() {\r\n            let cssText;\r\n            let cssBasePath;\r\n            if (element instanceof HTMLLinkElement) {\r\n                let [cssRules, accessError] = getRulesOrError();\r\n                if (\r\n                    (isSafari && !element.sheet) ||\r\n                    (!isSafari && !cssRules && !accessError) ||\r\n                    isStillLoadingError(accessError)\r\n                ) {\r\n                    try {\r\n                        logInfo(\r\n                            `Linkelement ${loadingLinkId} is not loaded yet and thus will be await for`,\r\n                            element\r\n                        );\r\n                        await linkLoading(element, loadingLinkId);\r\n                    } catch (err) {\r\n                        wasLoadingError = true;\r\n                    }\r\n                    if (cancelAsyncOperations) {\r\n                        return null;\r\n                    }\r\n                    [cssRules, accessError] = getRulesOrError();\r\n                }\r\n                if (cssRules) {\r\n                    if (!hasImports(cssRules, false)) {\r\n                        return cssRules;\r\n                    }\r\n                }\r\n                cssText = await loadText(element.href);\r\n                cssBasePath = getCSSBaseBath(element.href);\r\n                if (cancelAsyncOperations) {\r\n                    return null;\r\n                }\r\n            } else if (containsCSSImport()) {\r\n                cssText = element.textContent.trim();\r\n                cssBasePath = getCSSBaseBath(location.href);\r\n            } else {\r\n                return null;\r\n            }\r\n            await createOrUpdateCORSCopy(cssText, cssBasePath);\r\n            if (corsCopy) {\r\n                return corsCopy.sheet.cssRules;\r\n            }\r\n            return null;\r\n        }\r\n        async function createOrUpdateCORSCopy(cssText, cssBasePath) {\r\n            if (cssText) {\r\n                try {\r\n                    const fullCSSText = await replaceCSSImports(\r\n                        cssText,\r\n                        cssBasePath\r\n                    );\r\n                    if (corsCopy) {\r\n                        if (\r\n                            (corsCopy.textContent?.length ?? 0) <\r\n                            fullCSSText.length\r\n                        ) {\r\n                            corsCopy.textContent = fullCSSText;\r\n                        }\r\n                    } else {\r\n                        corsCopy = createCORSCopy(element, fullCSSText);\r\n                    }\r\n                } catch (err) {}\r\n                if (corsCopy) {\r\n                    corsCopyPositionWatcher = watchForNodePosition(\r\n                        corsCopy,\r\n                        \"prev-sibling\"\r\n                    );\r\n                }\r\n            }\r\n        }\r\n        function details(options) {\r\n            const rules = getRulesSync();\r\n            if (!rules) {\r\n                if (options.secondRound) {\r\n                    return null;\r\n                }\r\n                if (isLoadingRules || wasLoadingError) {\r\n                    return null;\r\n                }\r\n                isLoadingRules = true;\r\n                loadingStart();\r\n                getRulesAsync()\r\n                    .then((results) => {\r\n                        isLoadingRules = false;\r\n                        loadingEnd();\r\n                        if (results) {\r\n                            update();\r\n                        }\r\n                    })\r\n                    .catch((err) => {\r\n                        isLoadingRules = false;\r\n                        loadingEnd();\r\n                    });\r\n                return null;\r\n            }\r\n            return {rules};\r\n        }\r\n        let forceRenderStyle = false;\r\n        function render(theme, ignoreImageAnalysis) {\r\n            const rules = getRulesSync();\r\n            if (!rules) {\r\n                return;\r\n            }\r\n            cancelAsyncOperations = false;\r\n            function removeCSSRulesFromSheet(sheet) {\r\n                if (!sheet) {\r\n                    return;\r\n                }\r\n                for (let i = sheet.cssRules.length - 1; i >= 0; i--) {\r\n                    sheet.deleteRule(i);\r\n                }\r\n            }\r\n            function prepareOverridesSheet() {\r\n                if (!syncStyle) {\r\n                    createSyncStyle();\r\n                }\r\n                syncStylePositionWatcher && syncStylePositionWatcher.stop();\r\n                insertStyle();\r\n                if (syncStyle.sheet == null) {\r\n                    syncStyle.textContent = \"\";\r\n                }\r\n                const sheet = syncStyle.sheet;\r\n                removeCSSRulesFromSheet(sheet);\r\n                if (syncStylePositionWatcher) {\r\n                    syncStylePositionWatcher.run();\r\n                } else {\r\n                    syncStylePositionWatcher = watchForNodePosition(\r\n                        syncStyle,\r\n                        \"prev-sibling\",\r\n                        () => {\r\n                            forceRenderStyle = true;\r\n                            buildOverrides();\r\n                        }\r\n                    );\r\n                }\r\n                return syncStyle.sheet;\r\n            }\r\n            function buildOverrides() {\r\n                const force = forceRenderStyle;\r\n                forceRenderStyle = false;\r\n                sheetModifier.modifySheet({\r\n                    prepareSheet: prepareOverridesSheet,\r\n                    sourceCSSRules: rules,\r\n                    theme,\r\n                    ignoreImageAnalysis,\r\n                    force,\r\n                    isAsyncCancelled\r\n                });\r\n                isOverrideEmpty = syncStyle.sheet.cssRules.length === 0;\r\n                if (sheetModifier.shouldRebuildStyle()) {\r\n                    addReadyStateCompleteListener(() => update());\r\n                }\r\n            }\r\n            buildOverrides();\r\n        }\r\n        function getRulesOrError() {\r\n            try {\r\n                if (element.sheet == null) {\r\n                    return [null, null];\r\n                }\r\n                return [element.sheet.cssRules, null];\r\n            } catch (err) {\r\n                return [null, err];\r\n            }\r\n        }\r\n        function isStillLoadingError(error) {\r\n            return error && error.message && error.message.includes(\"loading\");\r\n        }\r\n        function safeGetSheetRules() {\r\n            const [cssRules, err] = getRulesOrError();\r\n            if (err) {\r\n                return null;\r\n            }\r\n            return cssRules;\r\n        }\r\n        const sheetChangeWatcher = createSheetWatcher(\r\n            element,\r\n            safeGetSheetRules,\r\n            update,\r\n            isAsyncCancelled\r\n        );\r\n        function pause() {\r\n            observer.disconnect();\r\n            cancelAsyncOperations = true;\r\n            corsCopyPositionWatcher && corsCopyPositionWatcher.stop();\r\n            syncStylePositionWatcher && syncStylePositionWatcher.stop();\r\n            sheetChangeWatcher.stop();\r\n        }\r\n        function destroy() {\r\n            pause();\r\n            removeNode(corsCopy);\r\n            removeNode(syncStyle);\r\n            loadingEnd();\r\n            if (rejectorsForLoadingLinks.has(loadingLinkId)) {\r\n                const reject = rejectorsForLoadingLinks.get(loadingLinkId);\r\n                rejectorsForLoadingLinks.delete(loadingLinkId);\r\n                reject && reject();\r\n            }\r\n        }\r\n        function watch() {\r\n            observer.observe(element, observerOptions);\r\n            if (element instanceof HTMLStyleElement) {\r\n                sheetChangeWatcher.start();\r\n            }\r\n        }\r\n        const maxMoveCount = 10;\r\n        let moveCount = 0;\r\n        function restore() {\r\n            if (!syncStyle) {\r\n                return;\r\n            }\r\n            moveCount++;\r\n            if (moveCount > maxMoveCount) {\r\n                return;\r\n            }\r\n            insertStyle();\r\n            corsCopyPositionWatcher && corsCopyPositionWatcher.skip();\r\n            syncStylePositionWatcher && syncStylePositionWatcher.skip();\r\n            if (!isOverrideEmpty) {\r\n                forceRenderStyle = true;\r\n                update();\r\n            }\r\n        }\r\n        return {\r\n            details,\r\n            render,\r\n            pause,\r\n            destroy,\r\n            watch,\r\n            restore\r\n        };\r\n    }\r\n    async function linkLoading(link, loadingId) {\r\n        return new Promise((resolve, reject) => {\r\n            const cleanUp = () => {\r\n                link.removeEventListener(\"load\", onLoad);\r\n                link.removeEventListener(\"error\", onError);\r\n                rejectorsForLoadingLinks.delete(loadingId);\r\n            };\r\n            const onLoad = () => {\r\n                cleanUp();\r\n                resolve();\r\n            };\r\n            const onError = () => {\r\n                cleanUp();\r\n                reject(\r\n                    `Linkelement ${loadingId} couldn't be loaded. ${link.href}`\r\n                );\r\n            };\r\n            rejectorsForLoadingLinks.set(loadingId, () => {\r\n                cleanUp();\r\n                reject();\r\n            });\r\n            link.addEventListener(\"load\", onLoad, {passive: true});\r\n            link.addEventListener(\"error\", onError, {passive: true});\r\n            if (!link.href) {\r\n                onError();\r\n            }\r\n        });\r\n    }\r\n    function getCSSImportURL(importDeclaration) {\r\n        return getCSSURLValue(\r\n            importDeclaration\r\n                .substring(7)\r\n                .trim()\r\n                .replace(/;$/, \"\")\r\n                .replace(/screen$/, \"\")\r\n        );\r\n    }\r\n    async function loadText(url) {\r\n        if (url.startsWith(\"data:\")) {\r\n            return await (await fetch(url)).text();\r\n        }\r\n        const cache = readCSSFetchCache(url);\r\n        if (cache) {\r\n            return cache;\r\n        }\r\n        const parsedURL = new URL(url);\r\n        let text;\r\n        if (parsedURL.origin === location.origin) {\r\n            text = await loadAsText(url, \"text/css\", location.origin);\r\n        }\r\n        text = await bgFetch({\r\n            url,\r\n            responseType: \"text\",\r\n            mimeType: \"text/css\",\r\n            origin: location.origin\r\n        });\r\n        writeCSSFetchCache(url, text);\r\n        return text;\r\n    }\r\n    async function replaceCSSImports(cssText, basePath, cache = new Map()) {\r\n        cssText = removeCSSComments(cssText);\r\n        cssText = replaceCSSFontFace(cssText);\r\n        cssText = replaceCSSRelativeURLsWithAbsolute(cssText, basePath);\r\n        const importMatches = getMatchesWithOffsets(cssImportRegex, cssText);\r\n        let prev = null;\r\n        let shouldIgnoreImportsInBetween = false;\r\n        let diff = 0;\r\n        for (const match of importMatches) {\r\n            let importedCSS;\r\n            const prevImportEnd = prev ? prev.offset + prev.text.length : 0;\r\n            const nextImportStart = match.offset;\r\n            const openBraceIndex = cssText.indexOf(\"{\", prevImportEnd);\r\n            const closeBraceIndex = cssText.indexOf(\"}\", prevImportEnd);\r\n            if (\r\n                shouldIgnoreImportsInBetween ||\r\n                (openBraceIndex >= 0 &&\r\n                    openBraceIndex < nextImportStart &&\r\n                    closeBraceIndex >= 0 &&\r\n                    closeBraceIndex < nextImportStart)\r\n            ) {\r\n                shouldIgnoreImportsInBetween = true;\r\n                importedCSS = \"\";\r\n            } else {\r\n                const importURL = getCSSImportURL(match.text);\r\n                const absoluteURL = getAbsoluteURL(basePath, importURL);\r\n                if (cache.has(absoluteURL)) {\r\n                    importedCSS = cache.get(absoluteURL);\r\n                } else {\r\n                    try {\r\n                        importedCSS = await loadText(absoluteURL);\r\n                        cache.set(absoluteURL, importedCSS);\r\n                        importedCSS = await replaceCSSImports(\r\n                            importedCSS,\r\n                            getCSSBaseBath(absoluteURL),\r\n                            cache\r\n                        );\r\n                    } catch (err) {\r\n                        importedCSS = \"\";\r\n                    }\r\n                }\r\n            }\r\n            cssText =\r\n                cssText.substring(0, match.offset + diff) +\r\n                importedCSS +\r\n                cssText.substring(match.offset + match.text.length + diff);\r\n            diff += importedCSS.length - match.text.length;\r\n            prev = match;\r\n        }\r\n        cssText = cssText.trim();\r\n        return cssText;\r\n    }\r\n    function createCORSCopy(srcElement, cssText) {\r\n        if (!cssText) {\r\n            return null;\r\n        }\r\n        const cors = document.createElement(\"style\");\r\n        cors.classList.add(\"darkreader\");\r\n        cors.classList.add(\"darkreader--cors\");\r\n        cors.media = \"screen\";\r\n        cors.textContent = cssText;\r\n        srcElement.parentNode.insertBefore(cors, srcElement.nextSibling);\r\n        cors.sheet.disabled = true;\r\n        corsStyleSet.add(cors);\r\n        return cors;\r\n    }\r\n\r\n    function injectProxy(\r\n        enableStyleSheetsProxy,\r\n        enableCustomElementRegistryProxy\r\n    ) {\r\n        document.dispatchEvent(\r\n            new CustomEvent(\"__darkreader__inlineScriptsAllowed\")\r\n        );\r\n        const cleaners = [];\r\n        function cleanUp() {\r\n            cleaners.forEach((clean) => clean());\r\n            cleaners.splice(0);\r\n        }\r\n        function documentEventListener(type, listener, options) {\r\n            document.addEventListener(type, listener, options);\r\n            cleaners.push(() => document.removeEventListener(type, listener));\r\n        }\r\n        function disableConflictingPlugins() {\r\n            const disableWPDarkMode = () => {\r\n                if (window?.WPDarkMode?.deactivate) {\r\n                    window.WPDarkMode.deactivate();\r\n                }\r\n            };\r\n            disableWPDarkMode();\r\n        }\r\n        documentEventListener(\"__darkreader__cleanUp\", cleanUp);\r\n        documentEventListener(\r\n            \"__darkreader__disableConflictingPlugins\",\r\n            disableConflictingPlugins\r\n        );\r\n        function overrideProperty(cls, prop, overrides) {\r\n            const proto = cls.prototype;\r\n            const oldDescriptor = Object.getOwnPropertyDescriptor(proto, prop);\r\n            if (!oldDescriptor) {\r\n                return;\r\n            }\r\n            const newDescriptor = {...oldDescriptor};\r\n            Object.keys(overrides).forEach((key) => {\r\n                const factory = overrides[key];\r\n                newDescriptor[key] = factory(oldDescriptor[key]);\r\n            });\r\n            Object.defineProperty(proto, prop, newDescriptor);\r\n            cleaners.push(() =>\r\n                Object.defineProperty(proto, prop, oldDescriptor)\r\n            );\r\n        }\r\n        function override(cls, prop, factory) {\r\n            overrideProperty(cls, prop, {value: factory});\r\n        }\r\n        function isDRElement(element) {\r\n            return element?.classList?.contains(\"darkreader\");\r\n        }\r\n        function isDRSheet(sheet) {\r\n            return isDRElement(sheet.ownerNode);\r\n        }\r\n        const updateSheetEvent = new CustomEvent(\"__darkreader__updateSheet\");\r\n        const adoptedSheetChangeEvent = new CustomEvent(\r\n            \"__darkreader__adoptedStyleSheetChange\"\r\n        );\r\n        const shadowDomAttachingEvent = new CustomEvent(\r\n            \"__darkreader__shadowDomAttaching\",\r\n            {bubbles: true}\r\n        );\r\n        const adoptedSheetOwners = new WeakMap();\r\n        const adoptedDeclarationSheets = new WeakMap();\r\n        function onAdoptedSheetChange(sheet) {\r\n            const owners = adoptedSheetOwners.get(sheet);\r\n            owners?.forEach((node) => {\r\n                if (node.isConnected) {\r\n                    node.dispatchEvent(adoptedSheetChangeEvent);\r\n                } else {\r\n                    owners.delete(node);\r\n                }\r\n            });\r\n        }\r\n        function reportSheetChange(sheet) {\r\n            if (sheet.ownerNode && !isDRSheet(sheet)) {\r\n                sheet.ownerNode.dispatchEvent(updateSheetEvent);\r\n            }\r\n            if (adoptedSheetOwners.has(sheet)) {\r\n                onAdoptedSheetChange(sheet);\r\n            }\r\n        }\r\n        function reportSheetChangeAsync(sheet, promise) {\r\n            const {ownerNode} = sheet;\r\n            if (\r\n                ownerNode &&\r\n                !isDRSheet(sheet) &&\r\n                promise &&\r\n                promise instanceof Promise\r\n            ) {\r\n                promise.then(() => ownerNode.dispatchEvent(updateSheetEvent));\r\n            }\r\n            if (adoptedSheetOwners.has(sheet)) {\r\n                if (promise && promise instanceof Promise) {\r\n                    promise.then(() => onAdoptedSheetChange(sheet));\r\n                }\r\n            }\r\n        }\r\n        override(\r\n            CSSStyleSheet,\r\n            \"addRule\",\r\n            (native) =>\r\n                function (selector, style, index) {\r\n                    native.call(this, selector, style, index);\r\n                    reportSheetChange(this);\r\n                    return -1;\r\n                }\r\n        );\r\n        override(\r\n            CSSStyleSheet,\r\n            \"insertRule\",\r\n            (native) =>\r\n                function (rule, index) {\r\n                    const returnValue = native.call(this, rule, index);\r\n                    reportSheetChange(this);\r\n                    return returnValue;\r\n                }\r\n        );\r\n        override(\r\n            CSSStyleSheet,\r\n            \"deleteRule\",\r\n            (native) =>\r\n                function (index) {\r\n                    native.call(this, index);\r\n                    reportSheetChange(this);\r\n                }\r\n        );\r\n        override(\r\n            CSSStyleSheet,\r\n            \"removeRule\",\r\n            (native) =>\r\n                function (index) {\r\n                    native.call(this, index);\r\n                    reportSheetChange(this);\r\n                }\r\n        );\r\n        override(\r\n            CSSStyleSheet,\r\n            \"replace\",\r\n            (native) =>\r\n                function (cssText) {\r\n                    const returnValue = native.call(this, cssText);\r\n                    reportSheetChangeAsync(this, returnValue);\r\n                    return returnValue;\r\n                }\r\n        );\r\n        override(\r\n            CSSStyleSheet,\r\n            \"replaceSync\",\r\n            (native) =>\r\n                function (cssText) {\r\n                    native.call(this, cssText);\r\n                    reportSheetChange(this);\r\n                }\r\n        );\r\n        override(\r\n            Element,\r\n            \"attachShadow\",\r\n            (native) =>\r\n                function (options) {\r\n                    this.dispatchEvent(shadowDomAttachingEvent);\r\n                    return native.call(this, options);\r\n                }\r\n        );\r\n        const shouldWrapHTMLElement =\r\n            location.hostname === \"baidu.com\" ||\r\n            location.hostname.endsWith(\".baidu.com\");\r\n        if (shouldWrapHTMLElement) {\r\n            override(\r\n                Element,\r\n                \"getElementsByTagName\",\r\n                (native) =>\r\n                    function (tagName) {\r\n                        if (tagName !== \"style\") {\r\n                            return native.call(this, tagName);\r\n                        }\r\n                        const getCurrentElementValue = () => {\r\n                            const elements = native.call(this, tagName);\r\n                            return Object.setPrototypeOf(\r\n                                [...elements].filter(\r\n                                    (element) =>\r\n                                        element && !isDRElement(element)\r\n                                ),\r\n                                NodeList.prototype\r\n                            );\r\n                        };\r\n                        let elements = getCurrentElementValue();\r\n                        const nodeListBehavior = {\r\n                            get: function (_, property) {\r\n                                return getCurrentElementValue()[\r\n                                    Number(property) || property\r\n                                ];\r\n                            }\r\n                        };\r\n                        elements = new Proxy(elements, nodeListBehavior);\r\n                        return elements;\r\n                    }\r\n            );\r\n        }\r\n        const shouldProxyChildNodes = [\"brilliant.org\", \"www.vy.no\"].includes(\r\n            location.hostname\r\n        );\r\n        if (shouldProxyChildNodes) {\r\n            overrideProperty(Node, \"childNodes\", {\r\n                get: (native) =>\r\n                    function () {\r\n                        const childNodes = native.call(this);\r\n                        return Object.setPrototypeOf(\r\n                            [...childNodes].filter((element) => {\r\n                                return !isDRElement(element);\r\n                            }),\r\n                            NodeList.prototype\r\n                        );\r\n                    }\r\n            });\r\n        }\r\n        function resolveCustomElement(tag) {\r\n            customElements.whenDefined(tag).then(() => {\r\n                document.dispatchEvent(\r\n                    new CustomEvent(\"__darkreader__isDefined\", {detail: {tag}})\r\n                );\r\n            });\r\n        }\r\n        documentEventListener(\"__darkreader__addUndefinedResolver\", (e) =>\r\n            resolveCustomElement(e.detail.tag)\r\n        );\r\n        if (enableCustomElementRegistryProxy) {\r\n            override(\r\n                CustomElementRegistry,\r\n                \"define\",\r\n                (native) =>\r\n                    function (name, constructor, options) {\r\n                        resolveCustomElement(name);\r\n                        native.call(this, name, constructor, options);\r\n                    }\r\n            );\r\n        }\r\n        let blobURLAllowed = null;\r\n        async function checkBlobURLSupport() {\r\n            if (blobURLAllowed != null) {\r\n                document.dispatchEvent(\r\n                    new CustomEvent(\"__darkreader__blobURLCheckResponse\", {\r\n                        detail: {blobURLAllowed}\r\n                    })\r\n                );\r\n                return;\r\n            }\r\n            const svg =\r\n                '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"1\" height=\"1\"><rect width=\"1\" height=\"1\" fill=\"transparent\"/></svg>';\r\n            const bytes = new Uint8Array(svg.length);\r\n            for (let i = 0; i < svg.length; i++) {\r\n                bytes[i] = svg.charCodeAt(i);\r\n            }\r\n            const blob = new Blob([bytes], {type: \"image/svg+xml\"});\r\n            const objectURL = URL.createObjectURL(blob);\r\n            try {\r\n                const image = new Image();\r\n                await new Promise((resolve, reject) => {\r\n                    image.onload = () => resolve();\r\n                    image.onerror = () => reject();\r\n                    image.src = objectURL;\r\n                });\r\n                blobURLAllowed = true;\r\n            } catch (err) {\r\n                blobURLAllowed = false;\r\n            }\r\n            document.dispatchEvent(\r\n                new CustomEvent(\"__darkreader__blobURLCheckResponse\", {\r\n                    detail: {blobURLAllowed}\r\n                })\r\n            );\r\n        }\r\n        documentEventListener(\r\n            \"__darkreader__blobURLCheckRequest\",\r\n            checkBlobURLSupport\r\n        );\r\n        if (enableStyleSheetsProxy) {\r\n            overrideProperty(Document, \"styleSheets\", {\r\n                get: (native) =>\r\n                    function () {\r\n                        const getCurrentValue = () => {\r\n                            const docSheets = native.call(this);\r\n                            const filteredSheets = [...docSheets].filter(\r\n                                (styleSheet) =>\r\n                                    styleSheet.ownerNode &&\r\n                                    !isDRSheet(styleSheet)\r\n                            );\r\n                            filteredSheets.item = (item) =>\r\n                                filteredSheets[item];\r\n                            return Object.setPrototypeOf(\r\n                                filteredSheets,\r\n                                StyleSheetList.prototype\r\n                            );\r\n                        };\r\n                        let elements = getCurrentValue();\r\n                        const styleSheetListBehavior = {\r\n                            get: function (_, property) {\r\n                                return getCurrentValue()[property];\r\n                            }\r\n                        };\r\n                        elements = new Proxy(elements, styleSheetListBehavior);\r\n                        return elements;\r\n                    }\r\n            });\r\n        }\r\n        {\r\n            const adoptedSheetsSourceProxies = new WeakMap();\r\n            const adoptedSheetsProxySources = new WeakMap();\r\n            const adoptedSheetsChangeEvent = new CustomEvent(\r\n                \"__darkreader__adoptedStyleSheetsChange\"\r\n            );\r\n            const adoptedSheetOverrideCache = new WeakSet();\r\n            const adoptedSheetsSnapshots = new WeakMap();\r\n            const isDRAdoptedSheetOverride = (sheet) => {\r\n                if (!sheet || !sheet.cssRules) {\r\n                    return false;\r\n                }\r\n                if (adoptedSheetOverrideCache.has(sheet)) {\r\n                    return true;\r\n                }\r\n                if (\r\n                    sheet.cssRules.length > 0 &&\r\n                    sheet.cssRules[0].cssText.startsWith(\r\n                        \"#__darkreader__adoptedOverride\"\r\n                    )\r\n                ) {\r\n                    adoptedSheetOverrideCache.add(sheet);\r\n                    return true;\r\n                }\r\n                return false;\r\n            };\r\n            const areArraysEqual = (a, b) => {\r\n                return a.length === b.length && a.every((x, i) => x === b[i]);\r\n            };\r\n            const onAdoptedSheetsChange = (node) => {\r\n                const prev = adoptedSheetsSnapshots.get(node);\r\n                const curr = (node.adoptedStyleSheets || []).filter(\r\n                    (s) => !isDRAdoptedSheetOverride(s)\r\n                );\r\n                adoptedSheetsSnapshots.set(node, curr);\r\n                if (!prev || !areArraysEqual(prev, curr)) {\r\n                    curr.forEach((sheet) => {\r\n                        if (!adoptedSheetOwners.has(sheet)) {\r\n                            adoptedSheetOwners.set(sheet, new Set());\r\n                        }\r\n                        adoptedSheetOwners.get(sheet).add(node);\r\n                        for (const rule of sheet.cssRules) {\r\n                            const declaration = rule.style;\r\n                            if (declaration) {\r\n                                adoptedDeclarationSheets.set(\r\n                                    declaration,\r\n                                    sheet\r\n                                );\r\n                            }\r\n                        }\r\n                    });\r\n                    node.dispatchEvent(adoptedSheetsChangeEvent);\r\n                }\r\n            };\r\n            const proxyAdoptedSheetsArray = (node, source) => {\r\n                if (adoptedSheetsProxySources.has(source)) {\r\n                    return source;\r\n                }\r\n                if (adoptedSheetsSourceProxies.has(source)) {\r\n                    return adoptedSheetsSourceProxies.get(source);\r\n                }\r\n                const proxy = new Proxy(source, {\r\n                    deleteProperty(target, property) {\r\n                        delete target[property];\r\n                        return true;\r\n                    },\r\n                    set(target, property, value) {\r\n                        target[property] = value;\r\n                        if (property === \"length\") {\r\n                            onAdoptedSheetsChange(node);\r\n                        }\r\n                        return true;\r\n                    }\r\n                });\r\n                adoptedSheetsSourceProxies.set(source, proxy);\r\n                adoptedSheetsProxySources.set(proxy, source);\r\n                return proxy;\r\n            };\r\n            [Document, ShadowRoot].forEach((ctor) => {\r\n                overrideProperty(ctor, \"adoptedStyleSheets\", {\r\n                    get: (native) =>\r\n                        function () {\r\n                            const source = native.call(this);\r\n                            return proxyAdoptedSheetsArray(this, source);\r\n                        },\r\n                    set: (native) =>\r\n                        function (source) {\r\n                            if (adoptedSheetsProxySources.has(source)) {\r\n                                source = adoptedSheetsProxySources.get(source);\r\n                            }\r\n                            native.call(this, source);\r\n                            onAdoptedSheetsChange(this);\r\n                        }\r\n                });\r\n            });\r\n            const adoptedDeclarationChangeEvent = new CustomEvent(\r\n                \"__darkreader__adoptedStyleDeclarationChange\"\r\n            );\r\n            [\"setProperty\", \"removeProperty\"].forEach((key) => {\r\n                override(CSSStyleDeclaration, key, (native) => {\r\n                    return function (...args) {\r\n                        const returnValue = native.apply(this, args);\r\n                        const sheet = adoptedDeclarationSheets.get(this);\r\n                        if (sheet) {\r\n                            const owners = adoptedSheetOwners.get(sheet);\r\n                            if (owners) {\r\n                                owners.forEach((node) => {\r\n                                    node.dispatchEvent(\r\n                                        adoptedDeclarationChangeEvent\r\n                                    );\r\n                                });\r\n                            }\r\n                        }\r\n                        return returnValue;\r\n                    };\r\n                });\r\n            });\r\n        }\r\n    }\r\n\r\n    const definedCustomElements = new Set();\r\n    const undefinedGroups = new Map();\r\n    let elementsDefinitionCallback;\r\n    function isCustomElement(element) {\r\n        if (element.tagName.includes(\"-\") || element.getAttribute(\"is\")) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    function recordUndefinedElement(element) {\r\n        let tag = element.tagName.toLowerCase();\r\n        if (!tag.includes(\"-\")) {\r\n            const extendedTag = element.getAttribute(\"is\");\r\n            if (extendedTag) {\r\n                tag = extendedTag;\r\n            } else {\r\n                return;\r\n            }\r\n        }\r\n        if (!undefinedGroups.has(tag)) {\r\n            undefinedGroups.set(tag, new Set());\r\n            customElementsWhenDefined(tag).then(() => {\r\n                if (elementsDefinitionCallback) {\r\n                    const elements = undefinedGroups.get(tag);\r\n                    undefinedGroups.delete(tag);\r\n                    elementsDefinitionCallback(Array.from(elements));\r\n                }\r\n            });\r\n        }\r\n        undefinedGroups.get(tag).add(element);\r\n    }\r\n    function collectUndefinedElements(root) {\r\n        if (!isDefinedSelectorSupported) {\r\n            return;\r\n        }\r\n        forEach(\r\n            root.querySelectorAll(\":not(:defined)\"),\r\n            recordUndefinedElement\r\n        );\r\n    }\r\n    let canOptimizeUsingProxy = false;\r\n    document.addEventListener(\r\n        \"__darkreader__inlineScriptsAllowed\",\r\n        () => {\r\n            canOptimizeUsingProxy = true;\r\n        },\r\n        {once: true, passive: true}\r\n    );\r\n    const unhandledShadowHosts = new Set();\r\n    document.addEventListener(\"__darkreader__shadowDomAttaching\", (e) => {\r\n        const host = e.target;\r\n        if (unhandledShadowHosts.size === 0) {\r\n            queueMicrotask(() => {\r\n                const hosts = [...unhandledShadowHosts].filter(\r\n                    (el) => el.shadowRoot\r\n                );\r\n                elementsDefinitionCallback?.(hosts);\r\n                unhandledShadowHosts.clear();\r\n            });\r\n        }\r\n        unhandledShadowHosts.add(host);\r\n    });\r\n    const resolvers = new Map();\r\n    function handleIsDefined(e) {\r\n        canOptimizeUsingProxy = true;\r\n        const tag = e.detail.tag;\r\n        definedCustomElements.add(tag);\r\n        if (resolvers.has(tag)) {\r\n            const r = resolvers.get(tag);\r\n            resolvers.delete(tag);\r\n            r.forEach((r) => r());\r\n        }\r\n    }\r\n    async function customElementsWhenDefined(tag) {\r\n        if (definedCustomElements.has(tag)) {\r\n            return;\r\n        }\r\n        return new Promise((resolve) => {\r\n            if (\r\n                window.customElements &&\r\n                typeof customElements.whenDefined === \"function\"\r\n            ) {\r\n                customElements.whenDefined(tag).then(() => resolve());\r\n            } else if (canOptimizeUsingProxy) {\r\n                if (resolvers.has(tag)) {\r\n                    resolvers.get(tag).push(resolve);\r\n                } else {\r\n                    resolvers.set(tag, [resolve]);\r\n                }\r\n                document.dispatchEvent(\r\n                    new CustomEvent(\"__darkreader__addUndefinedResolver\", {\r\n                        detail: {tag}\r\n                    })\r\n                );\r\n            } else {\r\n                const checkIfDefined = () => {\r\n                    const elements = undefinedGroups.get(tag);\r\n                    if (elements && elements.size > 0) {\r\n                        if (\r\n                            elements.values().next().value.matches(\":defined\")\r\n                        ) {\r\n                            resolve();\r\n                        } else {\r\n                            requestAnimationFrame(checkIfDefined);\r\n                        }\r\n                    }\r\n                };\r\n                requestAnimationFrame(checkIfDefined);\r\n            }\r\n        });\r\n    }\r\n    function watchWhenCustomElementsDefined(callback) {\r\n        elementsDefinitionCallback = callback;\r\n    }\r\n    function unsubscribeFromDefineCustomElements() {\r\n        elementsDefinitionCallback = null;\r\n        undefinedGroups.clear();\r\n        document.removeEventListener(\r\n            \"__darkreader__isDefined\",\r\n            handleIsDefined\r\n        );\r\n    }\r\n\r\n    const observers = [];\r\n    let observedRoots;\r\n    let handledShadowHosts;\r\n    function watchForStylePositions(\r\n        currentStyles,\r\n        update,\r\n        shadowRootDiscovered\r\n    ) {\r\n        stopWatchingForStylePositions();\r\n        const prevStylesByRoot = new WeakMap();\r\n        const getPrevStyles = (root) => {\r\n            if (!prevStylesByRoot.has(root)) {\r\n                prevStylesByRoot.set(root, new Set());\r\n            }\r\n            return prevStylesByRoot.get(root);\r\n        };\r\n        currentStyles.forEach((node) => {\r\n            let root = node;\r\n            while ((root = root.parentNode)) {\r\n                if (\r\n                    root === document ||\r\n                    root.nodeType === Node.DOCUMENT_FRAGMENT_NODE\r\n                ) {\r\n                    const prevStyles = getPrevStyles(root);\r\n                    prevStyles.add(node);\r\n                    break;\r\n                }\r\n            }\r\n        });\r\n        const prevStyleSiblings = new WeakMap();\r\n        const nextStyleSiblings = new WeakMap();\r\n        function saveStylePosition(style) {\r\n            prevStyleSiblings.set(style, style.previousElementSibling);\r\n            nextStyleSiblings.set(style, style.nextElementSibling);\r\n        }\r\n        function forgetStylePosition(style) {\r\n            prevStyleSiblings.delete(style);\r\n            nextStyleSiblings.delete(style);\r\n        }\r\n        function didStylePositionChange(style) {\r\n            return (\r\n                style.previousElementSibling !== prevStyleSiblings.get(style) ||\r\n                style.nextElementSibling !== nextStyleSiblings.get(style)\r\n            );\r\n        }\r\n        currentStyles.forEach(saveStylePosition);\r\n        function handleStyleOperations(root, operations) {\r\n            const {createdStyles, removedStyles, movedStyles} = operations;\r\n            createdStyles.forEach((s) => saveStylePosition(s));\r\n            movedStyles.forEach((s) => saveStylePosition(s));\r\n            removedStyles.forEach((s) => forgetStylePosition(s));\r\n            const prevStyles = getPrevStyles(root);\r\n            createdStyles.forEach((s) => prevStyles.add(s));\r\n            removedStyles.forEach((s) => prevStyles.delete(s));\r\n            if (\r\n                createdStyles.size + removedStyles.size + movedStyles.size >\r\n                0\r\n            ) {\r\n                update({\r\n                    created: Array.from(createdStyles),\r\n                    removed: Array.from(removedStyles),\r\n                    moved: Array.from(movedStyles),\r\n                    updated: []\r\n                });\r\n            }\r\n        }\r\n        function handleMinorTreeMutations(root, {additions, moves, deletions}) {\r\n            const createdStyles = new Set();\r\n            const removedStyles = new Set();\r\n            const movedStyles = new Set();\r\n            additions.forEach((node) =>\r\n                getManageableStyles(node).forEach((style) =>\r\n                    createdStyles.add(style)\r\n                )\r\n            );\r\n            deletions.forEach((node) =>\r\n                getManageableStyles(node).forEach((style) =>\r\n                    removedStyles.add(style)\r\n                )\r\n            );\r\n            moves.forEach((node) =>\r\n                getManageableStyles(node).forEach((style) =>\r\n                    movedStyles.add(style)\r\n                )\r\n            );\r\n            handleStyleOperations(root, {\r\n                createdStyles,\r\n                removedStyles,\r\n                movedStyles\r\n            });\r\n            additions.forEach((n) => {\r\n                deepObserve(n);\r\n                collectUndefinedElements(n);\r\n            });\r\n            additions.forEach(\r\n                (node) => isCustomElement(node) && recordUndefinedElement(node)\r\n            );\r\n            additions.forEach((node) => checkImageSelectors(node));\r\n        }\r\n        function handleHugeTreeMutations(root) {\r\n            const styles = new Set(getManageableStyles(root));\r\n            const createdStyles = new Set();\r\n            const removedStyles = new Set();\r\n            const movedStyles = new Set();\r\n            const prevStyles = getPrevStyles(root);\r\n            styles.forEach((s) => {\r\n                if (!prevStyles.has(s)) {\r\n                    createdStyles.add(s);\r\n                }\r\n            });\r\n            prevStyles.forEach((s) => {\r\n                if (!styles.has(s)) {\r\n                    removedStyles.add(s);\r\n                }\r\n            });\r\n            styles.forEach((s) => {\r\n                if (\r\n                    !createdStyles.has(s) &&\r\n                    !removedStyles.has(s) &&\r\n                    didStylePositionChange(s)\r\n                ) {\r\n                    movedStyles.add(s);\r\n                }\r\n            });\r\n            handleStyleOperations(root, {\r\n                createdStyles,\r\n                removedStyles,\r\n                movedStyles\r\n            });\r\n            deepObserve(root);\r\n            collectUndefinedElements(root);\r\n            checkImageSelectors(root);\r\n        }\r\n        function handleAttributeMutations(mutations) {\r\n            const updatedStyles = new Set();\r\n            const removedStyles = new Set();\r\n            mutations.forEach((m) => {\r\n                const {target} = m;\r\n                if (target.isConnected) {\r\n                    if (shouldManageStyle(target)) {\r\n                        updatedStyles.add(target);\r\n                    } else if (\r\n                        target instanceof HTMLLinkElement &&\r\n                        target.disabled\r\n                    ) {\r\n                        removedStyles.add(target);\r\n                    }\r\n                }\r\n            });\r\n            if (updatedStyles.size + removedStyles.size > 0) {\r\n                update({\r\n                    updated: Array.from(updatedStyles),\r\n                    created: [],\r\n                    removed: Array.from(removedStyles),\r\n                    moved: []\r\n                });\r\n            }\r\n        }\r\n        function observe(root) {\r\n            if (observedRoots.has(root)) {\r\n                return;\r\n            }\r\n            const treeObserver = createOptimizedTreeObserver(root, {\r\n                onMinorMutations: handleMinorTreeMutations,\r\n                onHugeMutations: handleHugeTreeMutations\r\n            });\r\n            const attrObserver = new MutationObserver(handleAttributeMutations);\r\n            attrObserver.observe(root, {\r\n                attributeFilter: [\"rel\", \"disabled\", \"media\", \"href\"],\r\n                subtree: true\r\n            });\r\n            observers.push(treeObserver, attrObserver);\r\n            observedRoots.add(root);\r\n        }\r\n        function subscribeForShadowRootChanges(node) {\r\n            const {shadowRoot} = node;\r\n            if (shadowRoot == null || observedRoots.has(shadowRoot)) {\r\n                return;\r\n            }\r\n            observe(shadowRoot);\r\n            shadowRootDiscovered(shadowRoot);\r\n        }\r\n        function deepObserve(node) {\r\n            iterateShadowHosts(node, subscribeForShadowRootChanges);\r\n        }\r\n        observe(document);\r\n        deepObserve(document.documentElement);\r\n        watchWhenCustomElementsDefined((hosts) => {\r\n            hosts = hosts.filter((node) => !handledShadowHosts.has(node));\r\n            const newStyles = [];\r\n            hosts.forEach((host) =>\r\n                push(newStyles, getManageableStyles(host.shadowRoot))\r\n            );\r\n            update({created: newStyles, updated: [], removed: [], moved: []});\r\n            hosts.forEach((host) => {\r\n                const {shadowRoot} = host;\r\n                if (shadowRoot == null) {\r\n                    return;\r\n                }\r\n                subscribeForShadowRootChanges(host);\r\n                deepObserve(shadowRoot);\r\n                collectUndefinedElements(shadowRoot);\r\n            });\r\n            hosts.forEach((node) => handledShadowHosts.add(node));\r\n        });\r\n        document.addEventListener(\"__darkreader__isDefined\", handleIsDefined);\r\n        collectUndefinedElements(document);\r\n    }\r\n    function resetObservers() {\r\n        observers.forEach((o) => o.disconnect());\r\n        observers.splice(0, observers.length);\r\n        observedRoots = new WeakSet();\r\n        handledShadowHosts = new WeakSet();\r\n    }\r\n    function stopWatchingForStylePositions() {\r\n        resetObservers();\r\n        unsubscribeFromDefineCustomElements();\r\n    }\r\n\r\n    function watchForStyleChanges(currentStyles, update, shadowRootDiscovered) {\r\n        watchForStylePositions(currentStyles, update, shadowRootDiscovered);\r\n    }\r\n    function stopWatchingForStyleChanges() {\r\n        stopWatchingForStylePositions();\r\n    }\r\n\r\n    const INSTANCE_ID = generateUID();\r\n    const styleManagers = new Map();\r\n    const adoptedStyleManagers = [];\r\n    const adoptedStyleFallbacks = new Map();\r\n    const adoptedStyleChangeTokens = new WeakMap();\r\n    let theme = null;\r\n    let fixes = null;\r\n    let isIFrame$1 = null;\r\n    let ignoredImageAnalysisSelectors = [];\r\n    let ignoredInlineSelectors = [];\r\n    function createOrUpdateStyle(className, root = document.head || document) {\r\n        let element = root.querySelector(`.${className}`);\r\n        if (!element) {\r\n            element = document.createElement(\"style\");\r\n            element.classList.add(\"darkreader\");\r\n            element.classList.add(className);\r\n            element.media = \"screen\";\r\n            element.textContent = \"\";\r\n        }\r\n        return element;\r\n    }\r\n    function createOrUpdateScript(className, root = document.head || document) {\r\n        let element = root.querySelector(`.${className}`);\r\n        if (!element) {\r\n            element = document.createElement(\"script\");\r\n            element.classList.add(\"darkreader\");\r\n            element.classList.add(className);\r\n        }\r\n        return element;\r\n    }\r\n    const nodePositionWatchers = new Map();\r\n    function setupNodePositionWatcher(node, alias) {\r\n        nodePositionWatchers.has(alias) &&\r\n            nodePositionWatchers.get(alias).stop();\r\n        nodePositionWatchers.set(alias, watchForNodePosition(node, \"head\"));\r\n    }\r\n    function stopStylePositionWatchers() {\r\n        forEach(nodePositionWatchers.values(), (watcher) => watcher.stop());\r\n        nodePositionWatchers.clear();\r\n    }\r\n    function createStaticStyleOverrides() {\r\n        const fallbackStyle = createOrUpdateStyle(\r\n            \"darkreader--fallback\",\r\n            document\r\n        );\r\n        fallbackStyle.textContent = getModifiedFallbackStyle(theme, {\r\n            strict: true\r\n        });\r\n        document.head.insertBefore(fallbackStyle, document.head.firstChild);\r\n        setupNodePositionWatcher(fallbackStyle, \"fallback\");\r\n        const userAgentStyle = createOrUpdateStyle(\"darkreader--user-agent\");\r\n        userAgentStyle.textContent = getModifiedUserAgentStyle(\r\n            theme,\r\n            isIFrame$1,\r\n            theme.styleSystemControls\r\n        );\r\n        document.head.insertBefore(userAgentStyle, fallbackStyle.nextSibling);\r\n        setupNodePositionWatcher(userAgentStyle, \"user-agent\");\r\n        const textStyle = createOrUpdateStyle(\"darkreader--text\");\r\n        if (theme.useFont || theme.textStroke > 0) {\r\n            textStyle.textContent = createTextStyle(theme);\r\n        } else {\r\n            textStyle.textContent = \"\";\r\n        }\r\n        document.head.insertBefore(textStyle, fallbackStyle.nextSibling);\r\n        setupNodePositionWatcher(textStyle, \"text\");\r\n        const invertStyle = createOrUpdateStyle(\"darkreader--invert\");\r\n        if (fixes && Array.isArray(fixes.invert) && fixes.invert.length > 0) {\r\n            invertStyle.textContent = [\r\n                `${fixes.invert.join(\", \")} {`,\r\n                `    filter: ${getCSSFilterValue({\r\n                    ...theme,\r\n                    contrast:\r\n                        theme.mode === 0\r\n                            ? theme.contrast\r\n                            : clamp(theme.contrast - 10, 0, 100)\r\n                })} !important;`,\r\n                \"}\"\r\n            ].join(\"\\n\");\r\n        } else {\r\n            invertStyle.textContent = \"\";\r\n        }\r\n        document.head.insertBefore(invertStyle, textStyle.nextSibling);\r\n        setupNodePositionWatcher(invertStyle, \"invert\");\r\n        const inlineStyle = createOrUpdateStyle(\"darkreader--inline\");\r\n        inlineStyle.textContent = getInlineOverrideStyle();\r\n        document.head.insertBefore(inlineStyle, invertStyle.nextSibling);\r\n        setupNodePositionWatcher(inlineStyle, \"inline\");\r\n        const overrideStyle = createOrUpdateStyle(\"darkreader--override\");\r\n        overrideStyle.textContent =\r\n            fixes && fixes.css ? replaceCSSTemplates(fixes.css) : \"\";\r\n        document.head.appendChild(overrideStyle);\r\n        setupNodePositionWatcher(overrideStyle, \"override\");\r\n        const variableStyle = createOrUpdateStyle(\"darkreader--variables\");\r\n        const selectionColors = theme?.selectionColor\r\n            ? getSelectionColor(theme)\r\n            : null;\r\n        const neutralBackgroundColor = modifyBackgroundColor(\r\n            parseColorWithCache(\"#ffffff\"),\r\n            theme\r\n        );\r\n        const neutralTextColor = modifyForegroundColor(\r\n            parseColorWithCache(\"#000000\"),\r\n            theme\r\n        );\r\n        variableStyle.textContent = [\r\n            `:root {`,\r\n            `   --darkreader-neutral-background: ${neutralBackgroundColor};`,\r\n            `   --darkreader-neutral-text: ${neutralTextColor};`,\r\n            `   --darkreader-selection-background: ${selectionColors?.backgroundColorSelection ?? \"initial\"};`,\r\n            `   --darkreader-selection-text: ${selectionColors?.foregroundColorSelection ?? \"initial\"};`,\r\n            `}`\r\n        ].join(\"\\n\");\r\n        document.head.insertBefore(variableStyle, inlineStyle.nextSibling);\r\n        setupNodePositionWatcher(variableStyle, \"variables\");\r\n        registerVariablesSheet(variableStyle.sheet);\r\n        const rootVarsStyle = createOrUpdateStyle(\"darkreader--root-vars\");\r\n        document.head.insertBefore(rootVarsStyle, variableStyle.nextSibling);\r\n        const enableStyleSheetsProxy = !(\r\n            fixes && fixes.disableStyleSheetsProxy\r\n        );\r\n        const enableCustomElementRegistryProxy = !(\r\n            fixes && fixes.disableCustomElementRegistryProxy\r\n        );\r\n        document.dispatchEvent(new CustomEvent(\"__darkreader__cleanUp\"));\r\n        {\r\n            const proxyScript = createOrUpdateScript(\"darkreader--proxy\");\r\n            proxyScript.append(\r\n                `(${injectProxy})(${enableStyleSheetsProxy}, ${enableCustomElementRegistryProxy})`\r\n            );\r\n            document.head.insertBefore(proxyScript, rootVarsStyle.nextSibling);\r\n            proxyScript.remove();\r\n        }\r\n    }\r\n    const shadowRootsWithOverrides = new Set();\r\n    function createShadowStaticStyleOverridesInner(root) {\r\n        const inlineStyle = createOrUpdateStyle(\"darkreader--inline\", root);\r\n        inlineStyle.textContent = getInlineOverrideStyle();\r\n        root.insertBefore(inlineStyle, root.firstChild);\r\n        const overrideStyle = createOrUpdateStyle(\"darkreader--override\", root);\r\n        overrideStyle.textContent =\r\n            fixes && fixes.css ? replaceCSSTemplates(fixes.css) : \"\";\r\n        root.insertBefore(overrideStyle, inlineStyle.nextSibling);\r\n        const invertStyle = createOrUpdateStyle(\"darkreader--invert\", root);\r\n        if (fixes && Array.isArray(fixes.invert) && fixes.invert.length > 0) {\r\n            invertStyle.textContent = [\r\n                `${fixes.invert.join(\", \")} {`,\r\n                `    filter: ${getCSSFilterValue({\r\n                    ...theme,\r\n                    contrast:\r\n                        theme.mode === 0\r\n                            ? theme.contrast\r\n                            : clamp(theme.contrast - 10, 0, 100)\r\n                })} !important;`,\r\n                \"}\"\r\n            ].join(\"\\n\");\r\n        } else {\r\n            invertStyle.textContent = \"\";\r\n        }\r\n        root.insertBefore(invertStyle, overrideStyle.nextSibling);\r\n        shadowRootsWithOverrides.add(root);\r\n    }\r\n    function delayedCreateShadowStaticStyleOverrides(root) {\r\n        const observer = new MutationObserver((mutations, observer) => {\r\n            observer.disconnect();\r\n            for (const {type, removedNodes} of mutations) {\r\n                if (type === \"childList\") {\r\n                    for (const {nodeName, className} of removedNodes) {\r\n                        if (\r\n                            nodeName === \"STYLE\" &&\r\n                            [\r\n                                \"darkreader darkreader--inline\",\r\n                                \"darkreader darkreader--override\",\r\n                                \"darkreader darkreader--invert\"\r\n                            ].includes(className)\r\n                        ) {\r\n                            createShadowStaticStyleOverridesInner(root);\r\n                            return;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        });\r\n        observer.observe(root, {childList: true});\r\n    }\r\n    function createShadowStaticStyleOverrides(root) {\r\n        const delayed = root.firstChild === null;\r\n        createShadowStaticStyleOverridesInner(root);\r\n        if (delayed) {\r\n            delayedCreateShadowStaticStyleOverrides(root);\r\n        }\r\n    }\r\n    function replaceCSSTemplates($cssText) {\r\n        return $cssText.replace(/\\${(.+?)}/g, (_, $color) => {\r\n            const color = parseColorWithCache($color);\r\n            if (color) {\r\n                const lightness = getSRGBLightness(color.r, color.g, color.b);\r\n                if (lightness > 0.5) {\r\n                    return modifyBackgroundColor(color, theme);\r\n                }\r\n                return modifyForegroundColor(color, theme);\r\n            }\r\n            return $color;\r\n        });\r\n    }\r\n    function cleanFallbackStyle() {\r\n        const fallback = document.querySelector(\".darkreader--fallback\");\r\n        if (fallback) {\r\n            fallback.textContent = \"\";\r\n        }\r\n    }\r\n    function createDynamicStyleOverrides() {\r\n        cancelRendering();\r\n        const allStyles = getManageableStyles(document);\r\n        const newManagers = allStyles\r\n            .filter((style) => !styleManagers.has(style))\r\n            .map((style) => createManager(style));\r\n        newManagers\r\n            .map((manager) => manager.details({secondRound: false}))\r\n            .filter((detail) => detail && detail.rules.length > 0)\r\n            .forEach((detail) => {\r\n                variablesStore.addRulesForMatching(detail.rules);\r\n            });\r\n        variablesStore.matchVariablesAndDependents();\r\n        variablesStore.setOnRootVariableChange(() => {\r\n            const rootVarsStyle = createOrUpdateStyle(\"darkreader--root-vars\");\r\n            variablesStore.putRootVars(rootVarsStyle, theme);\r\n        });\r\n        const rootVarsStyle = createOrUpdateStyle(\"darkreader--root-vars\");\r\n        variablesStore.putRootVars(rootVarsStyle, theme);\r\n        styleManagers.forEach((manager) =>\r\n            manager.render(theme, ignoredImageAnalysisSelectors)\r\n        );\r\n        if (loadingStyles.size === 0) {\r\n            cleanFallbackStyle();\r\n        }\r\n        newManagers.forEach((manager) => manager.watch());\r\n        const inlineStyleElements = toArray(\r\n            document.querySelectorAll(INLINE_STYLE_SELECTOR)\r\n        );\r\n        iterateShadowHosts(document.documentElement, (host) => {\r\n            createShadowStaticStyleOverrides(host.shadowRoot);\r\n            const elements = host.shadowRoot.querySelectorAll(\r\n                INLINE_STYLE_SELECTOR\r\n            );\r\n            if (elements.length > 0) {\r\n                push(inlineStyleElements, elements);\r\n            }\r\n        });\r\n        inlineStyleElements.forEach((el) =>\r\n            overrideInlineStyle(\r\n                el,\r\n                theme,\r\n                ignoredInlineSelectors,\r\n                ignoredImageAnalysisSelectors\r\n            )\r\n        );\r\n        handleAdoptedStyleSheets(document);\r\n        variablesStore.matchVariablesAndDependents();\r\n        if (isFirefox) {\r\n            const onAdoptedCssChange = (e) => {\r\n                const {sheets} = e.detail;\r\n                if (!Array.isArray(sheets) || sheets.length === 0) {\r\n                    return;\r\n                }\r\n                sheets.forEach(({sheet}) => {\r\n                    const {cssRules} = sheet;\r\n                    variablesStore.addRulesForMatching(cssRules);\r\n                });\r\n                variablesStore.matchVariablesAndDependents();\r\n                const response = [];\r\n                sheets.forEach(({sheetId, sheet}) => {\r\n                    const fallback = getAdoptedStyleSheetFallback(sheet);\r\n                    const cssRules = sheet.cssRules;\r\n                    fallback.render({\r\n                        theme: theme,\r\n                        ignoreImageAnalysis: ignoredImageAnalysisSelectors,\r\n                        cssRules\r\n                    });\r\n                    const commands = fallback.commands();\r\n                    response.push({sheetId, commands});\r\n                });\r\n                requestAnimationFrameOnce(\r\n                    getAdoptedStyleChangeToken(sheets[0].sheet),\r\n                    () => {\r\n                        document.dispatchEvent(\r\n                            new CustomEvent(\r\n                                \"__darkreader__adoptedStyleSheetCommands\",\r\n                                {detail: JSON.stringify(response)}\r\n                            )\r\n                        );\r\n                    }\r\n                );\r\n            };\r\n            document.addEventListener(\r\n                \"__darkreader__adoptedStyleSheetsChange\",\r\n                onAdoptedCssChange\r\n            );\r\n            cleaners.push(() =>\r\n                document.removeEventListener(\r\n                    \"__darkreader__adoptedStyleSheetsChange\",\r\n                    onAdoptedCssChange\r\n                )\r\n            );\r\n            document.dispatchEvent(\r\n                new CustomEvent(\"__darkreader__startAdoptedStyleSheetsWatcher\")\r\n            );\r\n        }\r\n    }\r\n    let loadingStylesCounter = 0;\r\n    const loadingStyles = new Set();\r\n    function createManager(element) {\r\n        const loadingStyleId = ++loadingStylesCounter;\r\n        function loadingStart() {\r\n            if (!isDOMReady() || !documentIsVisible()) {\r\n                loadingStyles.add(loadingStyleId);\r\n                logInfo(\r\n                    `Current amount of styles loading: ${loadingStyles.size}`\r\n                );\r\n                const fallbackStyle = document.querySelector(\r\n                    \".darkreader--fallback\"\r\n                );\r\n                if (!fallbackStyle.textContent) {\r\n                    fallbackStyle.textContent = getModifiedFallbackStyle(\r\n                        theme,\r\n                        {strict: false}\r\n                    );\r\n                }\r\n            }\r\n        }\r\n        function loadingEnd() {\r\n            loadingStyles.delete(loadingStyleId);\r\n            logInfo(\r\n                `Removed loadingStyle ${loadingStyleId}, now awaiting: ${loadingStyles.size}`\r\n            );\r\n            if (loadingStyles.size === 0 && isDOMReady()) {\r\n                cleanFallbackStyle();\r\n            }\r\n        }\r\n        function update() {\r\n            const details = manager.details({secondRound: true});\r\n            if (!details) {\r\n                return;\r\n            }\r\n            variablesStore.addRulesForMatching(details.rules);\r\n            variablesStore.matchVariablesAndDependents();\r\n            manager.render(theme, ignoredImageAnalysisSelectors);\r\n        }\r\n        const manager = manageStyle(element, {\r\n            update,\r\n            loadingStart,\r\n            loadingEnd\r\n        });\r\n        styleManagers.set(element, manager);\r\n        return manager;\r\n    }\r\n    function removeManager(element) {\r\n        const manager = styleManagers.get(element);\r\n        if (manager) {\r\n            manager.destroy();\r\n            styleManagers.delete(element);\r\n        }\r\n    }\r\n    const throttledRenderAllStyles = throttle((callback) => {\r\n        styleManagers.forEach((manager) =>\r\n            manager.render(theme, ignoredImageAnalysisSelectors)\r\n        );\r\n        adoptedStyleManagers.forEach((manager) =>\r\n            manager.render(theme, ignoredImageAnalysisSelectors)\r\n        );\r\n        callback && callback();\r\n    });\r\n    const cancelRendering = function () {\r\n        throttledRenderAllStyles.cancel();\r\n    };\r\n    function onDOMReady() {\r\n        if (loadingStyles.size === 0) {\r\n            cleanFallbackStyle();\r\n            return;\r\n        }\r\n    }\r\n    function runDynamicStyle() {\r\n        createDynamicStyleOverrides();\r\n        watchForUpdates();\r\n    }\r\n    function createThemeAndWatchForUpdates() {\r\n        createStaticStyleOverrides();\r\n        if (!documentIsVisible() && !theme.immediateModify) {\r\n            setDocumentVisibilityListener(runDynamicStyle);\r\n        } else {\r\n            runDynamicStyle();\r\n        }\r\n        changeMetaThemeColorWhenAvailable(theme);\r\n    }\r\n    function handleAdoptedStyleSheets(node) {\r\n        if (isFirefox) {\r\n            return;\r\n        }\r\n        if (canHaveAdoptedStyleSheets(node)) {\r\n            node.adoptedStyleSheets.forEach((s) => {\r\n                variablesStore.addRulesForMatching(s.cssRules);\r\n            });\r\n            const newManger = createAdoptedStyleSheetOverride(node);\r\n            adoptedStyleManagers.push(newManger);\r\n            newManger.render(theme, ignoredImageAnalysisSelectors);\r\n            newManger.watch((sheets) => {\r\n                sheets.forEach((s) => {\r\n                    variablesStore.addRulesForMatching(s.cssRules);\r\n                });\r\n                variablesStore.matchVariablesAndDependents();\r\n                newManger.render(theme, ignoredImageAnalysisSelectors);\r\n            });\r\n        }\r\n    }\r\n    function getAdoptedStyleChangeToken(sheet) {\r\n        if (adoptedStyleChangeTokens.has(sheet)) {\r\n            return adoptedStyleChangeTokens.get(sheet);\r\n        }\r\n        const token = Symbol();\r\n        adoptedStyleChangeTokens.set(sheet, token);\r\n        return token;\r\n    }\r\n    function getAdoptedStyleSheetFallback(sheet) {\r\n        let fallback = adoptedStyleFallbacks.get(sheet);\r\n        if (!fallback) {\r\n            fallback = createAdoptedStyleSheetFallback();\r\n            adoptedStyleFallbacks.set(sheet, fallback);\r\n        }\r\n        return fallback;\r\n    }\r\n    function watchForUpdates() {\r\n        const managedStyles = Array.from(styleManagers.keys());\r\n        watchForStyleChanges(\r\n            managedStyles,\r\n            ({created, updated, removed, moved}) => {\r\n                const stylesToRemove = removed;\r\n                const stylesToManage = created\r\n                    .concat(updated)\r\n                    .concat(moved)\r\n                    .filter((style) => !styleManagers.has(style));\r\n                const stylesToRestore = moved.filter((style) =>\r\n                    styleManagers.has(style)\r\n                );\r\n                stylesToRemove.forEach((style) => removeManager(style));\r\n                const newManagers = stylesToManage.map((style) =>\r\n                    createManager(style)\r\n                );\r\n                newManagers\r\n                    .map((manager) => manager.details({secondRound: false}))\r\n                    .filter((detail) => detail && detail.rules.length > 0)\r\n                    .forEach((detail) => {\r\n                        variablesStore.addRulesForMatching(detail.rules);\r\n                    });\r\n                variablesStore.matchVariablesAndDependents();\r\n                newManagers.forEach((manager) =>\r\n                    manager.render(theme, ignoredImageAnalysisSelectors)\r\n                );\r\n                newManagers.forEach((manager) => manager.watch());\r\n                stylesToRestore.forEach((style) =>\r\n                    styleManagers.get(style).restore()\r\n                );\r\n            },\r\n            (shadowRoot) => {\r\n                createShadowStaticStyleOverrides(shadowRoot);\r\n                handleAdoptedStyleSheets(shadowRoot);\r\n            }\r\n        );\r\n        watchForInlineStyles(\r\n            (element) => {\r\n                overrideInlineStyle(\r\n                    element,\r\n                    theme,\r\n                    ignoredInlineSelectors,\r\n                    ignoredImageAnalysisSelectors\r\n                );\r\n                if (element === document.documentElement) {\r\n                    const styleAttr = element.getAttribute(\"style\") || \"\";\r\n                    if (styleAttr.includes(\"--\")) {\r\n                        variablesStore.matchVariablesAndDependents();\r\n                        const rootVarsStyle = createOrUpdateStyle(\r\n                            \"darkreader--root-vars\"\r\n                        );\r\n                        variablesStore.putRootVars(rootVarsStyle, theme);\r\n                    }\r\n                }\r\n            },\r\n            (root) => {\r\n                createShadowStaticStyleOverrides(root);\r\n                const inlineStyleElements = root.querySelectorAll(\r\n                    INLINE_STYLE_SELECTOR\r\n                );\r\n                if (inlineStyleElements.length > 0) {\r\n                    forEach(inlineStyleElements, (el) =>\r\n                        overrideInlineStyle(\r\n                            el,\r\n                            theme,\r\n                            ignoredInlineSelectors,\r\n                            ignoredImageAnalysisSelectors\r\n                        )\r\n                    );\r\n                }\r\n            }\r\n        );\r\n        addDOMReadyListener(onDOMReady);\r\n    }\r\n    function stopWatchingForUpdates() {\r\n        styleManagers.forEach((manager) => manager.pause());\r\n        stopStylePositionWatchers();\r\n        stopWatchingForStyleChanges();\r\n        stopWatchingForInlineStyles();\r\n        removeDOMReadyListener(onDOMReady);\r\n        cleanReadyStateCompleteListeners();\r\n    }\r\n    let metaObserver;\r\n    function addMetaListener() {\r\n        metaObserver = new MutationObserver(() => {\r\n            if (document.querySelector('meta[name=\"darkreader-lock\"]')) {\r\n                metaObserver.disconnect();\r\n                removeDynamicTheme();\r\n            }\r\n        });\r\n        metaObserver.observe(document.head, {childList: true, subtree: true});\r\n    }\r\n    function createDarkReaderInstanceMarker() {\r\n        const metaElement = document.createElement(\"meta\");\r\n        metaElement.name = \"darkreader\";\r\n        metaElement.content = INSTANCE_ID;\r\n        document.head.appendChild(metaElement);\r\n    }\r\n    function isDRLocked() {\r\n        return document.querySelector('meta[name=\"darkreader-lock\"]') != null;\r\n    }\r\n    function isAnotherDarkReaderInstanceActive() {\r\n        const meta = document.querySelector('meta[name=\"darkreader\"]');\r\n        if (meta) {\r\n            if (meta.content !== INSTANCE_ID) {\r\n                return true;\r\n            }\r\n            return false;\r\n        }\r\n        createDarkReaderInstanceMarker();\r\n        addMetaListener();\r\n        return false;\r\n    }\r\n    let interceptorAttempts = 2;\r\n    function interceptOldScript({success, failure}) {\r\n        if (--interceptorAttempts <= 0) {\r\n            failure();\r\n            return;\r\n        }\r\n        const oldMeta = document.head.querySelector('meta[name=\"darkreader\"]');\r\n        if (!oldMeta || oldMeta.content === INSTANCE_ID) {\r\n            return;\r\n        }\r\n        const lock = document.createElement(\"meta\");\r\n        lock.name = \"darkreader-lock\";\r\n        document.head.append(lock);\r\n        queueMicrotask(() => {\r\n            lock.remove();\r\n            success();\r\n        });\r\n    }\r\n    function disableConflictingPlugins() {\r\n        if (document.documentElement.hasAttribute(\"data-wp-dark-mode-preset\")) {\r\n            const disableWPDarkMode = () => {\r\n                document.dispatchEvent(\r\n                    new CustomEvent(\"__darkreader__disableConflictingPlugins\")\r\n                );\r\n                document.documentElement.classList.remove(\r\n                    \"wp-dark-mode-active\"\r\n                );\r\n                document.documentElement.removeAttribute(\r\n                    \"data-wp-dark-mode-active\"\r\n                );\r\n            };\r\n            disableWPDarkMode();\r\n            const observer = new MutationObserver(() => {\r\n                if (\r\n                    document.documentElement.classList.contains(\r\n                        \"wp-dark-mode-active\"\r\n                    ) ||\r\n                    document.documentElement.hasAttribute(\r\n                        \"data-wp-dark-mode-active\"\r\n                    )\r\n                ) {\r\n                    disableWPDarkMode();\r\n                }\r\n            });\r\n            observer.observe(document.documentElement, {\r\n                attributes: true,\r\n                attributeFilter: [\"class\", \"data-wp-dark-mode-active\"]\r\n            });\r\n        }\r\n    }\r\n    let prevTheme = null;\r\n    let prevFixes = null;\r\n    function createOrUpdateDynamicThemeInternal(\r\n        themeConfig,\r\n        dynamicThemeFixes,\r\n        iframe\r\n    ) {\r\n        theme = themeConfig;\r\n        fixes = dynamicThemeFixes;\r\n        const colorAffectingKeys = [\r\n            \"brightness\",\r\n            \"contrast\",\r\n            \"darkSchemeBackgroundColor\",\r\n            \"darkSchemeTextColor\",\r\n            \"grayscale\",\r\n            \"lightSchemeBackgroundColor\",\r\n            \"lightSchemeTextColor\",\r\n            \"sepia\"\r\n        ];\r\n        if (prevTheme && prevFixes) {\r\n            const themeKeys = new Set([\r\n                ...Object.keys(theme),\r\n                ...Object.keys(prevTheme)\r\n            ]);\r\n            let onlyColorsChanged = true;\r\n            for (const key of themeKeys) {\r\n                if (\r\n                    theme[key] !== prevTheme[key] &&\r\n                    !colorAffectingKeys.includes(key)\r\n                ) {\r\n                    onlyColorsChanged = false;\r\n                    break;\r\n                }\r\n            }\r\n            if (\r\n                onlyColorsChanged &&\r\n                JSON.stringify(fixes) !== JSON.stringify(prevFixes)\r\n            ) {\r\n                onlyColorsChanged = false;\r\n            }\r\n            if (onlyColorsChanged) {\r\n                const palette = getColorPalette();\r\n                clearColorPalette();\r\n                palette.background.forEach((color) =>\r\n                    modifyBackgroundColor(color, theme)\r\n                );\r\n                palette.text.forEach((color) =>\r\n                    modifyForegroundColor(color, theme)\r\n                );\r\n                palette.border.forEach((color) =>\r\n                    modifyBorderColor(color, theme)\r\n                );\r\n                return;\r\n            }\r\n            clearColorPalette();\r\n        }\r\n        if (fixes) {\r\n            ignoredImageAnalysisSelectors = Array.isArray(\r\n                fixes.ignoreImageAnalysis\r\n            )\r\n                ? fixes.ignoreImageAnalysis\r\n                : [];\r\n            ignoredInlineSelectors = Array.isArray(fixes.ignoreInlineStyle)\r\n                ? fixes.ignoreInlineStyle\r\n                : [];\r\n        } else {\r\n            ignoredImageAnalysisSelectors = [];\r\n            ignoredInlineSelectors = [];\r\n        }\r\n        if (theme.immediateModify) {\r\n            setIsDOMReady(() => {\r\n                return true;\r\n            });\r\n        }\r\n        isIFrame$1 = iframe;\r\n        const ready = () => {\r\n            const success = () => {\r\n                disableConflictingPlugins();\r\n                document.documentElement.setAttribute(\r\n                    \"data-darkreader-mode\",\r\n                    \"dynamic\"\r\n                );\r\n                document.documentElement.setAttribute(\r\n                    \"data-darkreader-scheme\",\r\n                    theme.mode ? \"dark\" : \"dimmed\"\r\n                );\r\n                createThemeAndWatchForUpdates();\r\n            };\r\n            const failure = () => {\r\n                removeDynamicTheme();\r\n            };\r\n            if (isDRLocked()) {\r\n                removeNode(document.querySelector(\".darkreader--fallback\"));\r\n            } else if (isAnotherDarkReaderInstanceActive()) {\r\n                interceptOldScript({\r\n                    success,\r\n                    failure\r\n                });\r\n            } else {\r\n                success();\r\n            }\r\n        };\r\n        if (document.head) {\r\n            ready();\r\n        } else {\r\n            if (!isFirefox) {\r\n                const fallbackStyle = createOrUpdateStyle(\r\n                    \"darkreader--fallback\"\r\n                );\r\n                document.documentElement.appendChild(fallbackStyle);\r\n                fallbackStyle.textContent = getModifiedFallbackStyle(theme, {\r\n                    strict: true\r\n                });\r\n            }\r\n            const headObserver = new MutationObserver(() => {\r\n                if (document.head) {\r\n                    headObserver.disconnect();\r\n                    ready();\r\n                }\r\n            });\r\n            headObserver.observe(document, {childList: true, subtree: true});\r\n        }\r\n        prevTheme = theme;\r\n        prevFixes = fixes;\r\n    }\r\n    function removeProxy() {\r\n        document.dispatchEvent(new CustomEvent(\"__darkreader__cleanUp\"));\r\n        removeNode(document.head.querySelector(\".darkreader--proxy\"));\r\n    }\r\n    const cleaners = [];\r\n    function removeDynamicTheme() {\r\n        document.documentElement.removeAttribute(`data-darkreader-mode`);\r\n        document.documentElement.removeAttribute(`data-darkreader-scheme`);\r\n        cleanDynamicThemeCache();\r\n        removeNode(document.querySelector(\".darkreader--fallback\"));\r\n        if (document.head) {\r\n            const selectors = [\r\n                \".darkreader--user-agent\",\r\n                \".darkreader--text\",\r\n                \".darkreader--invert\",\r\n                \".darkreader--inline\",\r\n                \".darkreader--override\",\r\n                \".darkreader--variables\",\r\n                \".darkreader--root-vars\",\r\n                'meta[name=\"darkreader\"]'\r\n            ];\r\n            restoreMetaThemeColor();\r\n            selectors.forEach((selector) =>\r\n                removeNode(document.head.querySelector(selector))\r\n            );\r\n            removeProxy();\r\n        }\r\n        shadowRootsWithOverrides.forEach((root) => {\r\n            removeNode(root.querySelector(\".darkreader--inline\"));\r\n            removeNode(root.querySelector(\".darkreader--override\"));\r\n        });\r\n        shadowRootsWithOverrides.clear();\r\n        forEach(styleManagers.keys(), (el) => removeManager(el));\r\n        loadingStyles.clear();\r\n        cleanLoadingLinks();\r\n        forEach(document.querySelectorAll(\".darkreader\"), removeNode);\r\n        adoptedStyleManagers.forEach((manager) => manager.destroy());\r\n        adoptedStyleManagers.splice(0);\r\n        adoptedStyleFallbacks.forEach((fallback) => fallback.destroy());\r\n        adoptedStyleFallbacks.clear();\r\n        metaObserver && metaObserver.disconnect();\r\n        cleaners.forEach((clean) => clean());\r\n        cleaners.splice(0);\r\n    }\r\n    function cleanDynamicThemeCache() {\r\n        variablesStore.clear();\r\n        parsedURLCache.clear();\r\n        removeDocumentVisibilityListener();\r\n        cancelRendering();\r\n        stopWatchingForUpdates();\r\n        cleanModificationCache();\r\n        clearColorCache();\r\n        releaseVariablesSheet();\r\n        prevTheme = null;\r\n        prevFixes = null;\r\n    }\r\n\r\n    function parseCSS(cssText) {\r\n        cssText = removeCSSComments(cssText);\r\n        cssText = cssText.trim();\r\n        if (!cssText) {\r\n            return [];\r\n        }\r\n        const rules = [];\r\n        const excludeRanges = getTokenExclusionRanges(cssText);\r\n        const bracketRanges = getAllOpenCloseRanges(\r\n            cssText,\r\n            \"{\",\r\n            \"}\",\r\n            excludeRanges\r\n        );\r\n        let ruleStart = 0;\r\n        bracketRanges.forEach((brackets) => {\r\n            const key = cssText.substring(ruleStart, brackets.start).trim();\r\n            const content = cssText.substring(\r\n                brackets.start + 1,\r\n                brackets.end - 1\r\n            );\r\n            if (key.startsWith(\"@\")) {\r\n                const typeEndIndex = key.search(/[\\s\\(]/);\r\n                const rule = {\r\n                    type:\r\n                        typeEndIndex < 0 ? key : key.substring(0, typeEndIndex),\r\n                    query:\r\n                        typeEndIndex < 0\r\n                            ? \"\"\r\n                            : key.substring(typeEndIndex).trim(),\r\n                    rules: parseCSS(content)\r\n                };\r\n                rules.push(rule);\r\n            } else {\r\n                const rule = {\r\n                    selectors: parseSelectors(key),\r\n                    declarations: parseDeclarations(content)\r\n                };\r\n                rules.push(rule);\r\n            }\r\n            ruleStart = brackets.end;\r\n        });\r\n        return rules;\r\n    }\r\n    function getAllOpenCloseRanges(\r\n        input,\r\n        openToken,\r\n        closeToken,\r\n        excludeRanges = []\r\n    ) {\r\n        const ranges = [];\r\n        let i = 0;\r\n        let range;\r\n        while (\r\n            (range = getOpenCloseRange(\r\n                input,\r\n                i,\r\n                openToken,\r\n                closeToken,\r\n                excludeRanges\r\n            ))\r\n        ) {\r\n            ranges.push(range);\r\n            i = range.end;\r\n        }\r\n        return ranges;\r\n    }\r\n    function getTokenExclusionRanges(cssText) {\r\n        const singleQuoteGoesFirst =\r\n            cssText.indexOf(\"'\") < cssText.indexOf('\"');\r\n        const firstQuote = singleQuoteGoesFirst ? \"'\" : '\"';\r\n        const secondQuote = singleQuoteGoesFirst ? '\"' : \"'\";\r\n        const excludeRanges = getAllOpenCloseRanges(\r\n            cssText,\r\n            firstQuote,\r\n            firstQuote\r\n        );\r\n        excludeRanges.push(\r\n            ...getAllOpenCloseRanges(\r\n                cssText,\r\n                secondQuote,\r\n                secondQuote,\r\n                excludeRanges\r\n            )\r\n        );\r\n        excludeRanges.push(\r\n            ...getAllOpenCloseRanges(cssText, \"[\", \"]\", excludeRanges)\r\n        );\r\n        excludeRanges.push(\r\n            ...getAllOpenCloseRanges(cssText, \"(\", \")\", excludeRanges)\r\n        );\r\n        return excludeRanges;\r\n    }\r\n    function parseSelectors(selectorText) {\r\n        const excludeRanges = getTokenExclusionRanges(selectorText);\r\n        return splitExcluding(selectorText, \",\", excludeRanges);\r\n    }\r\n    function parseDeclarations(cssDeclarationsText) {\r\n        const declarations = [];\r\n        const excludeRanges = getTokenExclusionRanges(cssDeclarationsText);\r\n        splitExcluding(cssDeclarationsText, \";\", excludeRanges).forEach(\r\n            (part) => {\r\n                const colonIndex = part.indexOf(\":\");\r\n                if (colonIndex > 0) {\r\n                    const importantIndex = part.indexOf(\"!important\");\r\n                    declarations.push({\r\n                        property: part.substring(0, colonIndex).trim(),\r\n                        value: part\r\n                            .substring(\r\n                                colonIndex + 1,\r\n                                importantIndex > 0\r\n                                    ? importantIndex\r\n                                    : part.length\r\n                            )\r\n                            .trim(),\r\n                        important: importantIndex > 0\r\n                    });\r\n                }\r\n            }\r\n        );\r\n        return declarations;\r\n    }\r\n    function isParsedStyleRule(rule) {\r\n        return \"selectors\" in rule;\r\n    }\r\n\r\n    function formatCSS(cssText) {\r\n        const parsed = parseCSS(cssText);\r\n        return formatParsedCSS(parsed);\r\n    }\r\n    function formatParsedCSS(parsed) {\r\n        const lines = [];\r\n        const tab = \"    \";\r\n        function formatRule(rule, indent) {\r\n            if (isParsedStyleRule(rule)) {\r\n                formatStyleRule(rule, indent);\r\n            } else {\r\n                formatAtRule(rule, indent);\r\n            }\r\n        }\r\n        function formatAtRule({type, query, rules}, indent) {\r\n            lines.push(`${indent}${type} ${query} {`);\r\n            rules.forEach((child) => formatRule(child, `${indent}${tab}`));\r\n            lines.push(`${indent}}`);\r\n        }\r\n        function formatStyleRule({selectors, declarations}, indent) {\r\n            const lastSelectorIndex = selectors.length - 1;\r\n            selectors.forEach((selector, i) => {\r\n                lines.push(\r\n                    `${indent}${selector}${i < lastSelectorIndex ? \",\" : \" {\"}`\r\n                );\r\n            });\r\n            const sorted = sortDeclarations(declarations);\r\n            sorted.forEach(({property, value, important}) => {\r\n                lines.push(\r\n                    `${indent}${tab}${property}: ${value}${important ? \" !important\" : \"\"};`\r\n                );\r\n            });\r\n            lines.push(`${indent}}`);\r\n        }\r\n        clearEmptyRules(parsed);\r\n        parsed.forEach((rule) => formatRule(rule, \"\"));\r\n        return lines.join(\"\\n\");\r\n    }\r\n    function sortDeclarations(declarations) {\r\n        const prefixRegex = /^-[a-z]-/;\r\n        return [...declarations].sort((a, b) => {\r\n            const aProp = a.property;\r\n            const bProp = b.property;\r\n            const aPrefix = aProp.match(prefixRegex)?.[0] ?? \"\";\r\n            const bPrefix = bProp.match(prefixRegex)?.[0] ?? \"\";\r\n            const aNorm = aPrefix ? aProp.replace(prefixRegex, \"\") : aProp;\r\n            const bNorm = bPrefix ? bProp.replace(prefixRegex, \"\") : bProp;\r\n            if (aNorm === bNorm) {\r\n                return aPrefix.localeCompare(bPrefix);\r\n            }\r\n            return aNorm.localeCompare(bNorm);\r\n        });\r\n    }\r\n    function clearEmptyRules(rules) {\r\n        for (let i = rules.length - 1; i >= 0; i--) {\r\n            const rule = rules[i];\r\n            if (isParsedStyleRule(rule)) {\r\n                if (rule.declarations.length === 0) {\r\n                    rules.splice(i, 1);\r\n                }\r\n            } else {\r\n                clearEmptyRules(rule.rules);\r\n                if (rule.rules.length === 0) {\r\n                    rules.splice(i, 1);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    const blobRegex = /url\\(\\\"(blob\\:.*?)\\\"\\)/g;\r\n    async function replaceBlobs(text) {\r\n        const promises = [];\r\n        getMatches(blobRegex, text, 1).forEach((url) => {\r\n            const promise = loadAsDataURL(url);\r\n            promises.push(promise);\r\n        });\r\n        const data = await Promise.all(promises);\r\n        return text.replace(blobRegex, () => `url(\"${data.shift()}\")`);\r\n    }\r\n    const banner = `/*\r\n                        _______\r\n                       /       \\\\\r\n                      .==.    .==.\r\n                     ((  ))==((  ))\r\n                    / \"==\"    \"==\"\\\\\r\n                   /____|| || ||___\\\\\r\n       ________     ____    ________  ___    ___\r\n       |  ___  \\\\   /    \\\\   |  ___  \\\\ |  |  /  /\r\n       |  |  \\\\  \\\\ /  /\\\\  \\\\  |  |  \\\\  \\\\|  |_/  /\r\n       |  |   )  /  /__\\\\  \\\\ |  |__/  /|  ___  \\\\\r\n       |  |__/  /  ______  \\\\|  ____  \\\\|  |  \\\\  \\\\\r\n_______|_______/__/ ____ \\\\__\\\\__|___\\\\__\\\\__|___\\\\__\\\\____\r\n|  ___  \\\\ |  ____/ /    \\\\   |  ___  \\\\ |  ____|  ___  \\\\\r\n|  |  \\\\  \\\\|  |___ /  /\\\\  \\\\  |  |  \\\\  \\\\|  |___|  |  \\\\  \\\\\r\n|  |__/  /|  ____/  /__\\\\  \\\\ |  |   )  |  ____|  |__/  /\r\n|  ____  \\\\|  |__/  ______  \\\\|  |__/  /|  |___|  ____  \\\\\r\n|__|   \\\\__\\\\____/__/      \\\\__\\\\_______/ |______|__|   \\\\__\\\\\r\n                https://darkreader.org\r\n*/\r\n\r\n/*! Dark reader generated CSS | Licensed under MIT https://github.com/darkreader/darkreader/blob/main/LICENSE */\r\n`;\r\n    async function collectCSS() {\r\n        const css = [banner];\r\n        function addStaticCSS(selector, comment) {\r\n            const staticStyle = document.querySelector(selector);\r\n            if (staticStyle && staticStyle.textContent) {\r\n                css.push(`/* ${comment} */`);\r\n                css.push(staticStyle.textContent);\r\n                css.push(\"\");\r\n            }\r\n        }\r\n        addStaticCSS(\".darkreader--fallback\", \"Fallback Style\");\r\n        addStaticCSS(\".darkreader--user-agent\", \"User-Agent Style\");\r\n        addStaticCSS(\".darkreader--text\", \"Text Style\");\r\n        addStaticCSS(\".darkreader--invert\", \"Invert Style\");\r\n        addStaticCSS(\".darkreader--variables\", \"Variables Style\");\r\n        const modifiedCSS = [];\r\n        document.querySelectorAll(\".darkreader--sync\").forEach((element) => {\r\n            forEach(element.sheet.cssRules, (rule) => {\r\n                rule && rule.cssText && modifiedCSS.push(rule.cssText);\r\n            });\r\n        });\r\n        if (modifiedCSS.length) {\r\n            const formattedCSS = formatCSS(modifiedCSS.join(\"\\n\"));\r\n            css.push(\"/* Modified CSS */\");\r\n            css.push(await replaceBlobs(formattedCSS));\r\n            css.push(\"\");\r\n        }\r\n        addStaticCSS(\".darkreader--override\", \"Override Style\");\r\n        return css.join(\"\\n\");\r\n    }\r\n\r\n    let isDarkReaderEnabled = false;\r\n    const isIFrame = (() => {\r\n        try {\r\n            return window.self !== window.top;\r\n        } catch (err) {\r\n            console.warn(err);\r\n            return true;\r\n        }\r\n    })();\r\n    function enable(themeOptions = {}, fixes = null) {\r\n        const theme = {...DEFAULT_THEME, ...themeOptions};\r\n        if (theme.engine !== ThemeEngine.dynamicTheme) {\r\n            throw new Error(\"Theme engine is not supported.\");\r\n        }\r\n        createOrUpdateDynamicThemeInternal(theme, fixes, isIFrame);\r\n        isDarkReaderEnabled = true;\r\n    }\r\n    function isEnabled() {\r\n        return isDarkReaderEnabled;\r\n    }\r\n    function disable() {\r\n        removeDynamicTheme();\r\n        isDarkReaderEnabled = false;\r\n    }\r\n    const darkScheme =\r\n        typeof matchMedia === \"function\"\r\n            ? matchMedia(\"(prefers-color-scheme: dark)\")\r\n            : undefined;\r\n    let store = {\r\n        themeOptions: null,\r\n        fixes: null\r\n    };\r\n    function handleColorScheme() {\r\n        if (darkScheme?.matches) {\r\n            enable(store.themeOptions, store.fixes);\r\n        } else {\r\n            disable();\r\n        }\r\n    }\r\n    function auto(themeOptions = {}, fixes = null) {\r\n        if (themeOptions) {\r\n            store = {themeOptions, fixes};\r\n            handleColorScheme();\r\n            if (isMatchMediaChangeEventListenerSupported) {\r\n                darkScheme?.addEventListener(\"change\", handleColorScheme);\r\n            } else {\r\n                darkScheme?.addListener(handleColorScheme);\r\n            }\r\n        } else {\r\n            if (isMatchMediaChangeEventListenerSupported) {\r\n                darkScheme?.removeEventListener(\"change\", handleColorScheme);\r\n            } else {\r\n                darkScheme?.removeListener(handleColorScheme);\r\n            }\r\n            disable();\r\n        }\r\n    }\r\n    async function exportGeneratedCSS() {\r\n        return await collectCSS();\r\n    }\r\n    const setFetchMethod = setFetchMethod$1;\r\n\r\n    exports.auto = auto;\r\n    exports.disable = disable;\r\n    exports.enable = enable;\r\n    exports.exportGeneratedCSS = exportGeneratedCSS;\r\n    exports.isEnabled = isEnabled;\r\n    exports.setFetchMethod = setFetchMethod;\r\n\r\n    Object.defineProperty(exports, \"__esModule\", {value: true});\r\n});\r\n","// extracted by mini-css-extract-plugin\nexport {};","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { enableDarkMode, disableDarkMode } from 'darkreader';\n\nimport './scss/darkmode.scss';\n\n// Initialize immediately when script loads\ndocument.addEventListener('DOMContentLoaded', () => {\n\tconst darkMode = new DarkMode();\n});\n\nclass DarkMode {\n\tconstructor() {\n\t\tthis.isEnabled = false;\n\t\tthis.currentStyle = 1;\n\t\tthis.init();\n\t}\n\n\tinit() {\n\t\t// Create switches\n\t\tthis.createFloatingSwitch();\n\n\t\t// Initialize dark mode based on saved preference\n\t\tconst savedPreference = localStorage.getItem('nightly_dark_mode');\n\t\tif (savedPreference === 'enabled') {\n\t\t\tthis.enable();\n\t\t\t// Update switch states\n\t\t\tdocument.querySelectorAll('.nightly-switch').forEach((switchEl) => {\n\t\t\t\tswitchEl.classList.add('active');\n\t\t\t});\n\t\t}\n\n\t\t// Add switch event listeners\n\t\tthis.initSwitches();\n\n\t\t// Change style every 3 seconds for demo (remove in production)\n\t\tthis.startStyleDemo();\n\t}\n\n\tcreateSwitchElement(className = '') {\n\t\tconst switchWrapper = document.createElement('div');\n\t\tswitchWrapper.className = `nightly-switch ${className}`.trim();\n\n\t\tconst track = document.createElement('div');\n\t\ttrack.className = 'nightly-switch__track';\n\n\t\tconst circle = document.createElement('div');\n\t\tcircle.className = 'nightly-switch__circle';\n\n\t\tswitchWrapper.appendChild(track);\n\t\tswitchWrapper.appendChild(circle);\n\n\t\treturn switchWrapper;\n\t}\n\n\tcreateFloatingSwitch() {\n\t\tconst floatingSwitch = this.createSwitchElement('floating');\n\t\tdocument.body.appendChild(floatingSwitch);\n\t}\n\n\t// Change switch style\n\tchangeSwitchStyle() {\n\t\tconst switches = document.querySelectorAll('.nightly-switch');\n\t\tswitches.forEach((switchEl) => {\n\t\t\tswitchEl.classList.add(`style-${this.currentStyle}`);\n\t\t});\n\t}\n\n\tinitSwitches() {\n\t\tconst switches = document.querySelectorAll('.nightly-switch');\n\t\tswitches.forEach((switchEl) => {\n\t\t\tswitchEl.addEventListener('click', () => {\n\t\t\t\tthis.toggle();\n\t\t\t\t// Update all switches to maintain sync\n\t\t\t\tdocument.querySelectorAll('.nightly-switch').forEach((s) => {\n\t\t\t\t\ts.classList.toggle('active', this.isEnabled);\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t}\n\n\tenable() {\n\t\tenableDarkMode({\n\t\t\tbrightness: 100,\n\t\t\tcontrast: 100,\n\t\t\tsepia: 0,\n\t\t\tdarkSchemeBackgroundColor: '#1a1a1a',\n\t\t\tdarkSchemeTextColor: '#ffffff',\n\t\t});\n\t\tthis.isEnabled = true;\n\t\tlocalStorage.setItem('nightly_dark_mode', 'enabled');\n\t\tdocument.body.classList.add('nightly-dark-mode');\n\t}\n\n\tdisable() {\n\t\tdisableDarkMode();\n\t\tthis.isEnabled = false;\n\t\tlocalStorage.setItem('nightly_dark_mode', 'disabled');\n\t\tdocument.body.classList.remove('nightly-dark-mode');\n\t}\n\n\ttoggle() {\n\t\tif (this.isEnabled) {\n\t\t\tthis.disable();\n\t\t} else {\n\t\t\tthis.enable();\n\t\t}\n\t}\n}\n\nexport default new DarkMode();\n"],"names":["enableDarkMode","disableDarkMode","document","addEventListener","darkMode","DarkMode","constructor","isEnabled","currentStyle","init","createFloatingSwitch","savedPreference","localStorage","getItem","enable","querySelectorAll","forEach","switchEl","classList","add","initSwitches","startStyleDemo","createSwitchElement","className","switchWrapper","createElement","trim","track","circle","appendChild","floatingSwitch","body","changeSwitchStyle","switches","toggle","s","brightness","contrast","sepia","darkSchemeBackgroundColor","darkSchemeTextColor","setItem","disable","remove"],"sourceRoot":""}